javaravishanker@gmail.com
07-OCT-24
----------
History of Java 
----------------
Name of the Language  : Java
   First Name of Java : OAK (Tree Name) 1991
         Release Date : 23rd JAN 1996
	 Developed By : James Gosling and his friends
         Project Name : Green Project
	         Java : Island, Indonesia
      Official Symbol : Coffee CUP.
      
what is a function ?
---------------------
A function is a self defined block which is used to perform some calculation, printing the data and so on.

Example :
public void sum(int x, int y)
{
}

A function is divided into two types :

 1) Predefined OR Built-in function
 2) User-defined OR Custom function

Predefined OR Built-in function
-------------------------------
A function which is developed by language creator itself called 
predefined function.

User-defined OR Custom Function 
--------------------------------
A function which is written by user for its own requirement and
specification is called User-defined function.

Advantages of Function :
-------------------------
1) Modularity : 
---------------
Dividing the bigger task into number of smaller task.

2) Easy to understand :
-----------------------
Once the task is divided into number of independent modules then it is easy to understand the entire module.

3) Reusability :
-----------------
We can reuse a particular module for 'n' number of times.

Note :In java, we always reuse our java classes.

4) Easy debugging :
-------------------
Each module is isolated from another module so the debugging is easy because we can debug only one module where we have syntax or semantics error.
================================================================
Why we pass parameter to a function ?
-------------------------------------------
We should pass parameter to a function for getting more information regarding the function.

If We don't pass parameter then the informations are not complete, It is partial information.

Example :
---------
public void deposit(double amount)
{
}

public void doSum(int x, int y)
{
}

public void sleep(int hours)
{
}
===============================================================
Why functions are called Method in java ?
------------------------------------------
In C++ language, there is a facility to write a function inside the class as well outside of the class by using scope resolution operator (::) but in java we can write a function inside the class only, we can't define a function outside of the class, that is reason functions are called Method in java.  [08-OCT-24]

----------------------------------------------------------------
09-10-2024
-----------
What is platform independency in java ?
----------------------------------------
C and C++ programs are platform dependent programs that means the .exe file created on one machine will not be executed on the another machine if the system configuration is different.

That is the reason C and C++ programs are not suitable for website development.

The role of java compiler :
---------------------------
1) Syntax verification.
2) Verify the compatibility issues (L.H.S = R.H.S)
3) Will Convert Source code into byte code.


Java is a platform independent language. Whenever we write a java program, the extension of java program must be .java. 

Now this .java file we submit to java compiler (javac) for compilation process. After successful compilation the compiler will generate a very special byte code file i.e .class file (also known as bytecode). Now this .class file we submit to JVM for execution purpose.

The role of JVM is to load and execute the .class file. Here JVM plays a major role because It converts the .class file into appropriate machine code instruction (Operating System format) so java becomes platform independent language and it is highly suitable for website development.[09-OCT-24]

Note :- We have different JVM for different Operating System that means JVM is platform dependent technology where as Java is platform Independent technology.

JVM internally contains an interpreter so it executes the code line by line. It is written in 'C'langugae hance platform dependent.

Note : All the browsers internally contain JVM are known as
       JEB (Java Enabled Browsers) browser.
----------------------------------------------------------------
**What is difference between bit code and byte code :
----------------------------------------------------
Bit code is directly understood by Operating System but on the other hand byte code is understood by JVM, JVM is going to convert this byte code into appropriate machine understandable format. [09-OCT-24]
----------------------------------------------------------------
14-10-2024
-----------
* What is the difference between JDK, JRE, JVM and JIT compiler?
----------------------------------------------------------------
Paint Diagram [14-OCT]
JDK :
-----
It stands for Java Development Kit.It contains JRE and JDK tools. It is a developer version that means by using JDK we can develop and execute java programs. 

In order to develop and execute it supports various JDK tools which are as follows :

 a) javac	: java compiler, responsible for compilation.
 b) java	: Java launcher,responsible for executing java 
                  program.
 c) jdb		: java debugger, for debugging purpose
 d) jconsole	: java Console, to display the output in the 
                  console.
 e) javap	: java Profiler, To get the details of a class
 f) javadoc	: Java documention, for Generating java 
                  documentation.
		  
JRE :
-----
It stands for Java Runtime Environment.It contains JVM and class 
libraries. It is a client version that means by using JRE we can only execute our java programs (We can't develop). From java 11 version JRE folder is removed so now, from java 11v we can execute a java program without compilation by using following 
commnd :

        java FileName.java [This is the command to directly execute our java code]
	
JVM :
-----
The main purpose of JVM to load and execute the .class file.JVM takes .class file and convert the .class file into Operating System understandable format.

JVM is platform dependent, It provides various features like
Class loading, class verification, allocating the memory for static data member, Garbage collection, Security Manager and so on.

What is the difference Compiler and Interpreter :
--------------------------------------------------
Paint Diagram [14-OCT]


What is JIT Compiler :
-----------------------
As we know, Our interpreter is slow in nature so to boost up the java execution, we have JIT (Just In time) compiler support.

It holds the repeated code instruction and native code instruction, It will directly provide these two instrution at time 
of line by line execution so our interpreter executes the code
in more efficient way hance the overall execution becomes very fast.
----------------------------------------------------------------
How many data types in java ?
------------------------------
Paint Diagram [14-OCT]

15-10-2024
-----------
What is the difference between statically typed and dynamically typed language ?
--------------------------------------------------------------
statically typed language :
----------------------------
The languages where data type is compulsory before initialization of a variable are called Statically typed language.
In these languages, once we define the type of the variable then it will hold same kind of value till the end of the program.

Example of statically typed languages :
C,C++, JSE, C# and so on

Dynamically typed language :
----------------------------
The languages where Data type is not compulsory, It is optional to initialize the variable are called Dynamically Typed Language.

In these languages we can provide all different kinds of values to the variable during the execution of the program.

Example of dynamically typed languages :
Visual Basic, Javascript, Python and so on
----------------------------------------------------------------
What is comment in java ?
--------------------------
Comments are used to enhance the readability of the code. It is ignored by the Compiler.

In java, We have 3 types of comments 

1) Single line Comment
   //

2) Multiline Commment
   /*
   
   
   */
   
3) Documentation comment 
   /**
   Name of the Project : Online Shopping
     Number of Modules : 70 Modules
          Project Date : 12th March 2024
     Last Modification : 9th Oct 2024
                Author : James Goling and his friends
   */

================================================================
WAP in java to display welcome message :
-----------------------------------------
public class Welcome
{
	public static void main(String[] args) 
	{
		System.out.println("Hello Batch 40!!!!");
	}
}


Description of main() method :
-------------------------------
public :
--------
It is an access modifier in java which defines the accessibility level of main method. Our main method must be declared as public otherwise JVM can't access our main  method so the execution of the program will not be started.

If we don't declare our main method with public access modifier then code will compile but it will not be executed by JVM.

static :
--------
As of now, we have 2 types of methods in java :

 1) static method (OBJECT IS NOT REQUIRED)
 2) non static method (OBJECT IS REQUIRED)
 
 static method :
 ---------------
 If any method declared with static keyword then it is called static method. In order to call and execute static methods, Object is not required.
 
 Case 1 :
 ---------
 If a static method declared in the same class where main method is available then we can directly call the static method from main method as shown in the Program.
 
 public class StaticTest 
{
	public static void main(String[] args) 
	{
		greet();
	}
	
	public static void greet()
	{
		System.out.println("Hello Everyone!!!");
	}
}

Case 2 :
--------
If a static method is available in another class (Where main method is not available) then to call the static method CLASS
name is required as shown in the program.
 
class Welcome
{
	public static void greet()
	{
		System.out.println("Hello Batch 40");
	}
}	
public class StaticDemo
{
	public static void main(String[] args) 
	{
		Welcome.greet();
	}
}

Our main method must be declared as static so, JVM can invoke
main method with the help of class name.

If we don't declare our main method as static then code will compile (It is a non static method) but it will not be executed by JVM.

Note : There is no any syntax rule given by java compiler that method must be public and static.
----------------------------------------------------------------
void :
------
It is a keyword in java. We should write void before the name of the method so that particular method will not return any kind of value.

If we put the return type of the method as void then there is no communication between one module to another module.[It is one way communication]

If we don't write void or any other kind of return type before the main method then code WILL NOT compile because java compiler has provided syntax rule that every method must contain return type.

Note : If main method is not declared with void then program will NOT BE executed.

Note : Without return type we can't define a method in java [Syntax Rule]
----------------------------------------------------------------
16-10-2024
----------
main() method :
---------------
It is a user-defined method because a user is responsible to define some logic inside the main method.

main() method is very important method because every program execution will start from main() method only, as well as the execution of the program ends with main() method only.
-----------------------------------------------------------------
Q) Can we write multiple method with same name ?
------------------------------------------------
Yes, We can write multiple methods with same name but parameter must be different otherwise code will not compile.

Note :- We can also write multiple main methods with different parameter but JVM will always execute the main method which takes String [] args (String array) as a parameter as shown in the program below.

public class Welcome 
{
	public static void main(String[] args) 
	{			
		System.out.println("Hello Batch 40!!!!");	
		main("NIT");
	}
	
	public static void main(String args) 
	{			
		System.out.println(args);		
	}
	
}

Output : Hello Batch 40 
         NIT
-----------------------------------------------------------------
String [] args :    
----------------
String is a predefined class in java available in java.lang package (just like header file) and args is an array variable 
of type String so, it can hold multiple values.

IQ :
----
Why the main method of java accepts String array as a parameter ?

String is a collection of alpha-numeric character so it can accept all different kind of values. Java software people has
provided String array as a parameter so it can ACCEPT MULTIPLE 
VALUES OF DIFFERENT TYPE, that means providing more wider scope to accept hetrogeneous types of values.
-----------------------------------------------------------------
System.out.println() :
----------------------
It is an output statement in java, By using this statement we can print different types of values on the console. 

In this statement System is a predefined class available in java.lang pacakage, out is a reference variable of type PrintStream class available in java.io package and println() is 
a predefined method available in PrintStream class.

Note :Actually It is HAS-A relation concept, System class has 
PrintStream class as shown below.

public class System
{
   PrintStream out = null;  //HAS-A Relation
}
-----------------------------------------------------------------
WAP in java to add two numbers :   
--------------------------------
public class Addition 
{
	public static void main(String[] args) 
	{
		int x = 100;
		int y = 200;
		int z = x + y;
		System.out.println("The Sum is :"+z);	
		
	}
}
-----------------------------------------------------------------
//WAP to add two numbers without 3rd variable :
-----------------------------------------------
public class AdditionWithout3rdVariable 
{
	public static void main(String[] args) 
	{
		int x = 100;
		int y = 200;
		System.out.println("Sum is :"+x+y); //100200
		System.out.println(+x+y); //300
		System.out.println(""+x+y); //100200
		System.out.println("Sum is :"+(x+y));
	}
}
-----------------------------------------------------------------
public class IQ 
{
	public static void main(String[] args) 
	{
		String str = 25 + 25 + "NIT" + 90 + 89;
		System.out.println(str); //50NIT9089
	}
}
----------------------------------------------------------------
Command Line Argument :
-----------------------
In java, Whenever we pass any argument to the main method then it is called Command Line Argument.

public static void main(String [] args) //Command Line Argument
{
}

By using command line argument, We can pass some value at runtime.

Advantage of command line argument is, single time compilation and number of time execution with different value.
-----------------------------------------------------------------
Programs on Command Line Argument :
-----------------------------------
public class Command 
{
	public static void main(String[] args) 
	{
		System.out.println(args[0]);
	}
}

javac Command.java
java Command Virat Rohit Rahul
Output : Virat
-----------------------------------------------------------------
public class CommandWithDifferentValues 
{
	public static void main(String[] x) 
	{
		System.out.println(x[0]);
	}
}

javac CommandWithDifferentValues.java
java CommandWithDifferentValues 78 9.0 Ravi false

Output : 78
-----------------------------------------------------------------
WAP to print first and last name using command line argument :
--------------------------------------------------------------
public class FullNameByCommand 
{
	public static void main(String[] args) 
	{
		System.out.println(args[0]);
	}
}

javac FullNameByCommand.java
java FullNameByCommand Virat Kohli   [Output is : Virat]
java FullNameByCommand "Virat Kohli"   [Output is : Virat Kohli]
-----------------------------------------------------------------
public class Command 
{
	public static void main(String[] args) 
	{
		System.out.println(args[0]);
	}
}

javac Command.java
java Command 

Output Exception : java.lang.ArrayIndexOutOfBoundsException

Note : This program is expecting at-least one value from the command line argument at runtime, if we don't provide single value then we will get an execption i.e. java.lang.ArrayIndexOutOfBoundsException
-----------------------------------------------------------------
17-10-2024
-----------
How to find out the length of an array variable ?
--------------------------------------------------
Array is an object in java, array reference variable has provided a predefined property or variable called "length" through which we can get the length of the array.

ArrayLength.java
-----------------
public class ArrayLength 
{
	public static void main(String[] args) 
	{
		int []arr = {10,20,30,40,50};
		System.out.println("Length of the array is :"+arr.length);
	}
}

ArrayLengthByCommand.java
---------------------------
public class ArrayLengthByCommand 
{
	public static void main(String[] args) 
	{
		System.out.println("Length of array is :"+args.length);
	}
}

javac ArrayLengthByCommand.java

java ArrayLengthByCommand
Length of array is : 0

java ArrayLengthByCommand Rahul
Length of array is : 1

java ArrayLengthByCommand 56 90 89
Length of array is : 3
-----------------------------------------------------------------
WAP in java to add two numbers using command line Argument :
-------------------------------------------------------------
public class CommandAddition 
{
	public static void main(String[] args) 
	{
		System.out.println(args[0] + args[1]);   
	}
}

javac CommandAddition.java
java CommandAddition 100 200 

Output : 100200

Here '+' operator will work as String concatenation operator because args is String type variable.
-----------------------------------------------------------------
How to convert String into integer :
------------------------------------
In order to convert a String into integer value, java software people has provided a predefined class called Integer, this class 
contains a static method called parseInt(String x) which accepts String as a parameter and convert this String into int type, that is the reason the return type of parseInt(String x) method is int type.

public class Integer
{
   public static int parseInt(String x)
   {
       return int value after conversion;
   }
}
-----------------------------------------------------------------
public class AdditionByCommand 
{
	public static void main(String[] args) 
	{
			
		int a = Integer.parseInt(args[0]);
		int b = Integer.parseInt(args[1]);
		
		System.out.println("Sum is :"+(a+b));
	}
}

javac AdditionByCommand.java
java AdditionByCommand 100 200 

Output->  Sum is : 300
-----------------------------------------------------------------
What is Eclipse IDE :
---------------------
Eclipse IDE :
-------------
IDE stands for "Integrated Development Environment". By using eclipse IDE, we can develop, compile and execute our java program in a single window.

The main purpose of Eclipse IDE to reduce the development time, once the development time will be reduced then automatically the cost of the project will be reduced.
----------------------------------------------------------------
How to create a Project in Eclipse IDE :
----------------------------------------
File -> new -> Project OR Java Project -> Provide the name for
the project (Batch 40) -> Finish 

---------------------------------------------------------------
What is a Package in java :
----------------------------
A package is nothing but folder in windows. It is used to arrange the classes and interfaces into a particular group.

If we arrange our java classes into a particular group by using pacakges (folders) then we will get the following two advantages :

1) Fast searching is possible.
2) Name can be reusable.

Program that describes a package is folder in windows :
--------------------------------------------------------
A package is a keyword in java and it must be the first statement of any java program.

package arithmetic;
public class Addition
{
	
}  

Command for compilation of the classes which contains Package statement. 

[javac -d . FileName.java ]

javac  -d  .  Addition.java

It will compile Addition.java, Addition.java contains arithmetic package, one package i.e folder called arithmetic will be created and automatically Addition.class file will be placed inside the package or folder called arithmetic.

Types of Packages :
---------------------------
1) Predefined OR Built-in package : The packages which are created by java software people for arranging the programs are called predefined package.

Example : java.lang, java.util, java.io, java.sql, java.net and so on

2) Userdefined Package OR Custom package : The packages which are created by user for arranging the user-defined programs are called user-defined package.

Example :
basic;
com.ravi.basic;
com.tcs.online_shopping;
----------------------------------------------------------------
18-10-2024
-----------
Command Line Argument program by using Eclise IDE :
---------------------------------------------------
WAP to find out the square of the number by using Command Line Argument.

package com.nit.command_line_argument;

public class FindSquare
{
	public static void main(String[] args) 
	{		
        int num = Integer.parseInt(args[0]);  
        System.out.println("Square of "+num+" is :"+(num*num));
	}
}

Steps to execute the command Line Argument Program using Eclipse IDE
---------------------------------------------------------------------
Right click on the program -> Run As -> Run configuration -> Verify your main class name -> select argument tab -> pass the appropriate value -> Run
---------------------------------------------------------------
WAP to find out the area of rectangle :
----------------------------------------
package com.nit.command_line_argument;

public class AreaOfRectangle {

	public static void main(String[] args) 
	{
		int length = Integer.parseInt(args[0]);
		int breadth = Integer.parseInt(args[1]);
		
		int areaOfRect = length * breadth;
		System.out.println("Area of Rectangle is :"+areaOfRect);
	}

}
------------------------------------------------------------------
How to convert String value into float and double :
---------------------------------------------------
1) String to float :
---------------------
 float x =  Float.parseFloat(String str);
 
2) String to double :
---------------------
 double y =   Double.parseDouble(String str);


WAP to find out the area of Circle by using command Line Arg:
-------------------------------------------------------------
package com.nit.command_line_argument;

public class AreaOfCircle {

	public static void main(String[] args) 
	{
	    final double PI = 3.14;  	    
	    double radius = Double.parseDouble(args[0]);
	    
	    double areaOfCircle = PI * radius * radius;
	    
	    System.out.println("Area of Circle is :"+areaOfCircle);
	    
	}

}
------------------------------------------------------------------
WAP in java to pass some value from command line argument based on the following criteria :

If the array length is 0 : It should print length is 0
If the array length is 1 : It should find the cube of the number
if the array length is 2 : It should print sum of the number
 
package com.nit.command_line_argument;

public class ArrayLengthCalculation {

	public static void main(String[] args) 
	{
		if(args.length ==0)
		{
		  System.err.println("Array Length is 0");
		}
		else if(args.length == 1)
		{
			int num = Integer.parseInt(args[0]);
			System.out.println("Cube of "+num+" is :"+(num*num*num));
			
		}
		else if(args.length == 2)
		{
			int x = Integer.parseInt(args[0]);
			int y = Integer.parseInt(args[1]);
			int sum = x + y;
			System.out.println("Sum is :"+sum);
		}	

	}

}
------------------------------------------------------------------
Program that describes how Integer.parseInt(String x) works 
internally ?

package com.nit.command_line_argument;

class Calculate
{
	public static int doSum(int x, int y)
	{
		return (x+y);
	}
}

public class CalculateDemo 
{
	public static void main(String[] args) 
	{
		
		int result =  Calculate.doSum(12, 24);
		System.out.println("Sum is :"+result);	
		
	}

}
------------------------------------------------------------------
WAP to read a character [M/F] from command line argument :
-----------------------------------------------------------
String class has provided a predefined non static method called charAt(int indexPosition) through which we can retrieve a character from the given string based on the index position.

//Program to retrieve the character from the String
package com.nit.command_line_argument;

public class CharAtDemo {

	public static void main(String[] args) 
	{
		String str = "india";
		char firstChar = str.charAt(0);
		System.out.println(firstChar);

	}

}

Program to read a character [M/F] from command line argument 
------------------------------------------------------------
package com.nit.command_line_argument;

public class ReadCharacter {

	public static void main(String[] args) 
	{
		char gender = args[0].charAt(0);
		System.out.println("Your Gender is :"+gender);
                    
	}

}
------------------------------------------------------------------
Naming convention in java :
----------------------------
Naming convention provides two important characteristics :

 a) Standard Code (Industry accepted code)
 b) Readability of the code will enhance.  

1) How to write a class in java :
----------------------------------
While writing a class in java, we should follow pascal naming convention, According to this each word first character must be capital and it should not contain any space. In java a class represents noun.

Example :
ThisIsExampleOfClass     

System
String 
Integer
CommandAddition
ArrayIndexOutOfBoundsException
DataInputStream.


2) How to write a method in java :
---------------------------------- 
While writing a method in java we should follow camel case  
naming convention, According to this naming convention first word will be in small and 2nd word onwards, each word first character must be capital. In java a method represents verb.

Example :
thisIsExampleOfMethod()
read()
readLine()
parseInt()
charAt()
toUpperCase()

3) How to write a field/variable in java :
-------------------------------------------
While writing a variable we should follow camel case naming convention but unlike method variable does not have () symbol.

Example :
----------
rollNumber    
customerName
customerBill
studentName
playerName


4) How to write a final and static variable :
---------------------------------------------
While writing the final and static variable we should follow snake_case naming convention.

Example :
Integer.MIN_VALUE  [MIN_VALUE is final and static variable]
Integer.MAX_VALUE  [MAX_VALUE is final and static variable]    
     
     
5) How to write a package :
---------------------------
A package must be written in lower case only. Generally it is reverse of company name.

com.nit.basic
com.tcs.introduction
com.wipro.shopping     
------------------------------------------------------------------
Tokens in java :
----------------
Token is the smallest unit of the program which is identified by the compiler.

Without token we can't complete statement or expression in java.

Token is divided into 5 types in java

  1) Keyword
  2) Identifier
  3) Literal
  4) Punctuators (Seperators)  
  5) Operator
  
19-10-2024
----------

Keyword
--------
A keyword is a predefined word whose meaning is already defined by the compiler.

In java all the keywords must be in lowercase only.

A keyword we can't use as a name of the variable, name of the class or name of the method.  

true, false and null look like keywords but actually they are literals.

As of now, we have 67+ keywords in java.
------------------------------------------------------------------
Identifiers :
--------------
A name in java program by default considered as identifiers.

Assigned to variable, method, classes to uniquely identify them.

We can't use keyword as an identifier. 

Ex:-

class Fan 
{
   int coil  ;
   
   void switchOn()  
   {
   }
}

Here Fan(Name of the class), coil (Name of the variable) and switchOn(Name of the Method) are identifiers.

Rules for defining an identifier :
------------------------------------
1) Can consist of uppercase(A-Z), lowercase(a-z),  digits(0-9), $ sign, and underscore (_)
2) Begins with letter, $, and _
3) It is case sensitive
4) Cannot be a keyword
5) No limitation of length 
------------------------------------------------------------------
Literals :
----------
Any constant which we are assiging to variable is called Literal.

In java we have 5 types of Literals :

1) Integral Literal
2) Floating Point Literal
3) Boolean Literal
4) Character Literal
5) String Literal

Note : null is also a literal
==================================================================
Integral Literal :
------------------
If any numeric literal does not contain any decimal OR fraction then it is called Integral Literal.
Example :  12, 90, 56, 34
 
In integral literal we have 4 data types :
   a) byte (8 bits)
   b) short(16 bits)
   c) int (32 bits)
   d) long (64 bits)

An integral literal we can represent in four different forms :
    a) Decimal Literal (Base is 10)
    b) Octal Literal (Base is 8)
    c) Hexadecimal Literal (Base is 16 [0-9 and a - f])
    d) Binary Literal (Base 2) [Available from JDK 1.7v]
    
Decimal Literal :
-----------------
By default our numeric literals are decimal literal. Here base is 10 so, It accepts 10 digits i.e. from 0-9.

Example : 
int x = 20;
int y = 123;
int z = 234;

Octal Literal :
---------------
If any Integer literal starts with 0 (Zero) then it will become octal literal. Here base is 8 so it will accept 8 digits i.e 0 to 7.

Example :

int a = 018; //Invalid becuase it contains digit 8 which is out of range
int b = 0777; //Valid
int c = 0123; //Valid

Hexadecimal Literal :
---------------------
If any integric literal starts with 0X or 0x (Zero capital X Or 0 small x) then it is hexadecimal literal. Here base is 16 so it will accept 16 digits i.e 0 to 9 and A to F OR [a to f]

Example :

int x = 0X12; //Valid
int y = 0xadd; //Valid
int z = 0Xface; //valid
int a = 0Xage; //Inavlid because character 'g' out of range

Binary Literal :
---------------
If a numeric literal starts with 0B (Zero capital B) or 0b (Zero small b) then it will become Binary literal. Binary literal is available from JDK 1.7v.
Here base is 2 so it will accept 2 digits i.e 0 and 1.

Example :
----------
int x = 0B101; //valid
int y = 0b111; //Valid
int z = 0B112; //Invalid [2 is out of range]

The deafult type is decimal literal so to generate the output for any different literal JVM converts into decimal literal.    
----------------------------------------------------------------
//Programs :
------------
//Octal Representation
public class Test 
{
	public static void main(String[] args) 
	{
		int x = 015;
		System.out.println(x);
	}
}
----------------------------------------------------------------
//Hexadecimal Representation 
-----------------------------
 public class Test 
{
	public static void main(String[] args) 
	{
		int x = 0xadd;
		System.out.println(x);
	}
}
----------------------------------------------------------------
//Binary Literal

public class Test 
{
	public static void main(String[] args) 
	{
		int x = 0b101;
		System.out.println(x);
	}
}
-----------------------------------------------------------------
By default every integral literal is of type int only. byte and short are below than int so we can assign integral literal(Which is by default int type) to byte and short but the values must be within the range. [for Byte -128 to 127 and for short -32768 to 32767]

Actually whenever we are assigning integral literal to byte and short data type then compiler internally converts into corresponding type.


byte b = (byte) 12; [Compiler is converting int to byte]
short s = (short) 12; [Compiler is converting int to short]

In order to represent long value explicitly we should use either L OR l (Capital L OR Small l) as a suffix to integral literal.

According to IT industry, we should use L bacause l looks like digit 1.
 --------------------------------------------------------------
 /* By default every integral literal is of type int only*/
public class Test4
{
public static void main(String[] args)
	{
                byte b = 128;  //error
		System.out.println(b);
		
		short s = 32768; //error
		System.out.println(s);
    }
}
---------------------------------------------------------------
//Assigning smaller data type value to bigger data type
public class Test5
{
public static void main(String[] args)
	{
   	    byte b = 125;  
		short s = b;  //Automatic type casting OR Widening 
		System.out.println(s);
	}
}
----------------------------------------------------------------
//Converting bigger type to smaller type
public class Test6
{
public static void main(String[] args)
	{
		short s = 127; 
		byte b = (byte) s;     //explicit type Casting (Narrowing)
		System.out.println(b);
	}
}
-----------------------------------------------------------------
21-10-2024
-----------
public class Test7
 {
 public static void main(String[] args)
 {
		byte x = (byte) 1L; 
		System.out.println("x value  = "+x);

		long l = 29L;
		System.out.println("l value  = "+l);

        int y =  (int)18L; 
		System.out.println("y value  = "+y);
 
  }
 }   
----------------------------------------------------------------
Is java pure Object Oriented language or not ?
-----------------------------------------------
No, Java is not a pure object oriented langauge because it is accepting primary data type, Actually any language which accepts primary data type is not a pure object oriented language.

Only Objects are moving in the network but not the primary data type so java has introduced Wrapper class concept to convert the primary data types into corresponding wrapper object.

Primary Data type           Wrapper Object
	byte		:	Byte
	short		:	Short
	int		:	Integer
	long		:	Long
	float		:	Float
	double		:	Double
	char		:	Character
	boolean		:	Boolean


Note : Apart from these 8 data types, Everything is an object in java so, if we remove all these 8 primitive data types then java will become pure OOP language.
----------------------------------------------------------------
//Wrapper claases
public class Test8 
{
	public static void main(String[] args) 
	{
		Integer x = 24;  
		Integer y = 24;
		Integer z = x + y;
		System.out.println("The sum is :"+z);	
		
		Boolean b = true;
		System.out.println(b);

		Double d = 90.90;
		System.out.println(d);

		Character c = 'A';
		System.out.println(c);
	}
}

Note : From JAVA 1.5 version we have two conecpt :

AutoBoxing : Converting Primitive to Wrapper Object (int to Integer)
UnBoxing : Converting Wrapper object back to primitive (Integer to int )
----------------------------------------------------------------
How to find out the minimum value, maximum value as well as size of different data types :

The Warpper classes like Byte, Short, Integer and Long has provided predefined static and final variables to represent minimum value, maximum value as well as size of the respective data type.

Example : 

If we want to get the minimum value, maximum value as well as size of byte data type then Byte class (Wrapper class) has provided the following final and static variables

Byte.MIN_VALUE   : -128

Byte.MAX_VALUE   :  127

Byte.SIZE        :  8 (bits format)
---------------------------------------------------------------
 //Program to find out the range and size of Integeral Data type
public class Test9 
{
	public static void main(String[] args) 
	{
		System.out.println("\n Byte range:");
		System.out.println(" min: " + Byte.MIN_VALUE);
		System.out.println(" max: " + Byte.MAX_VALUE);
		System.out.println(" size :"+Byte.SIZE);
 
		System.out.println("\n Short range:");
		System.out.println(" min: " + Short.MIN_VALUE);
		System.out.println(" max: " + Short.MAX_VALUE);
		System.out.println(" size :"+Short.SIZE);

		System.out.println("\n Integer range:");
		System.out.println(" min: " + Integer.MIN_VALUE);
		System.out.println(" max: " + Integer.MAX_VALUE);
		System.out.println(" size :"+Integer.SIZE);

		System.out.println("\n Long range:");
		System.out.println(" min: " + Long.MIN_VALUE);
		System.out.println(" max: " + Long.MAX_VALUE);
		System.out.println(" size :"+Long.SIZE);
		
	}
}
---------------------------------------------------------------
Providing _ (underscore) in integeral Literal :
------------------------------------------------
In Order to enhance the readability of large numeric literals, Java software people has provided _ from JDK 1.7V. While writing the big numbers to separate the numbers we can use _

We can't start or end an integral literal with _ we will get compilation error.

//We can provide _ in integral literal
public class Test10 
{
	public static void main(String[] args) 
	{
	    long mobile = 98_1234_5678L;
		System.out.println("Mobile Number is :"+mobile);
	}
}
----------------------------------------------------------------
public class Test11 
{
	public static void main(String[] args) 
	{
		final int x = 127;  
		byte b = x;
		System.out.println(b);
	}
}

Note : The above program will compile and execute without explicit type casting because variable is declared with 
final modifier.
----------------------------------------------------------------
How to convert decimal number to Octal, Hexadecimal and Binary :
----------------------------------------------------------------
Integer class has provided the following static methods to convert decimal to octal, hexadecimal and binary.

1) public static String toBinaryString(int x) : Will convert the decimal into binary in String format.

2) public static String toOctalString(int x) : Will convert the decimal into octal in String format.

3) public static String toHexString(int x) : Will convert the decimal into hexadecimal in String format.

Note : All the above static methods are available in Integer class.
----------------------------------------------------------------
// Converting from decimal to another number system
public class Test12 
{
      public static void main(String[] argv) 
      {
		   //decimal to Binary
           System.out.println(Integer.toBinaryString(7)); //111

		   //decimal to Octal  
           System.out.println(Integer.toOctalString(15)); //17

		   //decimal to Hexadecimal
           System.out.println(Integer.toHexString(2781)); //add 
		   
      }
}
---------------------------------------------------------------
var keyword in java :
---------------------
From java 10v, java software people has provided var keyword.

This var keyword can hold any kind of value but initialization is compulsory in the same line [compiler will come to know about the variable type based on value]

   var x = 12;   //x is int type

After initialization it will hold same kind of value till the end of the program.

              var a = 12;
	          a = true; //Invalid

It can be used for only for local variable.

//var keyword [Introduced from java 10]
public class Test13 
{
	public static void main(String[] args) 
	{
		   var x = 12;		       
		   System.out.println(x);	
		   
		    x = 90;
			System.out.println(x);
			
	            // x = "NIT";  //Invalid 
			
	}
}
===============================================================
22-10-2024
-----------
Floating Point Literal :
------------------------
If any numeric literal contains decimal or fraction then it is called Floating point literal.

Example :
---------
3.4, 90.67, 12.67, 0.1

In floating point literal we have 2 data types :
   a) float (32 bits)
   b) double (64 bits)
   
By default every floating point literal is of type double only so, the following statement will generate compilation error
        float x = 1.2;  //Invalid
	
        float f1 = (float) 1.2;  //Valid	  
	float f2 = 12.90F; //Valid	  
	float f3 = 19.15f; //Valid
	  
Even though, every floating point literal is of type double only but still compiler has provided two flavors to represent double value explicitly to enhance the readability of the code.

           double d1 = 12d;  
	   double d2 = 90D;
 
Floating point literal we can represent in exponent form with positive and negative value.

         double d1 = 15e2; [15 X 10 to the power of 2]
	 
* An integral literal we can represent in four different forms i.e decimal, octal, hexadecimal and binary but a floating point
literal we can represent in only one form i.e. decimal.
 
* An integral literal i.e byte, short, int and long we can assign to floating point literal i.e float and double but 
floating point literal we can't assign to integral literal.
----------------------------------------------------------------
//Programs :
-------------
public class Test 
{
	public static void main(String[] args) 
	{
		float f = 0.0; //error
		System.out.println(f);				
	}
}
----------------------------------------------------------------
public class Test1 
{
	public static void main(String[] args) 
	{		
		float b = 15.29F;
		float c = 15.25f;
		float d = (float) 15.30;

		System.out.println(b + " : "+c+ " : "+d);
       
	}
}
---------------------------------------------------------------
public class Test2 
{
	public static void main(String[] args) 
	{
		double d = 15.15;
		double e = 15d;
		double f = 90D;
		
		System.out.println(d+" , "+e+" , "+f);
	}
}
---------------------------------------------------------------
public class Test3 
{
	public static void main(String[] args) 
	{
		 double x = 0129.89;  

		 double y = 0167;

		 double z = 0178; //error

		System.out.println(x+","+y+","+z);
	}
}
--------------------------------------------------------------
class Test4 
{
	public static void main(String[] args) 
	{
		double x = 0X29;  

		double y = 0X91.5; //error
		
		System.out.println(x+","+y);
	}
}
---------------------------------------------------------------
public class Test5 
{
	public static void main(String[] args) 
	{
		double d1 = 15e-3;
		System.out.println("d1 value is :"+d1);		

		double d2 = 15e3;
		System.out.println("d2 value is :"+d2);		
	}
}
----------------------------------------------------------------
public class Test6 
{
	public static void main(String[] args) 
	{
		double a = 0791; //error

		double b = 0791.0; 

		double c = 0777;  

		double d = 0Xdead; 
		
		double e = 0Xdead.0; //error
	}
}
---------------------------------------------------------------
public class Test7 
{
	public static void main(String[] args) 
	{
	   double a = 1.5e3;  
	   float b = 1.5e3; //error  
	   float c = 1.5e3F; 	   
	   double d = 10; 	   
	   int e = 10.0; //error 
	   long f = 10D; //error
	   int g = 10F;  //error 
	   long l = 12.78F; //error
	}
}
----------------------------------------------------------------
//Range and size of floating point literal 
public class Test8 
{
	public static void main(String[] args)    
	{
		System.out.println("\n Float range:");
		System.out.println(" min: " + Float.MIN_VALUE);
		System.out.println(" max: " + Float.MAX_VALUE); 
		System.out.println(" size :"+Float.SIZE);

		System.out.println("\n Double range:");
		System.out.println(" min: " + Double.MIN_VALUE);
		System.out.println(" max: " + Double.MAX_VALUE);
		System.out.println(" size :"+Double.SIZE);
	}
} 
----------------------------------------------------------------
char Literal :
--------------
It is also known as Character Literal.

In char literal we have only data type i.e char data type which accepts 16 bits of memory.  

char literal we can represent in the following ways :

 a) Single character enclosed with single quotes.
    char ch = 'A';
 
 b) In older languages like C and C++ which support ASCII format
    and the range is 0 - 255, On the other hand java supports 
    UNICODE format (ASCII + NON ASCII) where the range is 0 - 65535.
           char ch = 65535;  //Valid

 c) We can assign character literal to integral literal to know the UNICODE value of that particular character.

           int x = 'A'; //Will return Unicode value of A (65)
	 
 d) A character literal we can also represent in 4 digit 
    hexadecimal number which is UNICODE representation, the 
    format is :
    
               '\udddd'  
	       
	       Here \u represents UNICODE
	       and d represents digit
 
               Minimum Range is : '\u0000'
	       Maximum range is : '\uffff'

   e) All escape sequences can also be represented by char literal.
   
             char ch = '\n';
 ---------------------------------------------------------------
 Programs :
 -----------
public class Test1 
{
	public static void main(String[] args) 
	{
		char ch1 = 'a';
		System.out.println("ch1 value is :"+ch1); 

		char ch2 = 97;   
		System.out.println("ch2 value is :"+ch2); 
      
		
	}
}
---------------------------------------------------------------
public class Test2 
{
	public static void main(String[] args) 
	{
		int ch = 'A';
		System.out.println("ch value is :"+ch);
	}
}
---------------------------------------------------------------
//The UNICODE value for ? character is 63 
public class Test3 
{
	public static void main(String[] args) 
	{
		char ch1 = 63;  
		System.out.println("ch1 value is :"+ch1);
		
		char ch2 = 64;  
		System.out.println("ch2 value is :"+ch2); 

		char ch3 = 65; 
		System.out.println("ch3 value is :"+ch3); 
	}
}
----------------------------------------------------------------
public class Test4 
{
	public static void main(String[] args) 
	{
		char ch1 = 45000;  
        System.out.println("ch1 value is :"+ch1); 

		char ch2 = 0Xadd;  		
		System.out.println("ch2 value is :"+ch2); 
		
		
	}
}

Note : We will get the output as ? because the equivalant language translator is not available in the System.
----------------------------------------------------------------
//Addition of two character in the form of Integer
public class Test5
{
public static void main(String txt[])
  {
	int x = 'A'; 
        int y = 'B';
    
	System.out.println(x + y); //131	
	System.out.println('A'+'B'); //131   
   } 
} 
----------------------------------------------------------------
//Range of UNICODE Value (65535) OR '\uffff'
class Test6 
{
	public static void main(String[] args) 
	{
		char ch1 = 65535; 
		System.out.println("ch value is :"+ch1);

		char ch2 = 65536; //error [Out of UNICODE range]
		System.out.println("ch value is :"+ch2);
	}
}
----------------------------------------------------------------
//WAP in java to describe unicode representation of char in hexadecimal format
public class Test7 
{
	public static void main(String[] args) 
	{
		int ch1 = '\u0000'; 
		System.out.println(ch1); //0

		int ch2 = '\uffff';   
		System.out.println(ch2); //65535

		char ch3 = '\u0041'; 
                System.out.println(ch3); //A  

		char ch4 = '\u0061';
		System.out.println(ch4); //a
	}
}
----------------------------------------------------------------
class Test8 
{
	public static void main(String[] args) 
	{
		char c1 = 'A';
		char c2 = 65;
		char c3 = '\u0041';

		System.out.println("c1 = "+c1+", c2 ="+c2+", c3 ="+c3);
	}
}
---------------------------------------------------------------
class Test9 
{
	public static void main(String[] args) 
	{
		int x = 'A';
		int y = '\u0041';
		System.out.println("x = "+x+" y ="+y);
	}
}
---------------------------------------------------------------
//Every escape sequence is char literal
class Test10 
{
	public static void main(String [] args) 
	{
		char ch ='\n';
		System.out.println("Hello");
		System.out.println(ch);
		
	}
}
----------------------------------------------------------------
public class Test11  
{
	public static void main(String[] args) 
	{
		System.out.println(Character.MIN_VALUE); //white space
		System.out.println(Character.MAX_VALUE); //?
		System.out.println(Character.SIZE); //16 bits
		
	}
}
----------------------------------------------------------------
boolean literal :
-----------------
It is used to represent two states i.e true or false.

Here we have only one data type i.e boolean data type which accepts 1 bit of memory or depends upon JVM implementation.

         boolean isValid = true;
	 boolean isEmpty = false;
	 
Unlike C and C++ we can't assign 0 and 1 to boolean data type becuase in java 0 and 1 are treated as int type.	 
	 
	 boolean x = 0; [Valid in C but invalid in java]
	 boolean y = 1; [Valid in C but invalid in java]
	 
	 
We can't assign String value to boolean type as shown below :

         boolean b = "true"; //Invalid

Programs :
----------
public class Test1
{
    public static void main(String[] args)
    {
        boolean isValid = true;   
        boolean isEmpty = false;
		
        System.out.println(isValid);
        System.out.println(isEmpty);
     }
}
---------------------------------------------------------------
public class Test2
{
    public static void main(String[] args)
    {
	boolean c = 0; //error
        boolean d = 1; //error
        System.out.println(c);
        System.out.println(d);       
    }
}
----------------------------------------------------------------
public class Test3 
{
	public static void main(String[] args) 
	{
		boolean x = "true";  
		boolean y = "false";  
		System.out.println(x);
               System.out.println(y); 
	}
}
----------------------------------------------------------------
String Literal :
-----------------
String is a predefined class available in java.lang Package.

String is a collection of alpha-nemeric character which is enclosed by double quotes. These characters can be alphabets, numbers, symbol or any special character.

In java we can create String object by using following 3 ways :

 1) By using String Literal 
    String str1 = "india";    
    
2) By using new keyword 
   String str2 = new String("Hyderabad");
     
3) By using Character array [Old Technique]
   char ch[] = {'R', 'A', 'J'};
----------------------------------------------------------------
Programs :
----------
//Three Ways to create the String Object
public class StringTest1 
{
	public static void main(String[] args) 
	{
		String s1 = "Hello World";       //Literal
		System.out.println(s1);

		String s2 = new String("Ravi"); //Using new Keyword
		System.out.println(s2);

		char s3[] = {'H','E','L','L','O'}; //Character Array 
		System.out.println(s3);

	}
}
---------------------------------------------------------------
//String is collection of alpha-numeric character
public class StringTest2 
{
	public static void main(String[] args) 
	{
		String x="B-61 Hyderabad";
		System.out.println(x);
		
		String y = "123";  
		System.out.println(y);

		String z = "67.90";       
		System.out.println(z);

		String p = "A";        
		System.out.println(p);
	}
}
---------------------------------------------------------------
//IQ
public class StringTest3
{
	public static void main(String []args)
	{		
		String s = 15+29+"Ravi"+40+40; 
		System.out.println(s);	
		
	}
}
---------------------------------------------------------------
4) Punctuators :
----------------
It is  also called separators.

It is used to inform the compiler how things are grouped in the code.

()  {}   []   ;   ,   .   @    (var args)  
---------------------------------------------------------------
What is a local variable ?
---------------------------
If a variable is declared inside the body of method OR block OR Constructor then it is called Local /Automatic/ Stack/
temporary variable.

Example :
---------
public void accept()
{
   int x = 100;  //x is a local variable
}

A local variable must be initialized by the developer before 
use because local variable does not have any default value.

We can't apply any kind of modifier on local variable except final.

public void accept()
{
   final int x = 100;  //final is a valid modifier
}

As far as it's scope is concerned, It must be used within the same method body only that menas we can't use local variable outside of the method body/block/constructor.

All local variables are the part of the method body, all the methods are executed in a special memory in java called Stack Memory so local variables are the part of Stack memory.

A local variable must be pre-declared and initialized before use.

public void m1()
{
  System.out.println(x); //error
  int x = 100;
}
---------------------------------------------------------------
24-10-2024
-----------
Why local variables are not accessible outside of the method ?
--------------------------------------------------------------
In java, Every methods are executed in a special memory called
Stack Memory.

Stack Memory works on LIFO (Last In First Out) basis.

In java, Whenever we call a method then a separate Stack Frame will be created for each and every method.[15-OCT]

Once the method execution is over then the corresponding method Stack frame will also be deleted from Stack Area, that is the reason we can't use local variable outside of the method. 

Each stack frame contains 3 parts :
   1) Local Variable Array
   2) Frame Data
   3) Operand Stack

Program :
---------
package com.ravi.method_execution;

public class MethodExecution 
{
	public static void main(String[] args) 
	{
		System.out.println("Main Method Started!!!");		
		m1();		
		System.out.println("Main Method Ended!!!");
	}

	public static void m1() 
	{
		System.out.println("m1 Method Started!!!");		
		m2();		
		System.out.println("m1 Method Ended!!!");
	}
	
	public static void m2() 
	{
		System.out.println("Hii I am m2 method");			
	}
}
---------------------------------------------------------------
Limitation of Commnd line Argument ?
-------------------------------------
As we know by using Command Line Argument, we can pass some value at runtime, These values are stroed in String array variable and then only the exceution of the program will be started.
In Command line Argumenet we can't ask to enter the value from our end user as shown in the Program.

Program :
----------
package com.ravi.command;

//Read Gender [M/F] from Command Line Argument
public class ReadCharacter 
{
	public static void main(String[] args)
	{
		System.out.println("Enter your Gender [M/F]");
		
		char gender =  args[0].charAt(4); 
		System.out.println("Your Gender is :"+gender);

	}

}

Note : In the above program, after providing the gender value, It is asking for Gender which is not a recommended way.

Note : charAt(int indexPosition) is a predefined non static method of String class, which is used to retrieve a character
from the given String.

public char charAt(int indexPosition) 
===============================================================
How to read the data from the End user with user friendly mesasage :

There are so many ways we can read the data from client which are as follows :

1) DataInputStream class (java.io)
2) BufferedReader class (java.io)
3) System.in.read()  (java.lang)
4) Console (java.io)
5) Scanner class (java.util)


Scanner class :
----------------
It is a predefined class available in java.util pacakge from 
JDK 1.5v.
It is used to read the data from the client with user-friendly message.

static variables of System class :
----------------------------------
System class has provided the following final and static variables which are as follows :

1) System.out : Used to print normal message.

2) System.err : Used to print error message. (Red Color)

3) System.in  : Used to read the data from the Source.

How to create an Object for Scanner class :
--------------------------------------------
Scanner sc = new Scanner(System.in); 

Non static methods of Scanner class :
--------------------------------------
1) public String next() : Used to read a single word.

2) public String nextLine() : Used to read multiple words or
                              complete line.
			      
3) public byte nextByte() : Used to read byte value.

4) public short nextShort() : Used to read short value.

5) public int nextInt() : Used to read int value.

6) public long nextLong() : Used to read long value.

7) public float nextFloat() : Used to read float value.

8) public double nextDouble() : Used to read double value.

9) public boolean nextBoolean() : Used to read boolean value.

10) public char next().charAt(0) : Will read a single characetr

---------------------------------------------------------------
WAP to read your name from end user :
-------------------------------------
import java.util.Scanner;   

public class ReadName 
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);		
		System.out.print("Enter your Name :");
		      
	        String name = sc.nextLine();
		System.out.println("Your Name is :"+name);
	}
}
--------------------------------------------------------------
WAP to read you age from Scanner class :
----------------------------------------
package com.ravi.scanner_demo;

import java.util.Scanner;

public class ReadAge 
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter your Age :");
		int age =  sc.nextInt();	
		System.out.print("Your Age is :"+age);
                sc.close();
	}

}
--------------------------------------------------------------
25-10-2024
-----------
WAP to read employee data from Scanner class :
-----------------------------------------------
package com.ravi.scanner_demo;

import java.util.Scanner;

public class EmployeeData 
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
				
		System.out.print("Enter Employee Id :");
		int empId = sc.nextInt();	
		
		System.out.print("Enter Employee Name :");
		String empName = sc.nextLine();	// \n [Buffer Problem]
		empName = sc.nextLine();
		
		System.out.println("Employee Id is :"+empId);
		System.out.println("Employee Name is :"+empName);
		
		sc.close();

	}

}
----------------------------------------------------------------
WAP to read Gender [M/F] from Scanner class :
----------------------------------------------
package com.ravi.scanner_demo;

import java.util.Scanner;

public class ReadGender {

	public static void main(String[] args)
	{
		Scanner sc = new Scanner(System.in);		
		System.out.print("Enter your Gender :");
		char gender = sc.next().charAt(0);
		System.out.println("Your Gender is :"+gender);
		sc.close();

	}

}
================================================================
5) Operators      
------------
It is a symbol which describes that how a calculation will be performed on operands.

Types Of Operators :
------------------------
1) Arithmetic Operator (Binary Operator) 

2) Unary Operators     

3) Assignment Operator

4) Relational Operator  (>, >=, <, <=, !=, ==)

5) Logical Operators (&&  ||  !)   

6) Boolean Operators (&  |)

7) Bitwise Operators (^  ~)

8) Ternary Operator

*9) Member Operator( Dot . Operator)

*10) new Operator

*11) instanceof Operator [It is also relational operator]
----------------------------------------------------------------
Basic Concepts of Operators :
-----------------------------
public class Test 
{
	public static void main(String[] args) 
	{
        int x = 15;
		int y = x++;
		System.out.println(x + " : "+ y);
	}
}
----------------------------------------------------------------
class Test 
{
	public static void main(String[] args) 
	{
        int x = 15;
		int y = --x;
		System.out.println(x + " : "+ y);
	}
}
---------------------------------------------------------------
class Test 
{
	public static void main(String[] args) 
	{
                 int x = 20;
		int y = ++20; //error
		System.out.println(x + " : "+ y);
	}
}
---------------------------------------------------------------
class Test 
{
	public static void main(String[] args) 
	{
        int x = 20;
		int y = ++(++x);
		System.out.println(x + " : "+ y);
	}
}
----------------------------------------------------------------
class Test 
{
	public static void main(String[] args) 
	{
            char ch = 'A';
	    ch++;
	    System.out.println(ch);
	}
}
----------------------------------------------------------------
class Test 
{
	public static void main(String[] args) 
	{
            double d1 = 12.89;
	    d1++;
	    System.out.println(d1);
	}
}

Note : Increment and decrement operator we can apply on any data type execpt boolean.
----------------------------------------------------------------
class Test 
{
	public static void main(String[] args) 
	{
               while(false)
		{
			System.out.println("Hello");
		}
		System.out.println("World");
	}
}
----------------------------------------------------------------
class Test 
{
	public static void main(String[] args) 
	{
		boolean b = false;
        while(b)
		{
			System.out.println("Hello");
		}
		System.out.println("World");
	}
}
----------------------------------------------------------------
class Test 
{
	public static void main(String[] args) 
	{
		final int x = 10;
		final int y = 20;
        while(x > y)
		{
			System.out.println("x is Greater than y");
		}
		System.out.println("Hello World");
	}
}
---------------------------------------------------------------
class Test 
{
	public static void main(String[] args) 
	{
		do
		{
			int x = 1;
			System.out.println("Hello");
			x++;
		}
		while (x<=10); //error
	}
}
----------------------------------------------------------------
class Test 
{
	public static void main(String[] args) 
	{
		int x = 1;
		do
		{			
			System.out.println("Hello");
			x++;
			     
			boolean b = false;			   
			if(b = true)       
				break;			
		}
		while (x<=10);
	}
}
----------------------------------------------------------------
Expression Conversion :
-----------------------
Whenever we are working with Arithmetic Operator (+,-,*,/,%) or unary minus operator, after expression exeution the result will be converted (Promoted) to int type, Actually to store the result minimum 32 bits data format is required.

Unary Minus Operator :
-----------------------
class Test 
{
	public static void main(String[] args) 
	{
		int x = 15;
		System.out.println(-x);
	}
}
----------------------------------------------------------------
class Test 
{
	public static void main(String[] args) 
	{
		byte b = 1;
		byte c = 1;
		byte d = b + c;
		System.out.println(d);
	}
}
---------------------------------------------------------------
class Test 
{	
	public static void main(String[] args) 
	{		
		short s = 12;
		short t = 14;
		short u = s + t;
		System.out.println(u); 
	}
}

After Arithmetic operator expression the result will be promoted to int type so, to hold the result minimum 32 bit data is required.
---------------------------------------------------------------
class Test 
{	
	public static void main(String[] args) 
	{		
		byte s = 1;
		byte t = 1;
		byte u = s + t; //error
		System.out.println(u); 
	}
}	 
---------------------------------------------------------------	 class Test 
{	
	public static void main(String[] args) 
	{		
		byte b = 2;		
		byte c = -b; //error
		System.out.println(c);
	}
}

In Arithmetic operator OR Unary minus operator, the result will be promated to int type (32 bits) so to hold the result int data type is reqd.
----------------------------------------------------------------
class Test 
{	
	public static void main(String[] args) 
	{	
		/*
		byte b = 1;
		b = b + 2; 
		System.out.println(b); */
		
		byte b = 2;
		b += 2; //It is valid because short hand operator	 
	    System.out.println(b);
	}
}

In the above program we are using short hand operator so we will get the result in byte format also.
--------------------------------------------------------------
Program On Boolean Operator :
-----------------------------

class Test 
{	
	public static void main(String[] args) 
	{	
		 int z = 5;
		  if(++z > 5 || ++z > 6)   //Logical OR
		  {
			  z++;
		  }
		  System.out.println(z); //7 

         System.out.println("................");

		  z = 5;
		  if(++z > 5 | ++z > 6)   //Boolean OR
		  {
			  z++;
		  }
		  System.out.println(z); //8


	}
}
---------------------------------------------------------------
class Test 
{	
	public static void main(String[] args) 
	{	
		
		int z = 5;
		if(++z > 6 & ++z> 6)
		{
			System.out.println("Inside If");
			z++;			
		}
		System.out.println(z);


	}
}
----------------------------------------------------------------
Working with Bitwise AND(&), Bitwise OR(|) and Bitwise X-OR (^) :
----------------------------------------------------------------
class Test 
{	
	public static void main(String[] args) 
	{	
		
		System.out.println(true ^ false);
	}
}
Here we will get the output based on the input i.e Same input output will be zero.
----------------------------------------------------------------
class Test 
{	
	public static void main(String[] args) 
	{			
		System.out.println(5 & 6); //4
		System.out.println(5 | 6); //7
		System.out.println(5 ^ 6); //3
	}
}
-----------------------------------------------------------------
Bitwise Complement Operator (~)
--------------------------------
It will not work with boolean.

public class Test 
{
	public static void main(String [] args) 
	{	
		System.out.println(~ true); //error
		
	}
	
}  
------------------------------------------------------------------
public class Test 
{
	public static void main(String [] args) 
	{	
		System.out.println(~ 5); //-6
		System.out.println(~ -4); //3
		
	}
	
}  
----------------------------------------------------------------
Member Operator (.) :
----------------------
It is also known as Dot operator OR Period.
It is used to access the member of the class.
If we want to access the variables OR methods which are available in the class then we should use member access Operator.

package com.ravi.m1;

class Welcome
{
	static int x = 100;  //static variable
	
	public static void accept() //static method
	{
		System.out.println("Accept static method");
	}
}

public class MemberOperator {

	public static void main(String[] args) 
	{
		System.out.println(Welcome.x);
		Welcome.accept();

	}

}

Note : Welcome class contains static variable and static method so, we can directly call static veraible and static method with the help of class name using dot operator.
----------------------------------------------------------------
26-10-2024
-----------
new keyword :
-------------
It is a keyword as well as Operator.

It is used to create the Object so by using Object reference we 
can access the non static member of the class.

It is used to provide default values to non static variable.

package com.ravi.new_keyword;

class Welcome
{
	int x = 500; //non static variable
	
	public void show() //non static method
	{
		System.out.println("Hello batch 40");
	}	
}

public class NewKeywordDemo 
{
	public static void main(String[] args) 
	{		
		Welcome w = new Welcome();		
		System.out.println(w.x);
		w.show();

	}

}
---------------------------------------------------------------
Limitation of if else :
-----------------------
The major drawback with if condition is, it checks the condition again and again so It increases the burdon over CPU so we introduced switch-case statement to reduce the overhead of the CPU.

Switch case statement in java :
-------------------------------
It is a selective statement so, we can select one statement among the available statements.

break is optional but if we use break then the control will move from out of the switch body.

We can write default so if any statement is not matching then default will be executed.

In switch case we can't pass long, float and double and boolean value.

[long we can pass in switch case from java 14v]

We can pass String from JDK 1.7v and we can also pass enum from JDK 1.5v.   
---------------------------------------------------------------
import java.util.*;
public class SwitchDemo 
{
	public static void main(String[] args) 
	{	
		Scanner sc = new Scanner(System.in);
        System.out.print("Please Enter a Character :"); 
		char colour = sc.next().toLowerCase().charAt(0);	

		switch(colour)      
		{
		case 'r' : System.out.println("Red") ; break;
		case 'g' : System.out.println("Green");break;
		case 'b' : System.out.println("Blue"); break;
		case 'w' : System.out.println("White"); break;
		default : System.out.println("No colour");
		}
		System.out.println("Completed") ;
	}
}
---------------------------------------------------------------
import java.util.Scanner;
public class SwitchDemo1
{
public static void main(String args[]) 
  {	
		System.out.println("\t\t**Main Menu**\n");	
		System.out.println("\t\t**100 Police**\n");
		System.out.println("\t\t**101 Fire**\n");
		System.out.println("\t\t**102 Ambulance**\n");
		System.out.println("\t\t**139 Railway**\n");
		System.out.println("\t\t**181 Women's Helpline**\n");		

		System.out.print("Enter your choice :");
		Scanner sc = new Scanner(System.in);
		int choice = sc.nextInt();	
		
		switch(choice)
		{
		case 100:
		System.out.println("Police Services");
		break;
		case 101:
		System.out.println("Fire Services");
		break;
		case 102:
		System.out.println("Ambulance Services");
		break;
		case 139:
		System.out.println("Railway Enquiry");
		break;
		case 181:
		System.out.println("Women's Helpline ");
		break;
		default:
		System.out.println("Your choice is wrong");		
		} 
    }
}
----------------------------------------------------------------
Passing String value in switch case :
--------------------------------------
import java.util.*;
public class SwitchDemo2 
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter the name of the season :");
		String season = sc.next().toUpperCase();

		switch(season)  //String allowed from 1.7
		{
			case "SUMMER" :
				 System.out.println("It is summer Season!!");
			 break;

			 case "RAINY" :
				 System.out.println("It is Rainy Season!!");
			 break;
		}
	}
}
----------------------------------------------------------------
public class Test 
{	
	public static void main(String[] args) 
	{	
	   long l = 12L;

	   switch(l) //error
		{
           case 12L :
	   System.out.println("It is case 12");
		   break;
		}
	}

}
---------------------------------------------------------------
public class Test 
{	
	public static void main(String[] args) 
	{	
	   float l = 12;

	   switch(l)
		{
           case 12F :
			   System.out.println("It is case 12");
		   break;
		}
	}

}


Note : We can't pass long, float and double value.
-----------------------------------------------------------------------
public class Test 
{	
	public static void main(String[] args) 
	{	
	        int x = 12;
		int y = 12;

	        switch(x)
		{
                   case y :  //error
			   System.out.println("It is case 12");
		   break;
		}
	}

}

Note : In the label of switch we should take constant value.
---------------------------------------------------------------
public class Test 
{	
	public static void main(String[] args) 
	{	
	   int x = 12;
		final int y = 12;

	   switch(x)
		{
                    case y :
			   System.out.println("It is case 12");
		   break;
		}
	}

}
---------------------------------------------------------------
public class Test 
{	
	public static void main(String[] args) 
	{	
	   byte b = 90;

	   switch(b)
		{
           case 128 :  //error
			   System.out.println("It is case 127");
		   break;
		}
	}

}

Note : Value 128 is out of the range of byte and same applicable for short data type
----------------------------------------------------------------
Loops in java :
---------------
A loop is nothing but repeatation of statements based on the 
specified condition.

In java we have 4 types of loops :
----------------------------------
1) do-while loop
2) while loop
3) for loop
4) for each loop
----------------------------------------------------------------
program on do-while loop :
--------------------------

public class DoWhile 
{
	public static void main(String[] args) 
	{
		do
		{
			int x = 1;  //Local Variable (block Level)
			System.out.println("x value is :"+x);
			x++;
		}
		while (x<=10); //error
	}
}

Note : x is a block level variable because It is declared inside do block so the scope of this x variable will be within the do block only.
--------------------------------------------------------------
package com.ravi.loop;

public class DoWhileDemo {

	public static void main(String[] args) 
	{
		int x = 1;
		do
		{
			System.out.println("x value is :"+x);
			x++;
		}
		while(x<=10);

	}

}
--------------------------------------------------------------
package com.ravi.loop;

public class WhileLoop {

	public static void main(String[] args) 
	{
		int x = 1;
		
		while(x>=-10)
		{
			System.out.println(x);
			x--;
			
		}

	}

}
---------------------------------------------------------------
//Program on for loop
package com.ravi.loop;

public class ForLoop {

	public static void main(String[] args) 
	{
	 for(int i=1; i<=10; i++)
	 {
		 System.out.println(i);
	 }
	}

}
--------------------------------------------------------------
28-10-2024
------------
For Each loop :
---------------
It is an enhanced for loop.
It is introduced from JDK 1.5v.
It is used to retrieve OR Iterate the values one by one from the Collection like array.

package com.ravi.for_each_loop;

public class ForEachDemo1 {

	public static void main(String[] args) 
	{
	    int []arr = {20,40,60,50,89,56,45};
		
	    for(int x : arr)
	    {
	    	System.out.println(x);
	    }
	}
}

Note : Internally the compiler will convert this for-each loop into Ordinary for loop.
--------------------------------------------------------------
How to sort Array data :
--------------------------
In java.util pacakge, there is a predefined class called Arrays which has various static methods to sort the array in ascending or alphabetical order.

Example :
           Arrays.sort(int []arr);  //For sorting int array
	   Arrays.sort(Object []arr) //For sorting String array

--------------------------------------------------------------
package com.ravi.for_each_loop;

public class ForEachDemo2 {

	public static void main(String[] args) 
	{
		int [] values = {30,10,20,50,40};
		
		java.util.Arrays.sort(values);
		
		for(int value : values)
		{
			System.out.println(value);
		}

	}

}
-------------------------------------------------------------
package com.ravi.for_each_loop;

import java.util.Arrays;

public class ForEachDemo3 {

	public static void main(String[] args) 
	{
		String []fruits = {"Mango","Apple","Guava","Grapes"};
		
		Arrays.sort(fruits);
		
		for(String fruit : fruits)
		{
			System.out.println(fruit);
		}

	}

}
-------------------------------------------------------------
In java, Can we hold hetrogeneous types of data using array ?
-------------------------------------------------------------
Yes, by using Object array we can hold hetrogeneous type of data but we can't peform sorting operation using Arrays.sort(), It will generate 
java.lang.ClassCastException

package com.ravi.for_each_loop;

public class ForEachDemo4 
{
	public static void main(String[] args) 
	{
		Object []arr = {'A',12,89.67,true, new String("NIT")};
		
		//Arrays.sort(arr); //java.lang.ClassCastException
		
		for(Object x : arr)
		{
			System.out.println(x);
		}

	}

}
-------------------------------------------------------------
What is BLC and ELC class in java ?
------------------------------------
BLC :
------
BLC statnds for Business Logic class, In this class we are responsible to write the logic. This class will not contain main method.
The main purpose of this BLC class to reuse this class in various packages.

Example :
----------
//BLC
public class Calculate
{
  //Here We are responsible to write the logic
}


ELC :
-----
It stands for Executable Logic class, It will not contain any logic but the execution of the program will start from this ELC class because it contains main method.

Example :
---------
//ELC
public class Main
{
  public static void main(String [] args)
  {
  }
}

============================================================
How to reuse a class in java ?
-------------------------------
The slogan of java is "WORA" write once run anywhere.

A public class created in one package can be reuse from different packages also by using import statement.

In a single .java file, we can declare only one public class that must be our .java file and that class can be reusable to all the packages.

*In a single java file, we can write only one public class and multiple non-public classes but it is not a recommended approach because the non public class we can use within the same package only.

So the conclusion is, we should declare every java class in a separate file to enhance the reusability of the BLC classes.
[Note we have 10 classes -> 10 java files]

How many .class file will be created in the above approach :
------------------------------------------------------------
For a public class in a single file, Only 1 .class file will be created.

For a public class in a single file which contains n number of non public classes then compiler will generate n number of .class file.

Example :
----------
Test.java
----------
public class Test  
{
	
}

class A
{
}

class B
{
}

class C
{
}

Note : Here total 4 .class file will be generated.
-------------------------------------------------------------
Here we have 2 packages :
-------------------------
com.ravi.application
com.ravi.execution 

Calculate.java(BLC) [Available in com.ravi.application]
--------------------------------------------------------
package com.ravi.application;

//BLC
public class Calculate 
{
   public static void doSum(int x, int y)
   {
	   System.out.println("Sum is :"+(x+y));
   }
}

Main.java(ELC) [Available in com.ravi.application]
------------------------------------------------
package com.ravi.application;

//ELC
public class Main 
{
	public static void main(String[] args) 
	{
		Calculate.doSum(10, 20);
		

	}

}

ELC.java (ELC) [Available in com.ravi.execution]
------------------------------------------------
This ELC class will import Calculate.java from com.ravi.application package as shown below.

package com.ravi.execution;

import com.ravi.application.Calculate;

public class ELC  
{
	public static void main(String[] args)
	{
	        //Importing and Using Calculate class
		Calculate.doSum(10, 10);

	}

}
============================================================
29-10-2024
-----------
Working with Static Method with different return type :
-------------------------------------------------------
If a static method is defined inside the ELC class then we can directly call the static method from the main method, class name is not required.

//A static method can be directly call within the same class
package com.ravi.pack1;

public class Test1
{
	public static void main (String[] args)
	{
		square(5); 	    
	}

	public static void square(int x)
	{  
	  System.out.println("Square is :"+(x*x));
	}
}
------------------------------------------------------------
2 files :
----------
GetSquare.java
----------------
package com.ravi.pack2;

//BLC
public class GetSquare 
{
   public static void getSquareOfNumber(int num)
   {
	   System.out.println("Square of "+num+" is :"+(num*num));
   }
}

Test2.java
-----------
package com.ravi.pack2;

import java.util.Scanner;

//ELC
public class Test2 
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter the side :");
		int side = sc.nextInt();		
		
		GetSquare.getSquareOfNumber(side);
		sc.close();
		
	}
}

Here getSquareOfNumber() method return type is void so there is no communication between BLC and ELC class.
-----------------------------------------------------------
2 files :
---------

FindSquare.java
----------------
//A static method returning integer value 
package com.ravi.pack3;

//BLC
public class FindSquare
{
	public static int getSquare(int x)
	{
		return (x*x);
	}
}

Test3.java
-----------
package com.ravi.pack3;

import java.util.Scanner;

//ELC
public class Test3
{
	public static void main (String[] arg)
	{	
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter the value of side :");
		int side = sc.nextInt();
		
		System.out.println("Square of "+side+" is :"+FindSquare.getSquare(side));
		sc.close();
	  
	}
}

Note : By using System.out.println(), we can't call a method whose return type is void. We will get compilation error as shown below

2 files :
---------
BLC.java
---------
public class BLC 
{
	public static void greet() //Method return type is
	{                            void
		
	}
}


ELC.java
--------

public class ELC 
{
	public static void main(String[] args) 
	{
		System.out.println(BLC.greet()); //error
	}
}
------------------------------------------------------------
2 files :
----------
Calculate.java
--------------
/*Program to find out the square and cube of 
  the number by following criteria
 * 
a) If number is 0 or Negative it should return -1
b) If number is even It should return square of the number
c) If number is odd It should return cube of the number
*/

package com.ravi.pack4;

//BLC
public class Calculate 
{
  public static int getSquareAndCube(int num)
  {
	  if(num <=0)
	  {
		 return -1;
	  }
	  else if(num%2 == 0)
	  {
		  return num*num;
	  }
	  else
	  {
		  return num*num*num;
	  }
	  
  }
  
}






Test4.java
-----------
package com.ravi.pack4;

import java.util.Scanner;

public class Test4 
{	
   public static void main(String[] args) 
   {
	 Scanner sc = new Scanner(System.in);	 
	 System.out.print("Enter a number :");
	 int num = sc.nextInt();
	 
	 int result = Calculate.getSquareAndCube(num);
	 System.out.println("Result is :"+result);
	 
	 sc.close();	 
   }	
	
}
------------------------------------------------------------
2 files :
----------
Rectangle.java
----------------
package com.ravi.pack5;

//BLC
public class Rectangle 
{	
  public static double getAreaOfRectangle(double length, double breadth)
  {	  
	  return (length * breadth);
  }
  
}

Test5.java
-----------
package com.ravi.pack5;

import java.util.Scanner;

public class Test5 
{
	public static void main(String[] args)
	{
	  Scanner sc = new Scanner(System.in);
	  System.out.print("Enter the length of the Rect :");
	  double length = sc.nextDouble();
	  
	  System.out.print("Enter the breadth of the Rect :");
	  double breadth = sc.nextDouble();
	  
	  double areaOfRectangle = Rectangle.getAreaOfRectangle(length, breadth);
	  
	  System.out.printf("Area of Rectangle is :%.2f",areaOfRectangle);
	  
	  sc.close();
	  
	  
	}
}
------------------------------------------------------------
2 files:
---------
EvenOrOdd.java
---------------
package com.ravi.pack6;

//BLC
public class EvenOrOdd 
{
	public static boolean isEven(int num)
    {
        return (num % 2 == 0);
    }
}

Test6.java
-----------
package com.ravi.pack6;

import java.util.Scanner;

//ELC
public class Test6 
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter a Number :");
		int num = sc.nextInt();
		
	    boolean isEven = EvenOrOdd.isEven(num);
	    System.out.println(num+" is Even ?:"+isEven);
	    
	    System.out.print("Enter another Number :");
		num = sc.nextInt();
	    
	    isEven = EvenOrOdd.isEven(num);
	    System.out.println(num+" is Even ?:"+isEven);
	    sc.close();
	}

}
-----------------------------------------------------------
2 files :
----------
Circle.java
------------
//Area of Circle
//If the radius is 0 or Negative then return -1.

package com.ravi.pack7;
public class Circle 
{
  public static String getAreaOfCircle(double radius)
  {		 
	  if(radius <=0)
	  {
		  return ""+(-1);
	  }
	  else
	  {
		  final double PI = 3.14;
		  double area = PI * radius * radius;
		  return ""+area;
	  }
	  
  }
}

Test7.java
-----------
package com.ravi.pack7;

import java.util.Scanner;

public class Test7 
{
	public static void main(String[] args) 
	{   
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter the radius :");
		double radius = sc.nextDouble();
		
		String areaOfCircle = Circle.getAreaOfCircle(radius);
		
		double area = Double.parseDouble(areaOfCircle);
		
		
		System.out.printf("Area of Circle is : %.2f",area);
		sc.close();
	
	}
}
------------------------------------------------------------
2 files :
-----------
Student.java
-------------
package com.ravi.pack8;

//BLC
public class Student 
{
 public static String getStudentDetails(int roll, String name, double fees)
  {
	//[Student name is : Ravi, roll is : 101, fees is :1200.90] 
	 
	return "[Student name is :"+name+", roll is :"+roll+", fees is :"+fees+"]";
	
  }
 
 
}

Test8.java
-----------
package com.ravi.pack8;

public class Test8 
{
	public static void main(String[] args)
	{
	  System.out.println(Student.getStudentDetails(101, "Scott", 12000));
	   
	}

}
------------------------------------------------------------
2 files :
---------
Table.java
-----------
package com.ravi.pack9;

//BLC 
public class Table 
{
  public static void printTable(int num) //5 X 1 = 5
  {
	 for(int i=1; i<=10; i++)
	 {
		 System.out.println(num+" X "+i+" = "+(num*i));
	 }
	 System.out.println("==========================");
	  
  }
}


Test9.java
-----------
package com.ravi.pack9;

//ELC 
public class Test9 
{
	public static void main(String[] args) 
	{		
		for(int i=1; i<=10; i++)
		{
			Table.printTable(i);
		}
	}

}
============================================================
Types of Variable in java :
---------------------------
Based on the data type we have only 2 types of variable in java :

  1) Primitive Variables 
  2) Reference Variables 

1) Primitive Variables :
------------------------
If a variable is declared with primitive data type like byte, short, int, long and so on then it is called Primitive Variables.

Example :
          int x = 100;
	  boolean y = true;

2) Reference Variable :
-----------------------
If a variable is declared with class name, interface name, enum , record and so on then it is called reference variable.

Example :
          Student s; //s is reference variable
	  Scanner sc = new Scanner(System.in); //sc is reference variable
          Integer y = null; //y is reference variable

Note : With primitive variable we can't call a method as well as we can't  assign null literal.

       int x = null;  //Invalid

       int y = 45;
       y.m1(); //Invalid


Based on declaration position Variables are divided into 4 types :

  a) Class Variables OR Static Field
  b) Instance Variables OR Non Static Field
  c) Local /Stack/temporary/Automatic Variable
  d) Parameter Variables 

============================================================
Program on Primitive variables :
-------------------------------
package com.ravi.variables;

class Test
{
   static int a = 100; //Class Variable OR Static Field
   int b = 200; //Instance Variable OR Non Static Field
   
   public void accept(int c)
   {
	   int d = 400;
	   System.out.println("Class Variable :"+a);
	   System.out.println("Instance Variable "+b);
	   System.out.println("Parameter Variable "+c);
	   System.out.println("Local Variable "+d);
	     
   }
   
}

public class PrimitiveVariableDemo 
{
  public static void main(String[] args) 
  {
	Test t1 = new Test();
	t1.accept(300);
  }
}
------------------------------------------------------------
Program on Reference variables :
-------------------------------
package com.ravi.variables;

import java.util.Scanner;

class Student
{
	Student s = new Student();  //Non static Field
	static Scanner sc = new Scanner(System.in);//static field
}


public class ReferenceVariableDemo 
{
  public static void main(String[] args) 
  {
	 Student st1 = new Student();  //st1 is local variable
  }
  
  public static void accept(Student s) //s is a parameter variable
  {
	  
  }
}
===========================================================
30-10-2024
------------
Object Oriented Programming (OOPs) 
----------------------------------
What is an Object?
------------------
An object is a physical entity which exist in the real world.
Example :- Pen, Car, Laptop, Mouse, Fan and so on

An Object is having 3 characteristics :

   a) Identification of the Object (Name of the Object)
   b) State of the Object (Data OR Properties OR Variable of Object)
   c) Behavior of the Object (Functionality of the Object)

OOP is a technique through which we can design or develop the programs using class and object.

Writing programs on real life objects is known as Object Oriented Programming.

Here in OOP we concentrate on objects rather than function/method.

Advantages of OOP :
--------------------
1) Modularity  (Dividing the bigger task into smaller task)
2) Reusability (We can reuse the component so many times)
3) Flexibility (Easy to maintain [By using interface])

Features of OOP :
-----------------
1) Class
2) Object
3) Abstraction
4) Encapsulation
5) Inheritance
6) Polymorphism
===============================================================
What is a class?
-----------------
A class is model/blueprint/template/prototype for creating the object.

A class is a logical entity which does not take any memory.

A class is a user-defined data type which contains data member and member function.

public class Employee
{
    Employee Data (Properties) 
         +
    Employee behavior (Function/Method)
}

A CLASS IS A COMPONENT WHICH IS USED TO DEFINE OBJECT PROPERTIES AND OBJECT BEHAVIOR.
--------------------------------------------------------------
How to initialize the object properties using 
reference variable through OOP.

2 files 
-------
Student.java
------------
package com.ravi.oop_demo;

//BLC
public class Student 
{
   String name;  //Non static variable
   double height; //Non static variable
   int age; //Non static variable
   
   public void talk()
   {
	  System.out.println("Hello Everyone, My name is :"+name); 
	  System.out.println("My age is :"+age); 
	  System.out.println("and my height is :"+height); 
   }
   
   public void writeExam()
   {
	   System.out.println("Every Saturday, I am writing the exam ");
   }   
   
}

StudentDemo.java
-----------------
package com.ravi.oop_demo;

//ELC
public class StudentDemo 
{
	public static void main(String[] args)
	{
		Student raj = new Student();  
		//Initializing the object properties
        raj.name = "Raj Gourav";
        raj.age = 21;
        raj.height = 5.8;
        
        //Calling the behavior
        raj.talk(); raj.writeExam();
        
        System.out.println("...............");
        
        Student priya = new Student();
        //Initializing the object properties
        priya.name = "Priya";
        priya.age = 20;
        priya.height = 5.6;
        
        //Calling the behavior
        priya.talk(); priya.writeExam();
        
        
        
	}

}
---------------------------------------------------------------
Steps for creating Object Orineted Programming 

Step 1 :-  Create the Object based on the BLC class inside ELC 
           class.[main method]

Step 2 :- Define all the object properties and behavior inside
          the BLC class based on your imagination.

Step 3 :- Initialize all the object properties with user friendly value by using reference variable.

step 4 :- call the behavior (calling the methods)
===============================================================
01-11-2024
----------
Instance Variable OR Non Static Field :
----------------------------------------
It is a class Level Variable.

If a non static variable is declared inside a class and outside of the method then it is called Instance Variable OR non static Field.

An instance variable life starts at the time of creating the object that means without an object we can't think abount instance variable.

public class Test 
{
	int x = 100;
	
	public static void main(String[] args) 
	{	
		System.out.println("x value is :"+x); //error
	}
}

The scope of an instance variable is within the same class as well as outside of the class but It depends upon the access modifier we have applied on the instance variable.

Instance variables are represented as an Object properties so whenever we want to represent Object level data/variable/properties then we should instance/non static variable.

public class Employee
{
  int employeeId;  //Instance Variable OR Non Static field
}
===============================================================
Initializing the Object properties using Method without parameter (Using Scanner class) :
----------------------------------
2 files :
----------
Customer.java
--------------
package com.ravi.oop;

import java.util.Scanner;

//BLC
public class Customer 
{
   int customerId;
   String customerName;
   double customerBill;
   
   //Initialize the Object Properties
   public void setCustomerData()
   {
	   Scanner sc = new Scanner(System.in);
	   System.out.print("Enter Customer Id :");
	   customerId = sc.nextInt();
	   System.out.print("Enter Customer Name :");
	   customerName = sc.nextLine();
	   customerName = sc.nextLine();
	   System.out.print("Enter Customer Bill :");
	   customerBill = sc.nextDouble();
	   sc.close();
   }
   
   //Printing the Object Properties
   public void getCustomerData()
   {
	   System.out.println("Customer Id is :"+customerId);
	   System.out.println("Customer Name is :"+customerName);
	   System.out.println("Customer Bill is :"+customerBill);
   }
   
   
}

CustomerDemo.java
------------------
package com.ravi.oop;

public class CustomerDemo {

	public static void main(String[] args) 
	{
		Customer scott = new Customer();
		scott.setCustomerData();
		scott.getCustomerData();

	}

}
---------------------------------------------------------------
Initializing the object properties using parameter variable :
-------------------------------------------------------------
2 files :
---------
Employee.java
---------------
package com.ravi.oop;

public class Employee 
{
   int employeeId;
   String employeeName;
   
   public void setEmployeeData(int id, String name)
   {
	   employeeId = id;
	   employeeName = name;	   
   }
   
   public void getEmployeeData()
   {
	   System.out.println("Employee id is :"+employeeId);
	   System.out.println("Employee name is :"+employeeName);
   }
   
   
   
}

EmployeeDemo.java
------------------
package com.ravi.oop;

public class EmployeeDemo {

	public static void main(String[] args) 
	{
		Employee john = new Employee();
		john.setEmployeeData(111, "John");;
		john.getEmployeeData();
		
		Employee martin = new Employee();
		martin.setEmployeeData(222, "Martin");
		martin.getEmployeeData();
	}

}

Note : Upto here, We know total 3 ways to initialize the object
properties which are as follows :
  
   1) Using Object reference(raj.rollNumber = 122)
   2) Using Method without parameter (Scanner class)
   3) Using Method with Parameter (Park Story)
   
--------------------------------------------------------------
Constructor [Introduction]
---------------------------
If the name of the class and name of the method both are exactly same and It does not contain any return type then it is called Constructor.

Example :
-----------
public class Test
{
   public Test() //Constructor
   {
   }
}
---------------------------------------------------------------
In java, Whenever we write a class and If we don't write any kind of constructor then automatically compiler will add one 
default no argument constructor in the class at the time of compilation.

Demo.java
-----------
public class Demo
{
   //Programmer has not provided any constructor
}

javac Demo.java (Compilation)
[After compilation Demo.class file will be generated]

Demo.class
----------
public class Demo
{
  public Demo() //Default No Argument Constructor [Added by 
  {                                             java compiler]
  }
}

*Every java class must have at-least one constructor either 
 explicitly written by user OR implicitly added by java compiler.

The access modifier of default no argument constructor [added by java compiler] will depend upon class access modifier that means, If the class is public then default no argument constructor will also be public otherwise not.

Example :
---------
public class Test
{
}

javac Test.java [java compiler will compile and add default 
                 constructor]

javap Test.class [To see the Constructor added by java compiler]
===============================================================
02-11-2024
-----------
Why compiler is adding default constructor to our class :
---------------------------------------------------------
We have 2 reasons that why compiler is adding default constructor :

1) Without default constructor, Object creation is not possible in java by using new keyword, if the class does not contain user-defined constructor.

2) As we know only class level variables are having default values so,  default constructor will initialize all the instance variables with default values with the help of new keyword.
  
 Data type - Default value
   byte  - 0
   short - 0
   int   - 0
   long  - 0
   float - 0.0
   double - 0.0
   char - (space) '\u0000'  
   boolean - false
   String - null
   Object - null (For any class i.e reference variable the default value is null)

Program that describes new keyword is repsonsible to allocate 
the default values for non static variables :
--------------------------------------------
2 files :
---------
Student.java
-------------
package com.ravi.oop;

public class Student 
{
  int rollNumber;
  String studentName;
  double studentFees;
  
    
  public void getStudentData()
  {
	System.out.println("Roll Number is :"+rollNumber);  
	System.out.println("Student Name is :"+studentName);  
	System.out.println("Student Fees is:"+studentFees);  
	
  }  
  
}

StudentDemo.java
-----------------
package com.ravi.oop;

public class StudentDemo 
{
	public static void main(String[] args) 
	{
		Student raj = new Student();
		raj.getStudentData();

	}

}

Here we will get output as default values i.e 0 , null and 0.0
---------------------------------------------------------------
How to initialize the object properties with parameter variable as per our requirement :

2 files :
-----------
Employee.java
---------------
package com.ravi.oop;

public class Employee 
{
   int employeeNumber;
   String employeeName;
   double employeeSalary;
   char employeeGrade;
   
   public void setEmployeeData(int eno, String ename, double salary)
   {
	   employeeNumber = eno;
	   employeeName = ename;
	   employeeSalary = salary;
   }
   
   public void getEmployeeData()
   {
	   System.out.println("Employee Id is :"+employeeNumber);
	   System.out.println("Employee Name is :"+employeeName);
	   System.out.println("Employee Salary is :"+employeeSalary);
	   System.out.println("Employee Grade is :"+employeeGrade);
   }
   
   public void calculateEmployeeGrade()
   {
	   if(employeeSalary >=75000)
	   {
		   employeeGrade = 'A';
	   }
	   else if(employeeSalary >=50000)
	   {
		   employeeGrade = 'B';
	   }
	   else if(employeeSalary >=30000)
	   {
		   employeeGrade = 'C';
	   }
	   else
	   {
		   employeeGrade = 'D';
	   }
   }
      
   
}

EmployeeDemo.java
-----------------
package com.ravi.oop;

public class EmployeeDemo 
{
	public static void main(String[] args) 
	{
		Employee scott = new Employee();
		scott.setEmployeeData(101, "Scott", 29000);
		scott.calculateEmployeeGrade();
		scott.getEmployeeData();

	}

}
================================================================
12-11-2024
-----------
Role of instance variable while creating the Object :
-----------------------------------------------------
Whenever we create an objet in java, a separate copy of all the instance variables will be created with each and every object.

package com.ravi.oop;

public class Test 
{
    int x = 10;        
	public static void main(String[] args) 
	{
		Test t1 = new Test();
		Test t2 = new Test();
		
		++t1.x;
		--t2.x;
		
		System.out.println(t1.x); //11
		System.out.println(t2.x); //9

	}
}
----------------------------------------------------------------

What is a static field ?
------------------------
It is a class level variable.

If a variable is declared with static modifier inside a class then it is called class variable OR static field.

A static field variable will be automatically initialized with default values and memory will be allocated (even the variable is final) AT THE TIME OF LOADING THE CLASS INTO JVM MEMORY.

In order to access the static member, we need not to create an object, here class name is required.

Role of static field in Object creation :
-----------------------------------------
Whenever we create an object then a single copy of static filed is created and the same single copy is sharable by all the objects so, if we make any changes through one object, it will reflect to all the objects as shown in the program.


package com.ravi.oop;

public class Demo 
{
    static int x = 100;  //102
    
	public static void main(String[] args) 
	{
		Demo d1 = new Demo();
		Demo d2 = new Demo();
		
		++d1.x;   ++d2.x;
		
		System.out.println(d1.x);
		System.out.println(d2.x);
	}

}

So the Conclusion is :

Instance Variable = Multiple Copies with each ane every Object
Static Variable = Single Copy for all the objects.
----------------------------------------------------------------
**What is Data Hiding ?
----------------------
Data hiding is nothing but declaring our data members with private access modifier so our data will not be accessible from outer world that means no one can access our data directly from  outside of the class.

*We should provide the accessibility of our data through methods so we can perform VALIDATION ON DATA which are coming from outer world.

2 files :
----------

Customer.java
--------------
package com.ravi.data_hiding;

public class Customer 
{
   private double balance = 10000; //Data hiding
   
   public void deposit(double amount)
   {
	  //Data Validation
	   if(amount <=0)
	   {
		   System.err.println("Amount can't be deposited");
	   }
	   else
	   {
		   this.balance = this.balance + amount;
		   System.out.println("Balance after deposit is :"+this.balance);
	   }
   }
   
   public void withdraw(double amount)
   {
	  if(this.balance < amount)
	  {
		  System.err.println("Insufficient balance");
	  }
	  else
	  {
		  this.balance = this.balance - amount;
		   System.out.println("Balance after Withdraw is :"+this.balance);	 
	  }
   }
}

BankApplication.java
----------------------
package com.ravi.data_hiding;

public class BankApplication 
{
	public static void main(String[] args)
	{
		Customer raj = new Customer();
		raj.deposit(5000);
		raj.withdraw(2000);

	}

}
================================================================
13-11-2024
----------
How to print Object properties (Instance variable) using toString() method :
----------------------------------------------------------
If we want to print our object properties (Instance Variables) then we should generate(override) toString() method in our class from Object class.

Now with the help of toString() method we need not to write any display kind of method to print the object properties i.e instance variable.

In order to generate the toString() method we need to follow the steps
Right click on the program -> source -> generate toString()

In order to call this toString() method, we need to print the corresponding object reference by using System.out.println() statement.

Manager m = new Manager();
System.out.println(m); //Calling toString() method of Manager class

Employee e = new Employee();
System.out.println(e); //Calling toString() method of Employee class.

2 files :
----------
Manager.java
-------------
package com.ravi.to_string;

public class Manager 
{
	private int managerId;  
	private String managerName;  

	public void setManagerData(int managerId, String managerName) {
		this.managerId = managerId;
		this.managerName = managerName;
	}

	@Override
	public String toString() 
	{
		return "Manager [managerId=" + managerId + ", managerName=" + managerName + "]";
	}

}

ManagerDemo.java
-----------------
package com.ravi.to_string;

public class ManagerDemo 
{
	public static void main(String[] args) 
	{
		Manager scott = new Manager();
		scott.setManagerData(111, "Mr. Scott");		
		System.out.println(scott);

	}

}
================================================================
Constructor :
-------------
What is the advantage of writing constructor in our class ?
------------------------------------------------------------
If we don't write a constructor in our program then variable initialization and variable re-initialization both are done in two different lines.

If we write constructor in our program then variable initialization and variable re-initialization both are done in the same line i.e at the time of Object creation. [13-NOV]

With Constructor approach, we need not to depend on method to re-initialize our instance variable with user value.
----------------------------------------------------------------
Defination of Constructor :
---------------------------
It is used to construct the object so it is called Constructor.

If the name of the class and name of the method both are exactly same and It should not contain any return type then it is called constructor.

The main purpose of constructor to initialize the object properties (Instance Variables) with user-defined value.

Every class must contain at-least one constructor either implicitly added by compiler or explicitly written by user.

Every time we create an object in java by using new keyword, at-least one constructor must be invoked.

A constructor never contain any return type including void also.

Example :
package com.ravi.command;

class Student
{
  public void Student() //Method
  {
	  System.out.println("I am Method");
  }  
  
  public static void main(String [] args)
  {
     Student s1 = new Student();
     s1.Student();
  }
}

A constructor may contain return keyword but not return keyword with value.

package com.ravi.command;

class Student
{
  public Student() 
  {
	  System.out.println("I am Constructor");
	  return;
  }  
  
  public static void main(String [] args)
  {
     Student s1 = new Student();
     
  }
}

A constructor is automatically called and executed at the time of creating the object.
================================================================
Types of Constructor :
----------------------
We have 3 types of Constructor :
--------------------------------
1) default no argument constructor (Added by compiler)
2) Non parameterized OR No Argument OR Zero Argument Constructor
   (Added by user for default value initialization)
3) Parameterized constructor 

default no argumenet constructor :
----------------------------------
Whenever we write a class and if we don't write any type of constructor then automatically one default constructor is added by the compiler.

The access modifier of default constaructor would be same as class access modifier.

It does not accept any parameter.

Example.java
--------------
public class Example 
{

}

javac Example.java

Example.class
------------
public class Example
{
   public Example() //default constructor
   {
   }
}

---------------------------------------------------------------
2) No Argument OR Parameter-less OR Non parameterized OR Zero
   argument Constructor.

If a user defines a constructor inside a class without argument then it is called no argument constructor.

No argument constructor and default constructor, both look like same the only difference is, default constructor means added by compiler and no argument constructor means written by user.

public class Student
{
  private int rollNumber;
  private String studentName;
  
  public Student() //No Argument Constructor
  {
     rollNumber = 111;
     studentName = "Raj";
  }
  
}  
  
No argument constructor is not recommended to initialize our object properties because due to no argument constructor all the object properties will be initialized with SAME VALUE as shown in the program. It is mainly used to initialized our object properties with default value.

2 files :
---------
Person.java
------------
package com.ravi.no_args;

public class Person {
	private int personId;
	private String personName;

	public Person() 
	{
		personId = 111;
		personName = "Scott";
	}

	@Override
	public String toString() {
		return "Person [personId=" + personId + ", personName=" + personName + "]";
	}

}

     
NoArgumentConstructor.java
---------------------------

package com.ravi.no_args;

public class NoArgumentConstructor {

	public static void main(String[] args) 
	{
		Person scott = new Person();
		System.out.println(scott);
		
		System.out.println(".........");
		Person smith = new Person();
		System.out.println(smith);

	}

}

In the above program smith and scott both objects are initialized with same data so not a recommened way.
----------------------------------------------------------------
Parameterized Constructor :
---------------------------
If we pass one or more argument to the constructor then it is called parameterized constructor.

By using parameterized constructor all the objects will be initialized with different values.

Example :
----------
public class Employee
{
   int id;
   String name;
   
   public Employee(int id, String name)
   {
      this.id = id;
      this.name = name;
   }
 }
---------------------------------------------------------------
Dog.java
---------
package com.ravi.first_complete_oop;

public class Dog 
{
	private String dogName;
	private int dogAge;
	private double dogHeight;
	
	public Dog(String dogName, int dogAge, double dogHeight) 
	{
		super();
		this.dogName = dogName;
		this.dogAge = dogAge;
		this.dogHeight = dogHeight;
	}

	@Override
	public String toString() {
		return "Dog [dogName=" + dogName + ", dogAge=" + dogAge + ", dogHeight=" + dogHeight + "]";
	}
}

ParameterizedConstructor.java
-----------------------------
package com.ravi.first_complete_oop;

public class ParameterizedConstructor
{
	public static void main(String[] args) 
	{
		Dog tommy = new Dog("Tommy", 5, 3.5);
		System.out.println(tommy);
		
		Dog tiger = new Dog("Tiger",6,4.4);
		System.out.println(tiger);

	}

}

---------------------------------------------------------------
Upto here, by using following ways we can initialize the Object Properties :
-----------------------------------------------------------------
1) By using Object reference
2) By using Method without parameter
3) At the time of variable declaration
4) Using No Argument Constructor
5) Using parameterized Constructor
=====================================================================
How to write setter and getter methods :
-----------------------------------------
public class Customer
{
   private double customerBill; 
   
   //Initialize the customerBill using parameterized constructor
   public Customer(double customerBill)
   {
      this.customerBill = customerBill;
   }

   //Writing setter to modify the existing customerBill
     public void setCustomerBill(double customerBill)
     {
      this.customerBill = customerBill;
     }
   
   //Writing getter to retrieve the private data value outside of BLC class
   public double getCustomerBill()
   {
      return this.customerBill;
   }
}
--------------------------------------------------------------------
FINAL CONCLUSION :
-------------------
Parameterized Constructor : To initialize the Object properties with user values.

Setter : To modify the existing object data.[Only one data at a time] OR Writing Operation

Getter : To read/retrieve private data value outside of BLC class. [Reading Operation]

toString() : To print Object properties (Instance Variable)
--------------------------------------------------------------------
*** What is Encapsulation 
--------------------------
[Accessing our private data with public methods like setter and getter]
--------------------------------
Binding the private data with its associated method in a single unit is called Encapsulation.

Encapsulation ensures that our private data (Object Properties) must be accessible via public methods like setter and getter.

It provides security because our data is private (Data Hiding) and it is only accessible via public methods WITH PROPER DATA VALIDATION.

In java, class is the example of encapsulation.


How to achieve encapsulation in a class :
------------------------------------------
In order to achieve encapsulation we should follow the following two 
techniques :

1) Declare all the data members with private access modifiers (Data Hiding OR Data Security)

2) Write public methods to perform read(getter) and write(setter) operation on these private data like setter and getter.

Note : If we decalre all our data with private access modifier then it is called TIGHTLY ENCAPSULATED CLASS. On the other hand if we declare our data other then private access modifier then it is called Loosely Encapsulated class.

//Program on Encapsulation :
-----------------------------
2 files :
---------
Employee.java
--------------
package com.ravi.setter_getter;

public class Employee
{
	private String employeeName;
	private double employeeSalary;

	public Employee(String employeeName, double employeeSalary) {
		super();
		this.employeeName = employeeName;
		this.employeeSalary = employeeSalary;
	}

	@Override
	public String toString() {
		return "Employee [employeeName=" + employeeName + ", employeeSalary=" + employeeSalary + "]";
	}

	public String getEmployeeName() 
	{
		return this.employeeName;
	}

	public void setEmployeeName(String employeeName)
	{
		this.employeeName = employeeName;
	}

	public double getEmployeeSalary() 
	{
		return this.employeeSalary;
	}

	public void setEmployeeSalary(double employeeSalary) 
	{
		this.employeeSalary = employeeSalary;
	}	
}

EmployeeDemo.java
-------------------
package com.ravi.setter_getter;

import java.util.Scanner;

public class EmployeeDemo {

	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter Employee Name :");
		String name = sc.nextLine();
		System.out.print("Enter Employee Salary :");
		double salary = sc.nextDouble();
		
		Employee emp = new Employee(name,salary);
        System.out.println(emp);
        
        emp.setEmployeeSalary(emp.getEmployeeSalary()+10000);
        System.out.println(emp);
        
        
        //Based on the salary, I want to known whether employee
        // is Developer, Designer OR Tester
        
        double sal = emp.getEmployeeSalary();
        
        if(sal>=75000)
        {
        	System.out.println(emp.getEmployeeName()+" is a Developer");
        }
        else if(sal>=50000)
        {
        	System.out.println(emp.getEmployeeName()+" is a Designer");
        }
        else
        {
        	System.out.println(emp.getEmployeeName()+" is a Tester");
        }
        		
	}

}
---------------------------------------------------------------------
Method return type as a class :
-------------------------------
While declaring a method in java, return type is compulsory.
As a method return type we have following options

1) void as a retutn type of the Method

2) Any primitive data type as a return type of the method.

3) Any class name/interface / enum / record we can take as a return type of the method.

Example 1 :
-----------
package com.nit;

public class Demo 
{
  public Demo m1() //Factory Method
  {
	 return this; //Valid
	     OR
	 return null;  //Valid
	     OR
	  return new Demo();  //Valid 
  }
}

Example 2 :
-----------
package com.nit;

public class Demo 
{
  int x;
  
  public Demo(int x)
  {
	  this.x = x;
  }
	
  public Demo m1() 
  {
	 return new Demo(8);
	
  }
}

Note : Here the return value depends upon the available constructor in the class.
====================================================================
What is a Factory Method :
--------------------------
If a method return type is class name menas it is returning the Object of the class then it is called Factory Method.

---------------------------------------------------------------------
//Program on Method return type as a class :
--------------------------------------------
2 files :
---------
Book.java
----------
package com.ravi.factory_method;

public class Book 
{
	private String authorName;
	private String bookTitle;

	public Book(String authorName, String bookTitle) 
	{
		super();
		this.authorName = authorName;
		this.bookTitle = bookTitle;
	}

	@Override
	public String toString() {
		return "Book [authorName=" + authorName + ", bookTitle=" + bookTitle + "]";
	}
	
	public static Book getBookObject()
	{
		return new Book("James Gosling", "Java");
	}

}


BookDemo.java
--------------
package com.ravi.factory_method;

public class BookDemo {

	public static void main(String[] args) 
	{
		Book object = Book.getBookObject();
		System.out.println(object);
	}

}

In the avove program getBookObject() is providing only one Book object so it is not recommended because the main purpose of any method to provide re-usability as shown in the program below.

Employee.java
-------------
2 files :
----------
package com.ravi.factory_method;

import java.util.Scanner;

public class Employee 
{
	private int employeeId;
	private String employeeName;
	private double employeeSalary;

	public Employee(int employeeId, String employeeName, double employeeSalary) {
		super();
		this.employeeId = employeeId;
		this.employeeName = employeeName;
		this.employeeSalary = employeeSalary;
	}

	@Override
	public String toString() {
		return "Employee [employeeId=" + employeeId + ", employeeName=" + employeeName + ", employeeSalary="
				+ employeeSalary + "]";
	}
	
	public static Employee getEmployeeObject()
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter Employee Id :");
		int id = sc.nextInt();
		
		System.out.print("Enter Employee Name :");
		String name = sc.nextLine();
		name = sc.nextLine();
		
		System.out.print("Enter Employee Salary :");
		double sal = sc.nextDouble();
		
		return new Employee(id, name, sal);
	}

}

EmployeeDemo.java
------------------
package com.ravi.factory_method;

import java.util.Scanner;

public class EmployeeDemo {

	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("How many Objects you want ?");
		int noOfObj = sc.nextInt();
		
		for(int i=1; i<=noOfObj; i++)
		{
		    Employee object = Employee.getEmployeeObject();
		    System.out.println(object);
		    
		}
		sc.close();
		
	}

}
---------------------------------------------------------------------
15-11-2024
-----------
2 files :
---------
Product.java
------------
package com.ravi.factory_method;

import java.util.Scanner;

public class Product
{
	private int productId;
	private String productName;
	private double productPrice;

	public Product(int productId, String productName, double productPrice) 
	{
		super();
		this.productId = productId;
		this.productName = productName;
		this.productPrice = productPrice;
	}

	@Override
	public String toString() 
	{
		return "Product [productId=" + productId + ", productName=" + productName + ", productPrice=" + productPrice
				+ "]";
	}

	public static Product getProductObject()
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter Product Id :");
		int id = sc.nextInt();
		System.out.print("Enter Product Name :");
		String pname = sc.nextLine();
		pname = sc.nextLine();
		System.out.print("Enter Product Price :");
		double price = sc.nextDouble();
		
		return new Product(id, pname, price);
		
	}
	
}

ProductDemo.java
-----------------
package com.ravi.factory_method;

import java.util.Scanner;

public class ProductDemo {

	public static void main(String[] args)
	{
	   Scanner sc = new Scanner(System.in);
	   System.out.print("How many product object :");
	   int noOfObj = sc.nextInt();
	   
	   for(int i=1; i<=noOfObj; i++)
	   {
		   Product object = Product.getProductObject();
		   System.out.println(object);
	   }
	   sc.close();

	}

}
---------------------------------------------------------------------
What is Shallow and Deep copy in java :
----------------------------------------
Shallow Copy :
--------------
In Shallow copy, Only one Object will be created but the same object will be refered by multiple reference variables.

If we modify the object properties by any of the reference variable then original object will be modified as shown in the program.-

2 files :
---------
Laptop.java
-----------
package com.ravi.shallow_copy;

public class Laptop 
{
	private String laptopBrand;
	private double laptopPrice;

	public Laptop(String laptopBrand, double laptopPrice) {
		super();
		this.laptopBrand = laptopBrand;
		this.laptopPrice = laptopPrice;
	}

	@Override
	public String toString() {
		return "Laptop [laptopBrand=" + laptopBrand + ", laptopPrice=" + laptopPrice + "]";
	}

	public String getLaptopBrand() {
		return laptopBrand;
	}

	public void setLaptopBrand(String laptopBrand) {
		this.laptopBrand = laptopBrand;
	}

	public double getLaptopPrice() {
		return laptopPrice;
	}

	public void setLaptopPrice(double laptopPrice) {
		this.laptopPrice = laptopPrice;
	}
}


ShallowCopy.java
-----------------

package com.ravi.shallow_copy;

public class ShallowCopy {

	public static void main(String[] args) 
	{
		Laptop lap1 = new Laptop("HP", 86000);		
		Laptop lap2 = lap1;
		System.out.println("Before Change...");
        System.out.println(lap1);
        System.out.println(lap2);
        
        System.out.println("After Change...");
        lap2.setLaptopBrand("Dell");
        lap2.setLaptopPrice(90000);
        System.out.println(lap1);
        System.out.println(lap2);
        
		
	}

}
---------------------------------------------------------------------
Deep Copy :
-----------
In deep copy two different objects will be created, the 2nd object will copy the content of first object.

If we modify the object by using reference variable then only one object will be modified because both the objects are created in two different memory location as shown below.


Customer.java
---------------
package com.ravi.deep_copy;

public class Customer 
{
	private double customerBill;
	
	public Customer()
	{	
		customerBill = 0.0;
	}

	public Customer(double customerBill) 
	{
		super();
		this.customerBill = customerBill;
	}

	@Override
	public String toString() {
		return "Customer [customerBill=" + customerBill + "]";
	}

	public double getCustomerBill() {
		return customerBill;
	}

	public void setCustomerBill(double customerBill) {
		this.customerBill = customerBill;
	}
	
	
	

}

DeepCopy.java
---------------
package com.ravi.deep_copy;

public class DeepCopy {

	public static void main(String[] args)
	{
		Customer c1 = new Customer(12000);		
		Customer c2 = new Customer();
		c2.setCustomerBill(c1.getCustomerBill());
		
		System.out.println("Before Change...");
		System.out.println(c1);
		System.out.println(c2);
		
		c1.setCustomerBill(15000);
		
		System.out.println("After Change...");
		System.out.println(c1);
		System.out.println(c2);	

	}

}
====================================================================
***Pass by Value :
-----------------
Java does not support pointers so java only works with pass by value.

Pass by value means we are sending the copy of orginal data to the method.
---------------------------------------------------------------------
package com.ravi.pass_by_value;

public class PassByValueDemo1 
{
	public static void main(String[] args) 
	{
		int x = 10;
		accept(x);
		System.out.println(x); 
	}
	
	public static void accept(int y)
	{
		y = 100;
	}

}
--------------------------------------------------------------------
package com.ravi.pass_by_value;

public class PassByValueDemo2 {

	public static void main(String[] args) 
	{
		int x = 10;
		x = accept(x);
		System.out.println(x); 
	}
	
	public static int accept(int y)
	{
		y = 100;
		return y;
	}

}
---------------------------------------------------------------------
package com.ravi.pass_by_value;

class Product
{
	private double productPrice = 12000;

	public void setProductPrice(double productPrice) 
	{
		this.productPrice = productPrice;
	}

	@Override
	public String toString() {
		return "Product [productPrice=" + productPrice + "]";
	}
	
	
	
	
}

public class PassByValueDemo3 
{
	public static void main(String[] args) 
	{
		Product p1 = new Product();	//12000
		accept(p1);
		System.out.println(p1); //18000
	}
	
	public static void accept(Product prod)
	{
	    prod.setProductPrice(18000);
	}

}
---------------------------------------------------------------------
package com.ravi.pass_by_value;

class Product
{
	private double productPrice = 12000;

	public void setProductPrice(double productPrice) 
	{
		this.productPrice = productPrice;
	}

	@Override
	public String toString() {
		return "Product [productPrice=" + productPrice + "]";
	}	
	
}

public class PassByValueDemo4
{
	public static void main(String[] args) 
	{
		Product p1 = new Product();	//12000
		accept(p1);
		System.out.println(p1); //12000
	}
	
	public static void accept(Product prod)
	{
		prod = new Product();  //new another object
	    prod.setProductPrice(18000);
	}

}
---------------------------------------------------------------------
package com.ravi.pass_by_value;


public class PassByValueDemo5 
{
	public static void main(String[] args) 
	{
		String str = new String("Hyd");
		accept(str);
		System.out.println(str); //Hyd
	}
	
	public static void accept(String s1)
	{
		s1 = "india";
	}
	
	
}

Note : Here String object will not be modified hence we will get the output Hyd because Strings are immutable.
----------------------------------------------------------------
16-11-2024
-----------
What is Garbage Collector in java -----------------------------------
It is an automatic memory management technique in java.

In C++ language, A programmer is responsible to allocate as well as de-allocate the memory otherwise we will get OutOfMemoryError.

In java language, Programmer is only responsible to allocate the memory, Memory de-allocation is automatically done by garbage collector.

Garbage Collector is a daemon thread which is responsible to delete the objects from the HEAP Memory. Actually It scans the heap memory and identifying which objects are eligible for Garbage Collector.[THE OBJECTS WHICH DOES NOT CONTAIN ANY REFERENCES ONLY THOSE OBJECTS ARE ELIGIBLE FOR GC]

It internally uses an algorithm called Mark and Sweep algorithm to delete the un-used objects.

As a developer we can also explicitly call garbage collector by writing the following code

System.gc();
---------------------------------------------------------------

How many ways we can make an object eligible for Garbage Collector :
--------------------------------------------------------------------
There are 3 ways we can make an object eligible for GC.

1) Assigning null literal to existing reference variable :
   Employee e1 = new Employee(111,"Ravi");
            e1 = null;

2) Creating an Object inside a method :

   public void createObject()
   {
      Employee e2 = new Employee();
   }
Here we are creating Employee object inside the method so, once the method execution is over then e2 will be deleted from the Stack Frame and the employee object will become eligible for GC.

3) Assigning new Object to the old existing reference variable:
   
   Employee e3 = new Employee();
   e3 = new Employee();

Earlier e3 variable was poting to Employee object after that a new Employee Object is created which is pointing to another memory location so the first object is eligible for GC.

===============================================================
Memory in java :
------------------
In java, whenever we create an object then Object and its content (properties and behavior) are stroed in a special memory called HEAP Memory. Garbage collector visits heap memory only.

All the local variables and parameters variables are executed in Stack Frame and available in Stack Memory.
----------------------------------------------------------------
18-11-2024
----------
HEAP AND STACK DIAGRAM :
------------------------
HEAP and STACK Digram for CustomerDemo.java
-------------------------------------------
class Customer
{
	private String name; 
	private int id; 

	public Customer(String name , int id) 
	{
		super();
		this.name=name;
		this.id=id;
	}

	public void setId(int id)  
	{
		this.id=id;
	}

	public int getId() 
	{
		return this.id;
	}
}

public class CustomerDemo
{
	public static void main(String[] args) 
	{
		int val = 100;

		Customer c = new Customer("Ravi",2);

        m1(c);   
		
		//GC  [Only one object 3000x eligible for GC]
		
		System.out.println(c.getId());
	}

	public static void m1(Customer cust) 
	{
		cust.setId(5);   

	    cust = new Customer("Rahul",7);

		cust.setId(9);
		System.out.println(cust.getId());
	}
}  
    
//9 5
----------------------------------------------------------------
HEAP and STACK Diagram for Sample.java
---------------------------------------
public class Sample
{	
	private Integer i1 = 900;

	public static void main(String[] args) 
	{
		Sample s1 = new Sample();    
		                              
		Sample s2 = new Sample();       

	    Sample s3 = modify(s2); 

		s1 = null;

         //GC [4 objects 1000x, 2000x, 5000x and 6000x]
		 
		System.out.println(s2.i1);		
	}
    public static Sample modify(Sample s)
	{
		s.i1=9;
		s = new Sample();
		s.i1= 20;  
        System.out.println(s.i1);
		s=null;
		return s;
	}
}

//20 9
----------------------------------------------------------------
HEAP and STACK Diagram for Test.java
--------------------------------------
public class Test 
{
	Test t;
	int val;

	public Test(int val)  
	{
		this.val = val;
	}

	public Test(int val, Test t)
	{
		this.val = val;
		this.t = t;
	}

	public static void main(String[] args) 
	{
		Test t1 = new Test(100);
		
		Test t2 = new Test(200,t1);

		Test t3 = new Test(300,t1);

		Test t4 = new Test(400,t2);

		t2.t = t3; 
		t3.t = t4; 
		t1.t = t2.t; 
		t2.t = t4.t; 

	System.out.println(t1.t.val);
	System.out.println(t2.t.val);
	System.out.println(t3.t.val);
	System.out.println(t4.t.val);
	}
	
}  
----------------------------------------------------------------
19-11-2024
----------
HEAP and STACK Diagram for Employee.java
-----------------------------------------
public class Employee
{
	int id = 100;
	
	public static void main(String[] args) 
	{
		int val = 200;

		Employee e1 = new Employee();     

		e1.id = val;

		update(e1);	  
		
		System.out.println(e1.id);

        Employee e2 = new Employee(); 

		e2.id = 900;
        
		switchEmployees(e2,e1); //3000x, 1000x

		  //GC [2 objects 2000x and 4000x are eligible for GC]

			System.out.println(e1.id);
		    System.out.println(e2.id);
	    } 
		
	 public static void update(Employee e)  
	 {
        e.id = 500;
		e = new Employee();
		e.id = 400;
		System.out.println(e.id);
	 }

	 public static void switchEmployees(Employee e1, Employee e2)
	  {
		 int temp = e1.id; 
		 e1.id = e2.id; //500 
		 e2 = new Employee();
		 e2.id = temp;
	  }
   }

//Output 400 500 500 500
---------------------------------------------------------------
HEAP and STACK Digram for Test.java
-----------------------------------
class Test
{
int x;  
int y;  

void m1(Test t)  //1000x --m1()
{
x=x+1;
y=y+2;

t.x=t.x+3;
t.y=t.y+4;
}
public static void main(String[] args)
{
Test t1=new Test(); 
Test t2=new Test();  

t1.m1(t2);

System.out.println(t1.x+"... "+t1.y); //1  ...  2
System.out.println(t2.x+"... "+t2.y); //3  ...  4

t2.m1(t1);
System.out.println(t1.x+"... "+t1.y);
System.out.println(t2.x+"... "+t2.y);

t1.m1(t1);
System.out.println(t1.x+"... "+t1.y);
System.out.println(t2.x+"... "+t2.y);

t2.m1(t2);
System.out.println(t1.x+"... "+t1.y);
System.out.println(t2.x+"... "+t2.y);  
}
}
---------------------------------------------------------------
Passing an Object reference to the Constructor :(Copy Constructor)
--------------------------------------------------------------
We can pass an object reference to the constructor so we can copy the content of one object to another object.

public class Manager 
{
	private int managerId;
	private String managerName;

	public Manager(Employee emp) 
	{
		this.managerId = emp.getEmployeeId();
		this.managerName = emp.getEmployeeName();
	}
}



The following program explains how to copy the content of Employee object to initialize Manager class properties :

3 files :
----------
Employee.java
--------------
package com.ravi.copy_constructor;

public class Employee 
{
	private int employeeId;       
	private String employeeName;  

	public Employee(int employeeId, String employeeName) 
	{
		super();
		this.employeeId = employeeId;
		this.employeeName = employeeName;
	}
	
	

	public int getEmployeeId() {
		return employeeId;
	}



	public String getEmployeeName() {
		return employeeName;
	}



	@Override
	public String toString() 
	{
		return "Employee [employeeId=" + employeeId + ", employeeName=" + employeeName + "]";
	}
	
	
	
	

}
Manager.java
-------------
package com.ravi.copy_constructor;

public class Manager 
{
	private int managerId;
	private String managerName;

	public Manager(Employee emp) 
	{
		this.managerId = emp.getEmployeeId();
		this.managerName = emp.getEmployeeName();
	}

	@Override
	public String toString() {
		return "Manager [managerId=" + managerId + ", managerName=" + managerName + "]";
	}

}

CopyConstructor.java
---------------------
package com.ravi.copy_constructor;

public class CopyConstructor {

	public static void main(String[] args) 
	{
		Employee e1 = new Employee(111, "Scott");
		
		Manager m1 = new Manager(e1);
		System.out.println(m1);

	}

}

In the above program, using Employee class properties, we are initializing Manager class properties, both are two different classes. The following program explains how to initialize same 2nd object proprties through 1st object properties :

2 files :
---------
Product.java
-------------
package com.ravi.copy_constructor;

public class Product 
{
	private int productId;
	private String productName;

	public Product(int productId, String productName) //P p1 = new P(1,"Cam");
	{
		super();
		this.productId = productId;
		this.productName = productName;
	}
	
	public Product(Product prod)  // P p2 = new P(p1);
	{
		this.productId = prod.productId;
		this.productName = prod.productName;
	}

	@Override
	public String toString() {
		return "Product [productId=" + productId + ", productName=" + productName + "]";
	}
	

}

CopyConstructorDemo.java
------------------------
package com.ravi.copy_constructor;

public class CopyConstructorDemo {

	public static void main(String[] args)
        {
		Product p1 = new Product(1,"Camera");
		System.out.println(p1);
		
		Product p2 = new Product(p1);
		System.out.println(p2);

	}

}
-------------------------------------------------------------------
Scenario Based Programs :
--------------------------
Lab Program :(Method return type as a class + Passing Object ref)
----------------------------------------------------------------
A class called Customer is given to you. 

The task is to find the applicable Credit card Type and create CardType object based on the Credit Points of a customer.

Define the following for the class.

Attributes : 
	customerName : String,private
	creditPoints: int, private

Constructor :
	parameterizedConstructor: for both cusotmerName & creditPoints in that order.

Methods :
	Name of the method : getCreditPoints
	Return Type : int
	Modifier   : public 
	Task : This method must return creditPoints
	
	Name of the method : toString, Override it, 
	Return type : String 
	Task :  return only customerName from this.

Create another class called CardType. Define the following for the class

Attributes :
	customer : Customer, private
	cardType : String, private
Constructor :
	parameterizedConstructor: for customer and cardType attributes in that order

Methods :
	Name of the method : toString  Override this.  
	Return type : String
	Modifier : public
	Task :  Return the string in the following format.
		The Customer 'Rajeev' Is Eligible For 'Gold' Card.


Create One more class by name CardsOnOffer and define the following for the class.

Method : 
	Name Of the method : getOfferedCard 
	Return type : CardType
	Modifiers: public,static
	Arguments: Customer object

	Task : 	Create and return a CardType object after logically finding cardType from creditPoints as per the below rules.
		creditPoints	    cardType
		100  - 500	-   Silver
		501  - 1000	-   Gold
		1000 >		-   Platinum
		< 100		-   EMI
		
Create  an ELC class which contains Main method to test the working of the above.

4 files :
----------
package com.ravi.scenario_based_program;

public class Customer 
{
	private String customerName;
	private int creditPoints;

	public Customer(String customerName, int creditPoints) 
	{
		super();
		this.customerName = customerName;
		this.creditPoints = creditPoints;
	}

	public int getCreditPoints()
	{
		return this.creditPoints;
	}

	@Override
	public String toString() 
	{
		return this.customerName;  
	}
	
	
}

package com.ravi.scenario_based_program;

public class CardType 
{
	private Customer customer;  //1000x [HAS-A Relation]
	private String cardType;

	public CardType(Customer customer, String cardType) 
	{
		super();
		this.customer = customer;
		this.cardType = cardType;
	}

	@Override
	public String toString() 
	{
		//The Customer 'Rajeev' Is Eligible For 'Gold' Card.
		
		return "The Customer '"+this.customer+"' Is Eligible For '"+this.cardType+"' Card";
	}
	
	

}

package com.ravi.scenario_based_program;

public class CardsOnOffer 
{
  public static CardType getOfferedCard(Customer obj)  //obj -> 1000x
  {
	  int creditPoint = obj.getCreditPoints();
	  
	  if(creditPoint >=100 && creditPoint <=500)
	  {
		  return new CardType(obj, "Silver");
	  }
	  else if(creditPoint >500 && creditPoint <=1000)
	  {
		  return new CardType(obj, "Gold");
	  }
	  else if(creditPoint > 1000)
	  {
		  return new CardType(obj, "Platinum");
	  }
	  else
	  {
		  return new CardType(obj, "EMI");
	  }
	  
  }
}

package com.ravi.scenario_based_program;

import java.util.Scanner;

public class CreditCardType {

	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter Your Name :");
		String name = sc.nextLine();
		System.out.print("Enter your credit point :");
		int creditPoint = sc.nextInt();
		
		Customer c1 = new Customer(name, creditPoint);  //c1 --> 1000x
		CardType offeredCard = CardsOnOffer.getOfferedCard(c1);
		System.out.println(offeredCard);
		sc.close();
	}

}
-----------------------------------------------------------------
20-11-2024
-----------
Constructor Overloading :
-------------------------
We can write multiple constructors in the same class but argument must be different, It is called constructor overloading.

In order to call multiple constructors, we need only one object but we need to take the support of this() [this of] to call appropriate constructor.

THE FIRST LINE OF ANY CONSTRUCTOR IS MEANT FOR CALLING ANOTHER 
CONSTRUCTOR EITHER FROM SAME CLASS OR SUPER CLASS.

this() statement must be the first line of any construtor, to call the constructor present in the same class.

this() statement we can use only for constructor but not for method.

package com.ravi.overloading;

import java.text.DecimalFormat;

class Calculate
{
	public Calculate(int x, int y)
	{
		this(2.3, 7.8); //calling current class constructor [1st line]
		System.out.println("Sum of two integer is :"+(x+y));	
	}
	
	public Calculate(double a, double b)
	{
		this("Data","base");
		double sum = a + b;		
		DecimalFormat df = new DecimalFormat("00.00");
		System.out.println("Sum of two double is :"+df.format(sum));
	}
	
	public Calculate(String x, String y)
	{
		System.out.println("Concatenation of two String is :"+(x+y));
	}
}

public class ConstructorOverloading 
{
	public static void main(String[] args)
	{
		Calculate c1 = new Calculate(10, 20);
	}

}
==================================================================
Modifiers on Constructor :
---------------------------
Constructor can accept all types of access modifiers which are apllicable for accessibility level like private, default, protected and public.
       
package com.ravi.overloading;

public class PrivateConstructor 
{
	private PrivateConstructor()
	{
		System.out.println("Private Constructor");
	}

	public static void main(String[] args) 
	{
		new PrivateConstructor();

	}

}
Note : We can't apply static, final, abstract and synchronized modifier on constructor.
----------------------------------------------------------------
IQ :
----
Why we should declare a constructor with private Access modifier ?

We can declare a constructor with private access modifier due to the following two reasons :

1) If we want to declare only static variables and static methods inside a class then we should decalre constructor with private access modifier [Object is not required]

Example : java.util.Arrays and java.lang.Math class has private constructor because It contains only static methods.

2) If we want to develop singleton class, for singleton class we should create only one object by the class itself then we should declare the constructor with private access modifier.       

package com.ravi.constructor;

public class Foo 
{
  private Foo() //Private Constructor
  {
	  System.out.println("It is a private Constructor");
  }
  
  public static void main(String [] args)
  {
	  new Foo(); 	  
  }
	
}
===================================================================
Instance block OR Non static block OR Instance Initializer :
------------------------------------------------------------
It is a special block in java, which will be automatically executed at the time of creating the object.

Example :
---------
{
  //Instance block
}

The main purpose of instance block to initialize the instance variable of the class (that is the reason it is also known as instance initializer) as well as we can provide some common message for all the objects.

The fisrt line of any constructor is reserved for super() [super of] or this() [this of] that means the first line of any constructor is meant for calling either same class constructor OR super class constructor.[20-NOV]

Non static block will not be added to all the constructor, It would be added to the constructor which contains super().

If we have multiple non static blocks then it will be executed according to the order. [Top to bottom]

If a user explicitly writes non static block inside constructor body then it will be executed as it is.

We cann't write any return statement inside non static block because non static block must be executed normally.

------------------------------------------------------------------
package com.ravi.instance_block;

class Test
{
	{
		System.out.println("Instance block");
	}
}

public class InstanceBlockDemo1 
{
	public static void main(String[] args) 
	{
		new Test(); //Anonymous OR nameless object
                new Test();
                new Test();
	}

}

Note : Instance block will be automatically executed at the time of creating the object.
-------------------------------------------------------------------
package com.ravi.instance_block;

class Demo
{
	int x;
	
	{
		x = 100;
		System.out.println("Object creation is in process");
	}
}

public class InstanceBlockDemo2
{
	public static void main(String[] args) 
	{
		Demo d1 = new Demo();
		System.out.println(d1.x);
		
		Demo d2 = new Demo();
		System.out.println(d2.x);
	}

}

Note : We can initialize the instance variable inside non static block.
------------------------------------------------------------------
package com.ravi.instance_block;

class Sample
{
	int x;
	
	public Sample()
	{
		x = 200;
		System.out.println("No Argument Constructor "+x);
	}
	
	{
		x = 100;
		System.out.println("Non static block "+x);
	}
}

public class InstanceBlockDemo3 {

	public static void main(String[] args) 
	{
		new Sample();

	}

}

Note : Instance blocks are executed before the constructor body execution.
-------------------------------------------------------------------
package com.ravi.instance_block;

class Foo
{
	public Foo(int x, int y)
	{
		this(2.4, 5.7);
		System.out.println("Integer parameter constructor");
	}
	public Foo(double x, double y)
	{
		System.out.println("Double parameter constructor");
	}
	
	{
		System.out.println("Non static block");
	}
	
}

public class InstanceBlockDemo4 {

	public static void main(String[] args) 
	{
		Foo f1 = new Foo(100,200);

	}

}

Note : The constructor which contains super(), only that constructor will contain non static block.
------------------------------------------------------------
package com.ravi.instance_block;

class Stuff
{
	int x;
	
	public Stuff()
	{
		x = 400;
		System.out.println(x);
	}
	
	{
		x = 100;
		System.out.println(x);
	}
	
	{
		x = 200;
		System.out.println(x);
	}
	
	{
		x = 300;
		System.out.println(x);
	}
}


public class InstancleBlockDemo5 {

	public static void main(String[] args) 
	{
		new Stuff();
	}

}

Note : Non static blocks are executed according to the order.
[top to bottom]
-----------------------------------------------------------------
package com.ravi.instance_block;


class NIT
{
	public NIT()
	{
		System.out.println("Constructor");
		
		{
		  System.out.println("Non static block");	
		}
	}
}

public class InstanceBlockDemo6 
{

	public static void main(String[] args)
	{
		new NIT();

	}

}

Note : Non static block will be executed as it is if it is written
by user in the body of the constructor.
------------------------------------------------------------------
public class Test 
{	
	{
		return;
		//System.out.println("NSB");
	}
	
	public static void main(String[] args) 
	{
		new Test();
	}
	
}  

Note : Non static block never contain any return statement.
=============================================================
21-11-2024
----------
Instance variable initialization Order :
-----------------------------------------
All the instance variables are initialized in the following order during the life cycle :

1) It will initialized with default value at the time of Object   creation. [new Test(); Test class instance variable will be initialized with default value, init method is working internally]
   
2) Now control will verify whether, we have initailized at the time of variable declaration or not.

3) Now control will verify whether, we have initailized 
   inside non static block or not. [If present]

4) Now control will verify whether, we have initailized in the  body of the constructor or not.
   
5) Now control will verify whether, we have initailized in the method body or not but it is not recommended because Object is already created, we need to call the method explicitly, It is not the part of the object.

Default value [new keyword] => At the time of declaration => in the body of non static block => in the body of constructor => Inside method body [Not Recommended]
-------------------------------------------------------------
package com.ravi.initialization_order;

class Test
{
  private int x = 100 ;   //STEP 1
 
  {
	  x = 200; //STEP 2
  }
  
  public Test()
  {
	  super();
	  x = 300;  //STEP 3
  }
  
 /* public void accept()
  {
	  x = 400;  //STEP 4 [Not Recommended]
  } */
 
  
  public int getX()
  {
	  return this.x;
  }
}

public class InstanceVariableInitializationOrder 
{
	public static void main(String[] args) 
	{
		Test t1 = new Test();	
		
		System.out.println(t1.getX());
	}

}

Output is : 300
-------------------------------------------------------------
What is blank final field in java ?
------------------------------------
A final variable must be initialized by developer only once.

If a final instance variable is not initialized at the time of declaration then it is called Blank final field.

final int x;  //Blank final field

A blank final field can't be initialized inside the default constructor.

A blank final field, We can't initialized inside the method 
body.

A blank final field must be explicitly initialized by the developer till the object creation (till the completion of constructor body execution)

A blank final field, We can initialize in the following two places :
          1) Inside non static block
	  2) Inside constructor body
	  
A blank final field also have default value provided by new keyword.

A blank final field must be initialized in all the constructors available in class.
-------------------------------------------------------------
Programs :
===========
class LIC
{
	final double installment;  //Blank Final field
}

public class BlankFinalFieldDemo1 
{			
	public static void main(String[] args) 
	{
		LIC l = new LIC();
		System.out.println(l.installment);
	}
	
}  

A blank final field can't be initialized by default constructor.
-------------------------------------------------------------
class Test
{
	final int x;
	
	public void setData()
	{
		x = 200;
	}
}
class BlankFinalFieldDemo2 
{
	public static void main(String[] args) 
	{
		Test t1 = new Test();
	}
}

Note : can't initialized inside a method.
--------------------------------------------------------------class Foo
{
	 final int x;
	 
	/*{
		x = 123;
	}*/
	 
	 //OR
	
	public Foo()
	{
	   x = 300;	
	}
}
public class BlankFinalFieldDemo3 
{
	public static void main(String[] args) 
	{
		Foo f1 = new Foo();
		System.out.println(f1.x);
	}
}

A blank final field must be initialized inside non static block OR inside constructor body.
-------------------------------------------------------------
class Demo
{
	final int x;
	
	{
		print();
		x = 222;
	}
	public void print()
	{
		System.out.println("Default Value :"+x);
	}
	
	
}
public class BlankFinalFieldDemo4 
{
	public static void main(String[] args) 
	{
		Demo d1 = new Demo();
		System.out.println("User value :"+d1.x);
	}
}

A blank final field also have default value.
-------------------------------------------------------------
class Student
{
	final String name;
	
	public Student()
	{
		name = "Scott";
	}
	
	public Student(String name)
	{
		this.name = name;
	}	
}
public class BlankFinalFieldDemo5 
{
	public static void main(String[] args) 
	{
		Student scott = new Student();
		System.out.println(scott.name);
		
		Student smith = new Student("Smith");
		System.out.println(smith.name);
	}
}

blank final field must be initialized in all the constructor available in the class.
-------------------------------------------------------------
class Hello
{
	final int x;
	
	public Hello()
	{
		System.out.println(x);
	}
	
	public Hello(int y)
	{
		System.out.println(y);
	}
	
	{
		x = 100;
	}
	
}
public class BlankFinalFieldDemo6 
{
	public static void main(String[] args) 
	{
		Hello h1 = new Hello();
		Hello h2 = new Hello(1);
		
	}
}
=============================================================
22-11-2024
----------
Relationship between the classes :
-----------------------------------
In java, in between the classes we have two types of relation

  1) IS-A Relation
  2) HAS-A Relation
  
1) IS-A relation we can achieve by using Inheritance concept.

Example :

class Vehicle
{
}
class Car extends Vehicle  //IS-A relation
{
}

2) HAS-A Relation we can achieve by using Association concept.

   Example :
   ---------
   class Engine
   {
   }
   
   class Car
   {
      private Engine engine;  //[HAS-A Relation]
   }
   
--------------------------------------------------------------
Inheritance (IS-A Relation) :
--------------------------------
Deriving a new class (child class) from existing class (parent class) in such a way that the new class will acquire all the properties and features (except private) from the existing class is called inheritance.

It is one of the most imporatnt feature of OOPs which provides "CODE REUSABILITY".

Using inheritance mechanism the relationship between the  classes is parent and child. According to Java the parent class is called super class and the child class is called sub class.

In java we provide inheritance using 'extends' keyword.

*By using inheritance all the feature of super class is by default available to the sub class so the sub class need not to start the process from begning onwards.

Inheritance provides IS-A relation between the classes. IS-A relation is tightly coupled relation (Blood Relation) so if we modify the super class content then automatically sub class content will also modify.

Inheritance provides us hierarchical classification of classes, In this hierarchy if we move towards upward direction more generalized properties will occur, on the other hand if we move towards downwand more specialized properties will occur.

Note : By default java.lang.Object is the super class of all the classes we have in java.
--------------------------------------------------------------
Types of Inheritance in java :
------------------------------
Java supports 5 types of inheritance :

 1) Single level Inheritance
 2) Multi level Inheritance
 3) Hierarchical Inheritance
 4) Multiple Inheritance (Not supported using class)
 5) Hybrid Inheritance (Combination of two)
--------------------------------------------------------------
//Program on single level inheritance 

package com.ravi.inheritance_demo;

class Father
{
	public void house()
	{
		System.out.println("3 BHK House");
	}
}
class Son extends Father
{
	public void car()
	{
		System.out.println("Audi Car");
	}
}
public class InheritanceDemo 
{
	public static void main(String[] args)
	{
		Son son = new Son();
		son.car();
		son.house();
        }

}

Note : In inheritance we should always create the object for more specialized sub class.
--------------------------------------------------------------
//Program on single level inheritance 
--------------------------------------
package com.ravi.inheritance_demo;

class Super
{
	private int x;
	private int y;
	
	public void setData(int x, int y)
	{
		this.x = x;
		this.y = y;
	}

	public int getX() {
		return x;
	}

	public int getY() {
		return y;
	}	
}
class Sub extends Super
{
	public void getData()
	{
		System.out.println("x value is :"+getX());
		System.out.println("x value is :"+getY());
	}
}


public class InheritanceDemo 
{
	public static void main(String[] args)
	{
		Sub s1 = new Sub();
		s1.setData(100, 200);
		s1.getData();

	}

}

Note : Here with help of Encapsulation we can access private data of super class in sub class.
--------------------------------------------------------------
23-11-2024
----------

How to initialize the super class properties :
----------------------------------------------
super keyword is used to access the member or to access the memory of super class.

In order to initialize the super class properties we should use super keyword in the sub class as a first line of constructor.

super keyword always referes to its immediate super class.

Just like this keyword, super keyword (non static member) also we can't use inside static context.

super keyword we can use 3 ways in java :
------------------------------------------
1) To access super class variable (Variable Hiding)
2) To access super class method (Method Overriding)
3) To access super class constructor. (Constructor Chaining)


1) To access the super class variable (Variable Hiding) :
---------------------------------------------------------
Whenever super class variable name and sub class variable name both are same then it is called variable Hiding, Here sub class variable hides super class variable.

In order to access super class variable i.e super class memory, we should use super keyword as shown in the program.

VariableHidingDemo1.java
------------------------
package com.ravi.variable_hiding;

class Father
{
	protected double balance = 50000;
		
}
class Son extends Father
{
	protected double balance = 18000;  //Variable Hiding
	
	public void showBalance()
	{
		System.out.println("Son Balance is :"+this.balance); //18000
		System.out.println("Father Balance is : "+super.balance); //50000
		
	}
}

public class VariableHidingDemo1 
{
	public static void main(String[] args)
	{
		Son s1 = new Son();
		s1.showBalance();

	}

}
--------------------------------------------------------------

Method Hiding = It is only possible with static method.
Method Overriding = It is only possible with non-static method.

2) To call the method super class (Method Overriding)
------------------------------------------------------
If the super class non static method name and sub class non static method name both are same (Method Overriding) and if we create an object for sub class then sub class method will be 
executed (bottom to top), if we want to call super class method from sub class method body then we we should use super keyword as shown in the program.

package com.ravi.method_overriding;

class Alpha
{
	public String toString()
	{
		return "Hyderabad";
	}
}
class Beta extends Alpha
{	
	public String toString()
	{
		System.out.println(super.toString());
		return "India";
	}
}
public class MethodOverridingDemo
{
	public static void main(String[] args) 
	{
		Beta b = new Beta();
		System.out.println(b);
		

	}

}
----------------------------------------------------------------
25-11-2024
-----------
3) To call the super class Constructor (Constructor Chaining)
-------------------------------------------------------------
Whenever we write a class in java and we don't write any kind of constructor to the class then the java compiler will automatically add one default constructor to the class.

THE FIRST LINE OF ANY CONSTRUCTOR IS RESERVERD EITHER FOR super() or this() keyword that means first line of any constructor is used to call another constructor of either same class OR super class.

In the first line of any constructor if we don't specify either super() or this() then the compiler will automatically add super() to the first line of constructor.

Now the purpose of this super() [added by java compiler], to call the default constructor or No-Argument constructor of the super class.

In order to call the constructor of super class as well as same class, we have total 4 cases.
---------------------------------------------------------------
Case 1:
-------
super() : Automatically added by compiler to maintain the 
          hierarchy in the first line of the Constructor. It
	  is used to call default OR no argument constructor 
	  of super class.
	  
ConstructorChainingDemo1.java
-----------------------------
package com.ravi.constructor_chaining;

class Alpha
{
	public Alpha()
	{
		super();
		System.out.println("No Argument constructor of Alpha class");
	}
}
class Beta extends Alpha
{
	public Beta()
	{
		super();
		System.out.println("No Argument constructor of Beta class");
	}
}

public class ConstructorChainingDemo1 {

	public static void main(String[] args)
	{
		new Beta();

	}

}
----------------------------------------------------------------
The following program explains that default constructor will be added by java compiler and the first line is reserved for super()

class A
{
	public A()
	{
	  System.out.println("A");	
	}
}
class B extends A
{}

class C extends B
{
	public C()
	{
	  System.out.println("C");	
	}
}

public class Test 
{			
	public static void main(String[] args) 
	{
		new C();  //A C
	}
	
}  
---------------------------------------------------------------
Case 2 :
--------
super("NIT") : It must be written by user. It is used to call 
               parameterized constructor of super class.
	  
package com.ravi.constructor_chaining;

class Animal
{
	protected String name;
	
	public Animal(String name)
	{
		super();
		this.name = name;
	}	
}

class Dog extends Animal
{
	public Dog(String dogName)
	{
		super(dogName);
	}
	
	public String getDogName()
	{
		return this.name;
	}
	
}

class Tiger extends Animal
{
	public Tiger(String tigerName)
	{
		super(tigerName);
	}
	
	public String getTigerName()
	{
		return this.name;
	}
}

public class ConstructorChainingDemo2 
{
  public static void main(String[] args) 
  {
	   Dog tommy = new Dog("Tommy");
	   System.out.println("Dog name is :"+tommy.getDogName());
	   
	   Tiger tiger = new Tiger("Tiger");
	   System.out.println("Tiger name is :"+tiger.getTigerName());
   } 
}
--------------------------------------------------------------
Case 3 :
--------
this() : Must be explicitly written by user in the
         first line of constructor. It is used to call
          no argument constructor of current class.

package com.ravi.constructor_chaining;

class Super
{
	public Super()
	{
		super();
		System.out.println("No Argument Constructor of super class");
	}
	
	public Super(int x)
	{
		this();
		System.out.println("Parameterized Constructor of super class :"+x);
	}
}
class Sub extends Super
{
	public Sub(int val)
	{
		super(val);
		System.out.println("Parameterized Constructor of Sub class ");
	}
}

public class ConstructorChaningDemo3 {

	public static void main(String[] args) 
	{
		new Sub(12);

	}

}

---------------------------------------------------------------
Case 4 :
---------
this("java") : Must be explicitly written by user in the
           first line of constructor. It is used to call
           parameterized constructor of current class.

package com.ravi.constructor_chaining;
class Base
{	
	public Base()
	{
		this(15);
		System.out.println("No Argument Constructor of Base class");
	}
	
	public Base(int x)
	{   
		System.out.println("Parameterized Constructor of Base class :"+x);
	}
}

class Derived extends Base
{
	public Derived()
	{
		System.out.println("No Argument Constructor of Derived class");
	}
}
public class ConstructorChainingDemo4 
{

	public static void main(String[] args) 
	{
		new Derived();

	}

}
================================================================
//Program on Hierarchical Inheritance :
----------------------------------------
4 files :
----------
Shape.java
-----------
package com.ravi.inheritance_programs;

public class Shape 
{
	protected int val; 
	
	public Shape(int val) 
	{
		super();
		this.val = val;
		System.out.println("val value is :"+val);
	}
}

Circle.java
-------------
package com.ravi.inheritance_programs;

public class Circle extends Shape {
	protected final double PI = 3.14;

	public Circle(int radius) {
		super(radius);
	}

	@Override
	public String toString() 
	{
		 double area = PI * val * val;
		 return ""+area;
	}

}

Rectangle.java
---------------
package com.ravi.inheritance_programs;

public class Rectangle extends Shape 
{
    protected int breadth;
	public Rectangle(int length, int breadth) 
	{
		super(length);
		this.breadth = breadth;

	}

	@Override
	public String toString() 
	{
		double area = val * breadth;
		return ""+area;
	}

}

HierarchicalDemo.java
-----------------------
package com.ravi.inheritance_programs;

import java.util.Scanner;

public class HierarchicalDemo {

	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter the value of Radius :");
		int rad = sc.nextInt();
		Circle circle = new Circle(rad);
		System.out.println(circle);

         System.out.print("Enter the length of the Rect :");	         	
         int length = sc.nextInt();
         
         System.out.print("Enter the breadth of the Rect :");	
         int breadth = sc.nextInt();
         
         Rectangle rect = new Rectangle(length, breadth);
         System.out.println(rect);
         sc.close();
		
	}

}
----------------------------------------------------------------
//Program on Single level inheritance 

package com.ravi.inheritance_programs;

class Employee 
{
	protected int employeeId;
	protected String employeeName;
	protected double employeeSalary;

	public Employee(int employeeId, String employeeName, double employeeSalary)
	{
		super();
		this.employeeId = employeeId;
		this.employeeName = employeeName;
		this.employeeSalary = employeeSalary;
	}

}

class PermanentEmployee extends Employee
{
	protected String departmentName;
	protected String designation;
	
	public PermanentEmployee(int employeeId, String employeeName, double employeeSalary, String departmentName, String designation) 
	{
		super(employeeId, employeeName, employeeSalary);
		this.departmentName = departmentName;
		this.designation = designation;
	}

	@Override
	public String toString() {
		return "PermanentEmployee [employeeId=" + employeeId + ", employeeName=" + employeeName + ", employeeSalary="
				+ employeeSalary + ", departmentName=" + departmentName + ", designation=" + designation + "]";
	}	
		
}
public class SingleLevelDemo {

	public static void main(String[] args) 
	{
		PermanentEmployee p = new PermanentEmployee(1, "Scott", 90000, "IT", "Developer");
		System.out.println(p);

	}

}
===============================================================
26-11-2024
-----------
HOW MANY WAYS WE CAN INITIALIZE THE OBJECT PROPERTIES ?
-------------------------------------------------------
The following are the ways to initialize the object properties 
---------------------------------------------------------------
public class Test
{
   int x,y;
}


1) At the time of declaration :

   Example :
   
  public class Test
   {
      int x = 10;
      int y = 20;
   }

   Test t1 = new Test();   [x = 10  y = 20]
   Test t2 = new Test();   [x = 10  y = 20]

Here the drawback is all objects will be initialized with same value.
---------------------------------------------------------------
2) By using Object Reference :

   public class Test
   {
      int x,y;
   }
   
   Test t1 = new Test();   t1.x=10;   t1.y=20;
   Test t2 = new Test();   t2.x=30;   t2.y=40;

   Here we are getting different values with respect to object but here the program becomes more complex.
---------------------------------------------------------------
3) By using methods :

   A) First Approach (Method without Parameter)
   ----------------------------------------------
   public class Test
   {
      int x,y;

      public void setData()  
      {                         
         x = 100;  y = 200;
      }
   }

    Test t1 = new Test();  t1.setData();  [x = 100   y = 200]
    Test t2 = new Test();  t2.setData();  [x = 100   y = 200]
    
    Here also, all the objects will be iniatilized with same 
    value.

    B) Second Approach (Method with Parameter)
    -------------------------------------------
     public class Test
     {
      int x,y;   

      public void setData(int x, int y)  
      {                        
         this.x = x;
	 this.y = y;
      }
   }
   
    Test t1 = new Test();  t1.setData(12,78);  [x = 12  y = 78]
    Test t2 = new Test();  t2.setData(15,29);  [x = 15  y = 29]

    Here the Drawback is initialization and re-initialization both are done in two different lines so Constructor introduced.
----------------------------------------------------------------------
4) By using Constructor 

   A) First Approach (No Argument Constructor)
   --------------------------------------------
   public class Test
   {
      int x,y;

      public Test()  //All the objects will be initialized with
      {                                             same value
         x = 0;  y = 0;
      }     
           
   }

    Test t1 = new Test();    [x = 0   y = 0]
    Test t2 = new Test();    [x = 0   y = 0]
    

    B) Second Approach (Parameterized Constructor)
    -----------------------------------------------
     public class Test
     {
      int x,y;      

      public Test(int x, int y)  
      {                        
         this.x = x;
	 this.y = y;
      }
   }

    Test t1 = new Test(12,78);    [x = 12   y = 78]
    Test t2 = new Test(15,29);    [x = 15   y = 29]

    This is the best way to initialize our instance variable because variable initialization and variable re-initialization both will be done in the same line as well as all the objects will be initialized with different values. 

    C) Third Approach (Copy Constructor)
    --------------------------------------

       public class Manager
       {
          private int managerId;
	  private String managerName;
          
	  public Manager(Employee emp)
	  {
	    this.managerId = emp.getEmployeeId();
	    this.managerName = emp.getEmployeeName();
          }
       }

Here with the help of Object reference (Employee class) we are 
initializing the properties of Manager class. (Copy Constructor)

        d) By using instance block (Instance Initializer)
	-------------------------------------------------
	
	public class Test
	{
	   int x,y;

           public Test()
	   {
	      System.out.println(x); //100
	      System.out.println(y); //200
	   }

           //Instance block
	   {
	       x = 100; 
	       y = 200;
	   }
	}

------------------------------------------------------------------
5) By using super keyword :

   class Super
   {
     int x,y;

     public Super(int x , int y)
     {
        this.x = x;
	this.y = y;
     }
   }
   class Sub extends Super
   {
      Sub()
      {
         super(100,200); //Initializing the properties of super class
      }
   }

   new Sub();
================================================================
//Program on Hierarchical Inheritance :
----------------------------------------
package com.nit.hierarchical_inheritance;

class Employee 
{
	protected String empId;
	protected String name;
	protected double salary;

	public Employee(String empId, String name, double salary) 
	{
		super();
		this.empId = empId;
		this.name = name;
		this.salary = salary;
	}
}

class Developer extends Employee 
{
	protected String designation;

	public Developer(String empId, String name, double salary, String designation) 
	{
		super(empId, name, salary);
		this.designation = designation;
	}

	@Override
	public String toString() {
		return "Developer [empId=" + empId + ", name=" + name + ", salary=" + salary + ", designation=" + designation
				+ "]";
	}
}

class Designer extends Employee
{
	protected String designation;

	public Designer(String empId, String name, double salary, String designation) 
	{
		super(empId, name, salary);
		this.designation = designation;
	}

	@Override
	public String toString() {
		return "Designer [empId=" + empId + ", name=" + name + ", salary=" + salary + ", designation=" + designation
				+ "]";
	}
   	
}
public class HierarchicalInheritanceDemo 
{
	public static void main(String[] args) 
	{
		Developer dev = new Developer("DEV0001", "Scott", 70000 , "Programmer");
		System.out.println(dev);
		
		Designer desi = new Designer("DES001", "Martin", 25000, "UI Designer");
		System.out.println(desi);

	}

}
----------------------------------------------------------------
//Program on Multilevel inheritance :
--------------------------------------
package com.nit.multilevel;

class Student 
{
	protected int studentId;
	protected String studentName;
	protected String studentAddress;

	public Student(int studentId, String studentName, String studentAddress)
	{
		super();
		this.studentId = studentId;
		this.studentName = studentName;
		this.studentAddress = studentAddress;
	}

}

class ScienceStudent extends Student
{
	int phy, che;

	public ScienceStudent(int studentId, String studentName, String studentAddress, int phy, int che) 
	{
		super(studentId, studentName, studentAddress);
		this.phy = phy;
		this.che = che;
	}

	@Override
	public String toString() 
	{
		return "ScienceStudent [studentId=" + studentId + ", studentName=" + studentName + ", studentAddress="
				+ studentAddress + ", phy=" + phy + ", che=" + che + "]";
	}	
	
	
	
}
class PCM extends ScienceStudent
{
	protected int math;

	public PCM(int studentId, String studentName, String studentAddress, int phy, int che, int math) 
	{
		super(studentId, studentName, studentAddress, phy, che);
		this.math = math;
	}

	@Override
	public String toString() 
	{
		return super.toString()+"PCM [math=" + math + "]";
	}	
}

public class MultiLevel 
{
	public static void main(String[] args) 
	{
		PCM p = new PCM(1,"Raj", "Ameerpet", 89, 90, 91);
		System.out.println(p);

	}

}
----------------------------------------------------------------
Assignment :
------------
//Program on Hybrid Inheritance 

class Vehicle
{
}
class Car extends Vehicle
{}
   Maruti  and Ford
================================================================  **Why java does not support multiple Inheritance ?
--------------------------------------------------
Multiple Inheritance is a situation where a sub class wants to inherit the properties two or more than two super classes.

In every constructor we have super() or this(). When compiler will add super() to the first line of the constructor then we have an ambiguity issue that super() will call which super class constructor as shown in the diagram [26-NOV-24]

It is also known as Diamond Problem in java so the final conclusion is we can't achieve multiple inheritance using classes but same we can achieve by using interface [interface does not contain any constructor]
==============================================================

package com.ravi.basic_concepts;

class Foo
{	
	
	public Foo()
	{
	  System.out.println("Constructor");	
	}
	
	{
		 System.out.println("Instance Block");	
		 x = 10;
		 y = accept();
		 
	}
	
	public int accept()
	{
		System.out.println("Method");
		return 20;
	}
		
	int x = 1000;
	int y = 2000;
	
	
}
public class StaticBlockDemo 
{	
	public static void main(String [] args) 
	{		
		Foo f1 = new Foo();
		System.out.println(f1.x);
		 System.out.println(f1.y);	
	}	
}
-------------------------------------------------------------
Access modifiers in java :
---------------------------
In order to define the accessibility level of the class as well as member of the class we have 4 access modifiers :

1) private (Within the same class)
2) default (Within the same package)
3) protected (Within the same package OR even from another 
              package by using Inheritance)
4) public (No Restriction)
--------------------------------------------------------------
private :
---------
It is the most restrictive access modifier because the member declared as private can't be accessible from outside of the class.
In Java we can't declare an outer class as a private or protected. Generally we should declare the data member(variables) as private.

In java outer class can be declared as public, abstract, final, sealed and non-sealed only.


default :-
----------
It is an access modifier which is less restrictive than private. It is such kind of access modifier whose physical existance is not avaialble that means when we don't specify any kind of access modifier before the class name, variable name or method name then by default it would be default.

As far as its accessibility is concerned, default members are accessible within the same folder(package) only. It is also known as private-package modifier.


protected :
------------
It is an access modifier which is less restrictive than default because the member declared as protected can be accessible from the outside of the package (folder) too but by using inheritance concept.


Test.java [Available in com.nit.m1 package]
--------------------------------------------
package com.nit.m1;

public class Test 
{
  protected  int x = 500; 
}


ELC.java [Available in com.nit.m2 package]
--------------------------------------------
package com.nit.m2;

import com.nit.m1.Test;

public class ELC extends Test
{
	public static void main(String[] args) 
	{	
        ELC e = new ELC();
        System.out.println(e.x);
	}

}
--------------------------------------------------------------
public :
-------
It is an access modifier which does not contain any kind of restriction that is the reason the member declared as public can be accessible from everywhere without any restriction.

According to Object Oriented rule we should declare the classes and methods as public where as variables must be declared as private or protected according to the requirement.

Note : If a method is used for internal purpose only (like validation) then we can declare that method as private method.It is called 
Helper method.
--------------------------------------------------------------
28-11-2024
-----------
JVM Architecture with class loader sub system :
-----------------------------------------------
The entire JVM Architecture is divided into 3 sections :

1) Class Loader sub system
2) Runtime Data areas (Memory Areas)
3) Execution Engine

Class Loader Sub System :
-------------------------
The main purpose of Class Loader sub system to load the required .class file into JVM Memory from different memory loactions.

In order to load the .class file into JVM Memory, It uses an algorithm called "Delegation Hierarchy Algoroithm".

Internally, Class Loader sub system performs the following Task

      1) LOADING
      2) LINKING
      3) INITIALIZATION


LOADING :
---------
In order to load the required .class file, JVM makes a request to class loader sub system. The class loader sub system follows delegation hierarchy algorithm to load the required .class files from different areas.

To load the required .class file we have 3 different kinds of class loaders.


Bootstrap/Primordial class Loader :-
------------------------------------
It is responsible for loading all the predefined .class files that means all API(Application Programming Interface) level predefined classes are loaded by Bootstrap class loader.

It has the highest priority becuase Bootstrap class loader is the super class for Platform class loader.

It loads the classes from the following path 
C -> Program files -> Java -> JDK -> lib -> jrt-fs.jar 

Platform/Extension class loader :
----------------------------------
It is responsible to load the required .class file which is given by some 3rd party in the form of jar file.

It is the sub class of Bootstrap class loader and super class of Application class loader so it has more priority than Application class loader.

It loads the required .class file from the following path.
C -> Program files -> Java -> JDK -> lib -> ext -> ThirdParty.jar 

Command to create the jar file :
jar cf FileName.jar FileName.class         [*.class]

[If we want to compile more than one java file at a time then the command is :  javac *.java]

Application/System class loader :
---------------------------------------
It is responsible to load all userdefined .class file into JVM memory.

It has the lowest priority because it is the sub class Platform class loader.

It loads the .class file from class path level or environment 
variable.

Note :- 
------
If all the class loaders are failed to load the .class file into JVM memory then we will get a Runtime exception i.e java.lang.ClassNotFoundException.
-------------------------------------------------------------
How Delegation Hierarchy algorithm works :-
---------------------------------------------------
Whenever JVM makes a request to class loader sub system to load the required .class file into JVM memory, first of all, class loader sub system makes a request to Application class loader, Application class loader will delegate(by pass) the request to the Extension class loader, Extension class loader will also delegate the request to Bootstrap class loader.

Bootstrap class loader will load the .class file from lib folder(jrt-fs.jar) and then by pass the request back to extension class loader, Extension class loader will load the .class file from ext folder(*.jar) and by pass the request back to Application class loader, It will load the .class file from environment variable into JVM memory. 

Note : java.lang.Object is the first class to be loaded into JVM Memory.
--------------------------------------------------------------
What is Method Chaning in java ?
--------------------------------
It is a technique through which we call multiple methods in a single statement.

In this method chaining, always for calling next method we depend upon last method return type.

The final return type of the method depends upon last method call as shown in the program.

MethodChainingDemo1.java
-------------------------
package com.ravi.method_chaining;

public class MethodChainingDemo1 {

	public static void main(String[] args) 
	{
       String str = "india";
       char ch = str.concat(" is great").toUpperCase().charAt(0);
       System.out.println(ch);

	}

}

MethodChaningDemo2.java
-------------------------
package com.ravi.method_chaining;

public class MethodChaningDemo2 {

	public static void main(String[] args)
	{
		String str = "Hyderabad";
		int length = str.concat(" is IT City").toUpperCase().length();
		System.out.println(length);
	}

}
--------------------------------------------------------------
Role of java.lang.Class class in class loading :
----------------------------------------------------
There is a predefined class called Class available in java.lang pacakge.

In JVM memory whenever we load a class then it is loaded in special memory called Method Area and retutn type is java.lang.Class class object.

   java.lang.Class cls = AnyClass.class
   
 java.lang.Class class contains a predefined non static method  called getName() through which we can get the fully qualified name [Package Name + class Name]
 
 public String getName() : Provide fully qualified name of the class. 
 
 package com.ravi.class_loading;

class Student{}

class Sample{}

class Employee{}

class Customer{}

public class ClassLoadingInMethodArea {

	public static void main(String[] args) 
	{
		Class cls = Student.class;
		System.out.println(cls.getName()); //FQN (Package Name + Class Name)
		
		cls = Sample.class;
		System.out.println(cls.getName());
		
		cls = Employee.class;
		System.out.println(cls.getName());
		
		cls = Customer.class;
		System.out.println(cls.getName());
		
	}

}
--------------------------------------------------------------
//WAP that describes Application class loader is responsible to load our user-defined .class


java.lang.Class class has provided a predefined non static method called getClassLoader(), the return type of this method is ClassLoader class.[Factory Method]

This method will provide the class loader name which is responsible to load the .class file into JVM Memory.

public ClassLoader getClassLoader()
-------------------------------------------------------------
package com.ravi.class_loading;

class Test
{
	
}

public class ApplicationClassLoaderDemo {

	public static void main(String[] args) 
	{
		System.out.println("Test.class file is loaded by :");
		System.out.println(Test.class.getClassLoader());

	}

}

--------------------------------------------------------------
WAP to show Platform class loader is the super class for 
Application class loader.

getClassLoader() method return type is ClassLoader so further we can call any method of ClassLoader class, ClassLoader class
has provided a method called getParent() whose return type is again ClassLoader only.

    public ClassLoader getParent();
--------------------------------------------------------------

package com.ravi.class_loading;

class Demo
{
	
}

public class PlatformClassLoader {

	public static void main(String[] args)
	{
		System.out.println("Super class of Application class loader :");
		System.out.println(Demo.class.getClassLoader().getParent());
	}

}
-------------------------------------------------------------
package com.ravi.class_loading;

class Foo
{
	
}
public class BootStrapClassLoaderDemo {

	public static void main(String[] args)
	{
		System.out.println(Foo.class.getClassLoader().getParent().getParent());

	}

}

Note :- Here we will get the output  as null because it is built in class loader for JVM which is used for internal purpose (loading only predefined .class file) so implementation is not provided hence we are getting null.
-------------------------------------------------------------
Linking :
---------
verify :-
-------
It ensures the correctness of the .class files, If any suspicious activity is there in the .class file then It will stop the execution immediately by throwing a runtime error i.e java.lang.VerifyError.

There is something called ByteCodeVerifier(Component of JVM), responsible to verify the loaded .class file i.e byte code. Due to this verify module JAVA is highly secure language. 

java.lang.VerifyError is the sub class of java.lang.linkageError.

--------------------------------------------------------------
prepare : 
---------
[Static variable memory allocation + static variable initialization with default value even the variable is final]

It will allocate the memory for all the static data members, here all the static data member will get the default values so if we have static int x = 100; then for variable x  memory will be allocated (4 bytes) and now it will initialize with default value i.e 0, even the variable is final.

static Test t = new Test();

Here, t is a static reference variable so for t variable (reference variable) memory will be allocated as per JVM implementation i.e for 32 bit JVM (4 bytes of Memory) and for 64 bit (8 bytes of memory) and initialized with null.
-------------------------------------------------------------
30-11-2024
-----------

Resolve :
---------
All the symbolic references (#7) will be converted into direct references OR actual reference.

javap -verbose  FileName.class

Note :- By using above command we can read the internal details of .class file.
--------------------------------------------------------------
Initialization :
-----------------
Here class initialization will takes place. All the static data member will get their actual/original value and we can also use static block for static data member initialization.

Here, In this class initialization phase static variable and static block is having same priority so it will executed according to the order.(Top to bottom)

Can we write a Java Program without main method ?
--------------------------------------------------
class WithoutMain
{
   static
   {
       System.out.println("Hello User!!");
       System.exit(0);
   }
}

It was possible to write a java program without main method till JDK 1.6V. From JDK 1.7v onwards, at the time of loading the .class file JVM will verify the presence of main method in the .class file. If main method is not available then it will generate a runtime error that "main method not found in so so class".
--------------------------------------------------------------
Static Block OR Static Initializer :
-------------------------------------
It is a special block in java which is automatically executed at the time of loading the .class file.

Example :

static
{

}

Static blocks are executed only once because in java we can load the .class files only once.

If we have more than one static block in a class then it will be executed according to the order [Top to bottom]

The main purpose of static block to initialize the static data member of the class so it is also known as static initializer.

In java, a class is not loaded automatically, it is loaded based on the user request so static block will not be executed everytime, It depends upon whether class is loaded or not. 

static blocks are executed before the main or any static method.

A static blank final field must be initialized inside the static block only.

static final int A;   //static blank final field

static
{
   A = 100;
}

A static blank final field also have default value.

We can't write any kind of return statement inside static block.

If we don't declare static variable before static block body execution then we can perform write operation(Initialization is possible due to prepare phase) but read operation is not possible directly otherwise we will get an error Illegal forward reference, It is possible with class name bacause now compiler knows that variable is coming from class area OR Method area.

Example :

static 
{
   x = 100; //Valid
   System.out.println(x); //Invalid
   System.out.println(ClassName.x); //valid
}
static int x;

If we directly perform direct read and write operation inside a static method then it is valid.

public static void m1()
{
   y = 200; //Valid
   System.out.println(y); //Valid
}

static int y;
------------------------------------------------------------
//static block
class Foo
{		
	Foo()
	{
		System.out.println("No Argument constructor..");
	}

	{
		System.out.println("Instance block..");
	}

	static
	{
		System.out.println("Static block...");
	}
	
}
public class StaticBlockDemo 
{	
	public static void main(String [] args) 
	{		
		System.out.println("Main Method Executed ");		
	}	
}

Here Foo.class file is not loaded into JVM Memory so static block of Foo class will not be executed.
-------------------------------------------------------------
class Test
{
	static int x;

	static
	{
		x = 100;
		System.out.println("x value is :"+x);
	}
	
	static
	{
		x = 200;
		System.out.println("x value is :"+x);
	}

	static 
	{
		x = 300;
		System.out.println("x value is :"+x);
	}

	
}
public class StaticBlockDemo1   
{
	public static void main(String[] args) 
	{
		System.out.println("Main Method");
		System.out.println(Test.x);
	}
}


Note : If a class contains more than 1 static block then it will be executed from top to bottom.
--------------------------------------------------------------
class Foo
{	
	static int x;

    static
	{		
		System.out.println("x value is :"+x);
	}	
}

public class StaticBlockDemo2 
{
	public static void main(String[] args) 
	{
		 new Foo();
	}
}

Note : static variables are also having default value.
-------------------------------------------------------------
class Demo
{	
	final static int a ;	//Blank static final field

	static
	{	
            a = 100; //Initialization is compulsory here
	}	
}	
public class  StaticBlockDemo3
{
	public static void main(String[] args) 
		{		
	         System.out.println("a value is :"+Demo.a);		
	         }
}
--------------------------------------------------------------
class  A        //AD  BC  EF
{
	static 
	{
		System.out.println("A");
	}
	 
	{
		System.out.println("B");
	}

	A() 
	{		
		System.out.println("C");
	}
}
class B extends A
{
	static 
	{
		System.out.println("D");
	}
	 
	{
		System.out.println("E");
	}

	B() 
	{		
		System.out.println("F");
	}

}
public class StaticBlockDemo4 
{
	public static void main(String[] args) 
	{
		new B();  //class loading + Object Creation
	}
}
--------------------------------------------------------------
//illegal forward reference

class Demo 
{	
    static
	{   
		i = 100;		
	}

    static int i;
}

public class StaticBlockDemo5
{
    public static void main(String[] args) 
	{
        System.out.println(Demo.i);
	}
}
--------------------------------------------------------------
class Demo 
{
    static 
	{   
		i = 100;
		//System.out.println(i); //Illegal forward reference
		System.out.println(Demo.i);
    }

    static int i;
}

public class StaticBlockDemo6
{

    public static void main(String[] args) 
	{
		System.out.println(Demo.i);
	}
}
--------------------------------------------------------------
class StaticBlockDemo7 
{
	static 
	{
      System.out.println("Static Block");
	  return; 
	}

	public static void main(String[] args) 
	{
		System.out.println("Main Method");
	}
}
--------------------------------------------------------------
public class StaticBlockDemo8 
{
    final static int x; //Blank static final field

    static
	{		
		m1();		
		x = 15;		
	}

    public static void m1()
	{
		System.out.println("Default value of x is :"+x);
	}

	public static void main(String[] args) 
	{
		System.out.println("After initialization :"+StaticBlockDemo8.x);
	}
}
--------------------------------------------------------------
class Test
{	
	public static final Test t1 = new Test(); //t1 = null;
	
    static
	{
	   System.out.println("static block");
	}

	{
	   System.out.println("Non static block");
	}

	Test()
	{
		System.out.println("No Argument Constructor");
	}	
	
	
}

public class StaticBlockDemo9 
{
	public static void main(String[] args) 
	{
		new Test();  //2 steps (class loading + Object creation)
	}
}
-------------------------------------------------------------
class Sample
{	
	static 
	{
		System.out.println("Static Block");
		x = m1();	
		System.out.println(Sample.x);
	}
	
	public static int m1()
	{
	   System.out.println("Static Method");
	   return 100;	
	}
		
	static int x; 
}


public class StaticBlockDemo10 
{
	public static void main(String[] args) 
	{
		System.out.println(Sample.x);
	}
}
-------------------------------------------------------------------
Variable Memory Allocation and Initialization :
-------------------------------------------------
1) static field OR Class variable : 
-----------------------------------
Memory allocation done at prepare phase of class loading and initialized with default value even variable is final.

It will be initialized with Original value (If provided by user at the time of declaration) at class initialization phase.

When JVM will shutdown then during the shutdown phase class will be un-loaded from JVM memory so static data members are destroyed. They have long life.

2) Non static field OR Instance variable 
-----------------------------------------
Memory allocation done at the time of object creation using new keyword (Instantiation) and initialized as a part of Constructor with default values even the variable is final. [Object class-> at the time of declaration -> instance block -> constructor]

When object is eligible for GC then object is destroyed and all the non static data memebers are also destroyed with corresponding object. It has less life in comparison to static data members becuase they belongs to object.

3) Local Variable 
------------------
Memory allocation done at stack area (Stack Frame) and developer is responsible to initialize the variable before use. Once metod execution is over, It will be deleted from stack Frame henec it has shortest life.

4) Parameter variable 
----------------------
Memory allocation done at stack area (Stack Frame)  and end user is responsible to pass the value at runtime. Once metod execution is over, It will be deleted from stack Frame henec it has shortest life.

Note : We can done validation only one parameter variables.
-------------------------------------------------------------------
How many ways we can load the .class file into JVM memory :
-----------------------------------------------------------
There are so many ways to load the .class file into JVM memory but the following are the common examples :

1) By using java command

   public class Test
   {
   }

   javac Test.java
   java Test 

   Here we are making a request to class loader sub system to load Test.class file into JVM memory


2) By using Constructor (new keyword at the time of creating object).

3) By accessing static data member of the class.

4) By using inheritance 

5) By using Reflection API
-------------------------------------------------------------------
//Program that describes we can load a .class file by using new keyword (Object creation) OR by accessing static data member of the class.
class Demo
{
	static int x = 10;
	static
	{
		System.out.println("Static Block of Demo class Executed!!! :"+x);
	}
}
public class ClassLoading 
{
	public static void main(String[] args) 
	{	
		
		System.out.println("Main Method");
		//new Demo();
	    System.out.println("Hello "+Demo.x);	
	}
}

------------------------------------------------------------------
//Program that describes whenever we try to load sub class, first of all super class will be loaded. [before parent, child can't exist]

class Alpha
{
	static
	{
		System.out.println("Static Block of super class Alpha!!");
	}
}
class Beta extends Alpha 
{
	static
	{
		System.out.println("Static Block of Sub class Beta!!");
	}
}
class InheritanceLoading 
{
	public static void main(String[] args) 
	{
		 new Beta();
	}
}
------------------------------------------------------------------
Loading the .class file by using Reflection API :
-------------------------------------------------
java.lang.Class class has provided a predefined static factory method called forName(String className), It is mainly used to load the given .class file at runtime, The return type of this method is java.lang.Class

public static java.lang.Class forName(String className) throws 
ClassNotFoundException

Note : This method throws a checked execption i.e ClassNotFoundException 

package com.ravi.dynamic_loading;

class Bank
{
	static
	{
		ifscCode = "Bankhyd98675";
		System.out.println("IFSC code is :"+Bank.ifscCode);
	}
	
	static String ifscCode;
}

public class DynamicLoading 
{
	public static void main(String[] args) throws ClassNotFoundException
	{
	System.out.println("Main");
	Class.forName("com.ravi.dynamic_loading.Bank"); //FQN
	}
}

NOte : From the above program it is clear that Class.forName(String className) is used to load the given .class file dynamically at runtime.
------------------------------------------------------------------
*** What is the difference between java.lang.ClassNotFoundException 
and java.lang.NoClassDefFoundError 

java.lang.ClassNotFoundException :-
-----------------------------------------
It occurs when we try to load the required .class file at RUNTIME by using Class.forName(String className) statement or loadClass() static of ClassLoader class and if the required .class file is not available at runtime then we will get an exception i.e java.lang.ClassNotFoundException

Note :- It does not have any concern at compilation time, at run time, JVM will simply verify whether the required .class file is available or not available.
-------------------------------------------------------------------
class Foo
{
	static
	{
		System.out.println("static block of Foo class");
	}
}
public class ClassNotFoundExceptionDemo 
{
	public static void main(String[] args) throws ClassNotFoundException
	{
		Class.forName("Ravi");
	}
}


Note : At runtime, JVM will verify whether Ravi.class file is available Or not available, if not available then we will get 
java.lang.ClassNotFoundException.
-------------------------------------------------------------------
java.lang.NoClassDefFoundError :
--------------------------------
It occurs when the class was present at the time of COMPILATION but at runtime the required .class file is not available(manualy deleted by user ) Or it is not available in the current directory (Misplaced) then we will get a runtime error i.e java.lang.NoClassDefFoundError.

class Welcome
{
	public void greet()
	{
		System.out.println("Hello Batch 40");
	}
}
public class NoClassDeFFoundErrorDemo 
{
	public static void main(String[] args) 
	{
		Welcome w = new Welcome();
		w.greet();
	}
}

Note : After compilation delete Welcome.class OR move this Welcome .class file from current folder to any other folder.
--------------------------------------------------------------
03-12-2024
-----------
** A static method does not act on instance variable directly why?

 All the static members (static variable, static block, static method, static nested inner class) are loaded/executed at the time of loading the .class file into JVM Memory.

At class loading phase object is not created because object is created in the 2nd phase i.e Runtime data area so at the TIME OF EXECUTION OF STATIC METHOD AT CLASS LOADING PAHSE, NON STATIC VARIABLE WILL NOT BE AVAILABLE BY DEFAULT henec we can't access non static variable from static context[static block, static method and static nested inner class] without creating the object.
------------------------------------------------------------
public class StaticDemo 
{
	int x = 100;  //2nd Layer Data
	
	public static void main(String[] args) //1st Layer Member
	{
		System.out.println("x value is :"+x);//error
	}
}
--------------------------------------------------------------
class Test
{
	private int x;
	
	public Test(int x)
	{
		this.x = x;
	}
	
	public static void access()
	{
	  System.out.println("x value is :"+x);	//error
	}	
}
public class StaticDemo1 
{
	public static void main(String[] args) 
	{
		Test t1 = new Test(10);
		Test.access();
	}
}
-------------------------------------------------------------
How to access super class and sub class variable using Variable hiding concept through static method

package com.ravi.execution;

class Alpha
{
	protected int x = 100;
}
class Beta extends Alpha
{
	protected int x = 200;   //Variable Hiding
	
	public static void access()
	{
		Beta b1 = new Beta();
		System.out.println("Sub class x variable :"+b1.x);
		
		Alpha a1 = b1;
		System.out.println("Super class x variable is :"+a1.x);
		
	}	
}
public class IQ 
{
	public static void main(String[] args) 
	{
		Beta.access();
	}

}
-------------------------------------------------------------
Runtime Data Areas :
---------------------
It is also known as Memory Area.

Once a class is loaded then based on variable type method type it is divided into different memory areas which are as follows :

1) Method Area 
2) HEAP Area
3) Stack Area
4) PC Register
5) Native Method Stack

Method Area :
-------------
Whenever a class is loaded then the class is dumpped inside method area and returns java.lang.Class class object.

It provides all the information regarding the class, like name of the class, name of the package, static and non static fields available in the class, methods available in the class and so on.

We have only one method area per JVM that means for a single JVM we have only one Method area.

This Method Area OR Class Area is sharable by all the objects.
--------------------------------------------------------------
Program to Show From Method Area we can get complete information of the class. (Reflection API)

package com.ravi.class_description;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class ClassDescription {

	public static void main(String[] args) throws ClassNotFoundException
	{
	  Class cls =	Class.forName(args[0]); //FQN
	  
	  System.out.println("class name is :"+cls.getName());
	  
	  System.out.println("Package Name is :"+cls.getPackageName());
	  
	  System.out.println("Available methods are :");
	   
	  Method[] methods = cls.getDeclaredMethods();
	  int count = 0;
	  
	  for(Method method : methods)
	  {
		  System.out.println(method.getName());
		  count++;
	  }
      System.out.println("Total number of methods are :"+count);
	  
	  System.out.println("Available Fields are :");
	  
	  Field[] fields = cls.getDeclaredFields();
	  count = 0;
	  
	  for(Field field : fields)
	  {
		  count++;
		  System.out.println(field.getName());
	  }
	  
	  System.out.println("Total number of Fields are :"+count);
	  
	               
	}

}

Note :- getDeclaredMethods() is a predefined non static method available in java.lang.Class class , the return type of this method is Method array where Method is a predefined class available in java.lang.reflect sub package.

public Method[]  getDeclaredMethods()

getDeclaredFields() is a predefined non static method available in java.lang.Class class , the return type of this method is Field array where Field is a predefined class available in java.lang.reflect sub package.

public Field[]  getDeclaredFields()

Field and Method both the classes are providing getName() method to get the name of the field and Method.
--------------------------------------------------------------
HEAP AREA :
-----------
Whenever we create an object in java then the properties and behavior of the object are strored in a special memory area called HEAP AREA.

We have only one HEAP AREA per JVM.
--------------------------------------------------------------
STACK Area :
------------
All the methods are executed as a part of Stack Area.

Whenever we call a method in java then internally one stack Frame will be created to hold method related information.

Every Stack frame contains 3 parts :
1) Local Variable arrays
2) Frame Data
3) Operand Stack.

We have multiple stack area for a single JVM.

Everytime we create a new thread in java then JVM will create a separate Runtime Stack.[Multithreading]
-------------------------------------------------------------
HEAP and STACK Diagram for Static data member and array variables [Beta.java]
--------------------
class Alpha
{
	int val;

	static int sval = 200;
	static Beta b = new Beta();

	public Alpha(int val)
	{
      this.val = val;
	}
}

public class Beta    
{
	public static void main(String[] args) 
	{
		Alpha am1 = new Alpha(9);
		Alpha am2 = new Alpha(2);

		Alpha []ar = fill(am1, am2); 

		ar[0] = am1; 
        System.out.println(ar[0].val); 
        System.out.println(ar[1].val);
	}

	public static Alpha[] fill(Alpha a1, Alpha a2)
	{
		a1.val = 15;   

        Alpha fa[] = new Alpha[]{a2, a1}; 
			
		return fa;
	}
}
--------------------------------------------------------------
PC Register :
-------------
It stands for Program counter Register.

In order to hold the current executing instruction of running thread we have separate PC register for each and every thread.
----------------------------------------------------------------
Native Method Stack :
----------------------
Native method means, the java methods which are written by using native languages like C and C++. In order to write native method we need native method library support.

Native method stack will hold the native method information in a separate stack.
---------------------------------------------------------------------
Execution Engine : [Interpreter + JIT Compiler]

Interpreter 
------------
In java, JVM contains an interpreter which executes the program line by line. Interpreter is slow in nature because at the time of execution if we make a mistake at line number 9 then it will throw the execption at line number 9 and after solving the execption again it will start the execution from line number 1 so it is slow in execution that is the reason to boost up the execution java software people has provided JIT compiler.

JIT Compiler :
--------------
It stands for just in time compiler. The main purpose of JIT compiler to boost up the execution so the execution of the program will be completed as soon as possible.

JIT compiler holds the repeated instruction like method signature, variables, native method code and make it available to JVM at the time of execution so the overall execution becomes very fast.
--------------------------------------------------------------
HAS-A Relation :
----------------
class Order
{
  private int orderId;
  private String itemName;
  private double itemPrice;
}

class Customer
{
  private int customerId;
  private String customerName;
  private String customerAddree;
  private Order order; //HAS-A relation
}

If we use a class as a property to another class then it is called HAS-A Relation.

The limitation of IS-A relation is, it is tightly coupled relation i.e IS-A type relation so if we modify the content of super class then it will automatically, It will reflect to all the sub classes.

While working with HAS-A relation we can access the property of another class so HAS-A relation provides accessibility 
feature.

HAS-A relation we can achieve by using Association concept.

Association is divided into two types :

   1) Composition (Strong Reference)
   2) Aggregation (Weak Reference)

Association :
---------------
Association is a connection between two separate classes that can be built up through their Objects. 

The association builds a relationship between the classes and describes how much a class knows about another class. 

This relationship can be unidirectional or bi-directional. In Java, the association can have one-to-one, one-to-many, many-to-one and many-to-many relationships.

Example:-
One to One: A person can have only one PAN card
One to many: A Bank can have many Employees
Many to one:  Many employees can work in single department 
Many to Many: A Bank can have multiple customers and a customer can have multiple bank accounts.

3 files :
---------
Student.java
-------------
package com.ravi.has_a_reln;

public class Student 
{
	private int studentId;
	private String studentName;
	private int studentMarks;

	public Student(int studentId, String studentName, int studentMarks) {
		super();
		this.studentId = studentId;
		this.studentName = studentName;
		this.studentMarks = studentMarks;
	}

	@Override
	public String toString() {
		return "Student [studentId=" + studentId + ", studentName=" + studentName + ", studentMarks=" + studentMarks
				+ "]";
	}

	public int getStudentId() {
		return studentId;
	}

	public void setStudentId(int studentId) {
		this.studentId = studentId;
	}

	public String getStudentName() {
		return studentName;
	}

	public void setStudentName(String studentName) {
		this.studentName = studentName;
	}

	public int getStudentMarks() {
		return studentMarks;
	}

	public void setStudentMarks(int studentMarks) 
	{
		this.studentMarks = studentMarks;
	}
}
--------------------------------------------------------------
Trainer.java
-------------
package com.ravi.has_a_reln;

import java.util.Scanner;

public class Trainer 
{
   public static void viewStudentProfile(Student obj)
   {
	   Scanner sc = new Scanner(System.in);
	   System.out.print("Enter Student Id :");
	   int id = sc.nextInt();
	   
	   if(id == obj.getStudentId())
	   {
		 System.out.println(obj);   
	   }
	   else
	   {
		   System.err.println("Id is invalid !!!");
	   }
	  
   }
}

AssociationDemo.java
---------------------
package com.ravi.has_a_reln;

public class AssociationDemo {

	public static void main(String[] args) 
	{
		Student raj = new Student(111, "Raj", 455);
		Student priya = new Student(222, "Priya", 460);
		
		Trainer.viewStudentProfile(raj);
		Trainer.viewStudentProfile(priya);

	}
}
-------------------------------------------------------------
Composition (Strong reference) :
--------------------------------
Composition in Java is a way to design classes such that one class contains an object of another class. It is a way of establishing a "HAS-A" relationship between classes.

Composition represents a strong relationship between the containing class and the contained class.If the containing object (Car object) is destroyed, all the contained objects (Engine object) are also destroyed.

A car has an engine. Composition makes strong relationship between the objects. It means that if we destroy the owner object, its members  will be also destroyed with it. For example, if the Car is destroyed the engine will also be destroyed as well.

Program Guidelines :
--------------------
1) One object can't exist without another object
2) We will not create two separate objects, during the creation of Car object, Engine object should be automatically created.
3) We can declare blank final field.

3 files :
----------
Engine.java
------------
package com.ravi.composition;

public class Engine 
{
	private String engineType;
	private int horsePower;

	public Engine(String engineType, int horsePower) 
	{
		super();
		this.engineType = engineType;
		this.horsePower = horsePower;
	}

	@Override
	public String toString() {
		return "Engine [engineType=" + engineType + ", horsePower=" + horsePower + "]";
	}
}

Car.java
--------
package com.ravi.composition;

public class Car
{
	private String carName;
	private int carModel;
	private final Engine engine; // HAS-A Relation [Blank final field]
	
	public Car(String carName, int carModel)
	{
		super();
		this.carName = carName;
		this.carModel = carModel;
		this.engine = new Engine("Battery", 1200); //Composition		
	}


	@Override
	public String toString() 
	{
		return "Car [carName=" + carName + ", carModel=" + carModel + ", engine=" + engine + "]";
	}
	
	

}

CompositionDemo.java
---------------------
package com.ravi.composition;

public class CompositionDemo {

	public static void main(String[] args) 
	{
		Car car = new Car("Ford", 2024);
		System.out.println(car);
		

	}

}
--------------------------------------------------------------
05-12-2024

Aggregation (Weak Referance) :
------------------------------
Aggregation in Java is another form of association between classes that represents a "HAS-A" relationship, but with a weaker bond compared to composition. 

In aggregation, one class contains an object of another class, but the contained object can exist independently of the container. If the container object is destroyed, the contained object can still exist.


3 files :
----------
College.java
-------------
package com.ravi.aggregation;

public class College 
{
	private String collegeName;
	private String collegeLocation;

	public College(String collegeName, String collegeLocation) 
	{
		super();
		this.collegeName = collegeName;
		this.collegeLocation = collegeLocation;
	}

	@Override
	public String toString() {
		return "College [collegeName=" + collegeName + ", collegeLocation=" + collegeLocation + "]";
	}

	
	
}

Student.java
------------
package com.ravi.aggregation;

public class Student 
{
	private int studentId;
	private String studentName;
	private int studentMarks;
	private College college; // HAS-A Relation

	public Student(int studentId, String studentName, int studentMarks, College college)
	{
		super();
		this.studentId = studentId;
		this.studentName = studentName;
		this.studentMarks = studentMarks;
		this.college = college;
	}

	@Override
	public String toString() {
		return "Student [studentId=" + studentId + ", studentName=" + studentName + ", studentMarks=" + studentMarks
				+ ", college=" + college + "]";
	}

	
	
	
}


AggregationDemo.java
---------------------
package com.ravi.aggregation;

public class AggregationDemo {

	public static void main(String[] args) 
	{
		College clg = new College("VIT", "Vellore");
		
		Student s1 = new Student(1, "Scott", 450, clg);
		System.out.println(s1);

		Student s2 = new Student(2, "Smith", 452, clg);
		System.out.println(s2);
	}

}

Note :- IS-A relation is tightly coupled relation so if we modify the content of super class, sub class content will also modify but in HAS-A realtion we are accessing the properties of another class so we are not allowed to modify the content, we can access the content or Properties.
-------------------------------------------------------------
Assignemnts :
-------------
Order and Customer
Person and Address
Account and Customer
----------------------------------------------------------------
Description of System.out.println() :
-------------------------------------
public class System
{
   public final static java.io.PrintStream out = null;  //HAS-A Relation
}


System.out.println();

Internally System.out.println() creates HAS-A relation because System class contains a predefined class called java.io.PrintStream as shown in the above example.

The following program describes that how System.out.println() works internally :

Description.java
-----------------
package com.ravi.aggregation;

class Test  
{
	public static final String str = "Hyderabad";  
}

public class Description {

	public static void main(String[] args) 
	{
		System.out.println(Test.str.length());
	}
}
----------------------------------------------------------------
***Polymorphism :
-----------------
Poly means "many" and morphism means "forms".

It is a Greek word whose meaning is "same object having different behavior".

In our real life a person or a human being can perform so many task, in the same way in our programming languages a method or a constructor can perform so many task.

Eg:-

void add(int a, int b)

void add(int a, int b, int c)

void add(float a, float b)

void add(int a, float b)

----------------------------------------------------------------
Types of Polymorphism :
-----------------------
Polymorphism can be divided into two types :

1) Static polymorphism OR Compile time polymorphism OR Early binding

2) Dynamic Polymorphism OR Runtime polymorphism OR Late binding

1) Static Polymorphism :
------------------------
The polymorphism which exist at the time of compilation is called Static OR compile time polymorphism.

In static polymorphism, compiler has very good idea that which method is invoked depending upon METHOD PARAMETER.

Here the binding of the method is done at compilation time so, it is known as early binding.

We can achieve static polymorphism by using Method Overloading concept.

Example of static polymorphism : Method Overloading.


2) Dynamic Polymorphism 
-----------------------
The polymorphism which exist at runtime is called Dynamic polymorphim Or Runtime Polymorphism.

*Here compiler does not have any idea about method calling, at runtime JVM will decide which method will be invoked depending upon CLASS TYPE OBJECT.

Here method binding is done at runtime so, it is also called Late Binding.

We can achieve dynamic polymorphism by using Method Overriding.

Example of Dynamic Polymorphism : Method Overriding

----------------------------------------------------------------
Method Overloading :
-------------------
Method Overloading :
--------------------
Writing two or more methods in the same class or even in the super and sub class in such a way that the method name must be same but the argument must be different.

While Overloading a method we can change the return type of the method.

If parameters are same but only method return type is different then it is not an overloaded method.

Method overloading is possible in the same class as well as super and sub class.

While overloading the method the argument must be different otherwise there will be ambiguity problem.

Method Overloading allows us to write two methods with same name but differ in:
1. Number of parameters
2. Data type of parameters
3. Sequence/Order of data type of parameters(int -long and long int)

IQ :
----
Can we overload the main method/static method ?

Yes, we can overload the main method OR static method but the execution of the program will start from main method which accept String [] array as a parameter.

Note :- The advantage of method overloading is same method name we can reuse for different functionality for refinement of the method.

Note :- In System.out.println() or System.out.print(), print()
        and println() methods are best example for Method Overloading.
	
Example :
----------
public void makePayment(Cash c)
{
}
public void makePayment(UPI c)
{
}
public void makePayment(CreditCard c)
{
}
------------------------------------------------------------------
WAP to show Constructor Overloading :
--------------------------------------
package com.ravi.overload;

class Addition
{
	public Addition(int x, int y)
	{
		this(2.3F, 7.8f);
		System.out.println("Sum of two integer is :"+(x+y));
	}
	
	public Addition(float x, float y)
	{
		this("Data","base");
		System.out.println("Sum of two float is :"+(x+y));
	}
	
	public Addition(String x, String y)
	{
		super();
		System.out.println("Concatenation of two String is :"+(x+y));
	}
}

public class OverloadDemo1 
{
	public static void main(String[] args) 
	{
		 new Addition(100,200);
		

	}

}
------------------------------------------------------------------
WAP to show method overloading by changing the return type :
-------------------------------------------------------------
package com.ravi.overload;

class Sum
{
	public int add(int x, int y)
	{
		return (x+y);
	}
	public double add(double x, double y)
	{
		return (x+y);
	}
	
	public String add(String x, String y)
	{
		return (x+y);
	}
}

public class MethodOverloading 
{
	public static void main(String[] args) 
	{
		Sum s1 = new Sum();
	    System.out.println(s1.add("Data", "base"));
	    System.out.println(s1.add(12.90, 45.89));
	    System.out.println(s1.add(10, 20));
	    

	}

}
----------------------------------------------------------------
Var-Args in Java :
--------------------
It was introduced from JDK 1.5 onwards.

It stands for variable argument. It is an array variable which can hold 0 to n number of parameters of same type or different type by using Object class.

It is represented by exactly 3 dots (...) so it can accept any number of argument (0 to nth) that means now we need not to define method body again and again, if there is change in method parameter value.

var-args must be only one and last argument.

We can use var-args as a method/Constructor parameter only.
-------------------------------------------------------------------
WAP to show that var-args can accept 0 to n number of parameters 

package com.ravi.overload;
class Test
{
	public void input(int ...x)
	{
	 System.out.println("Var Args executed");	
	}
}

public class VarArgsDemo1 
{
	public static void main(String... args) 
	{	  
		
          Test t1 = new Test();
          t1.input();
          t1.input(10);
          t1.input(10,20);
          t1.input(10,20,30);
          t1.input(100,200,300,400); 
	}

}
------------------------------------------------------------------
WAP to show how to add parameter values using var args :

package com.ravi.overload;

class SumOfParameter
{
	public void acceptParameter(int ...values)
	{
		int sum = 0;
		for(int value : values)
		{
			sum = sum + value;
		}
		System.out.println("Sum of parameter is :"+sum);
	}
}

public class VarArgsDemo2
{
	public static void main(String[] args)
	{
		SumOfParameter s1 = new SumOfParameter();
		s1.acceptParameter(10,20,30,40);
		s1.acceptParameter(100,200,300,400);

	}

}
------------------------------------------------------------------
WAP to show var args must be only one and last argument

package com.ravi.overload;


class Sample 
{
	// All commented codes are invalid
	
	/*
	 * public void accept(float ...x, int ...y) { }
	 * 
	 * public void accept(int ...x, int y) { }
	 * 
	 * public void accept(int...x, int ...y) {}
	 */
	  
	 
	public void accept(int x, int... y)  
	{
		System.out.println("x value is :" + x);
		
		for (int z : y) 
		{
			System.out.println(z);
		}
	}
}

public class VarArgsDemo3 
{
   public static void main(String[] args) 
   {
	  Sample s1 = new  Sample();
	  s1.accept(12, 10,20,30,40);
   }
}
------------------------------------------------------------------
Program that show var args can accept hetrogeneous types of data.
-----------------------------------------------------------------
package com.ravi.overload;

class Accept
{
	 public void acceptHetrogeneous(Object ...obj)
	 {
		 for(Object o : obj)
		 {
			 System.out.println(o);
		 }
	 }
}

public class VarArgsDemo4 {

	public static void main(String[] args) 
	{
		Accept a1 = new Accept();
		a1.acceptHetrogeneous(12,23.90,'A',"NIT", new String("Hyd"));
	}

}
----------------------------------------------------------------
09-12-2024
----------
Wrapper classes in java :
-------------------------
We have 8 primitive data types in java i.e byte, short, int, long and so on.

Except these 8 primitive data types, everything in java is an object.

If we remove these 8 primitive data types then only java can become pure object oriented language.

On these primitive data types, we can't assign null or we can't invoke a method.

These primitive data types are unable to move in the network, only objects are moving in the network.

We can't perform serialization and object cloning on primitive data types.It is only possible with objects.

To avoid the above said problems, From JDK 1.5v, java software people has provided the following two concepts :

a) Autoboxing
b) Unboxing

Autoboxing 
--------------
When we convert the primitive data types into corresponding wrapper object then it is called Autoboxing as shown below.

Primitive type		Wrapper Object
----------------             ------------------
byte			-	Byte
short			-	Short
int			-	Integer
long			-	Long
float			-	Float
double			-	Double
char			-	Chracter
boolean			-	Boolean 

Note : ALL THE WRAPPER CLASSES ARE IMMUTABLE(UN-CHANGED) AS WELL AS equals(Object obj) and hashCode() methods are overridden in all the Wrapper classes.

WAP to show that Wrapper classes are immutable :
-------------------------------------------------

package com.ravi.immutable_demo;

class Product
{
	protected double price;
	
	public Product(double price) 
	{
		super();
		this.price = price;
	}

	public double getPrice() {
		return price;
	}

	public void setPrice(double price) {
		this.price = price;
	}

	@Override
	public String toString() 
	{
		return "Product [price=" + price + "]";
	}	
}

public class ImmutableDemo1
{
	public static void main(String[] args) 
	{
		Product laptop = new Product(67000);
		System.out.println("Before Change :"+laptop.getPrice());
		accept(laptop);
		System.out.println("After Change :"+laptop.getPrice());
	}
		
	public static void accept(Product prod)
	{
		prod.setPrice(90000);
	}

}
-------------------------------------------------------------

package com.ravi.immutable_demo;

public class ImmutableDemo2 
{
	public static void main(String[] args) 
	{
	Integer i = new Integer(90);
        accept(i);
        System.out.println(i);  //90
	}
	
	public static void accept(Integer y)
	{
		y = 120;
	}

}
---------------------------------------------------------------
package com.ravi.immutable_demo;

public class ImmutableDemo3 
{
   public static void main(String[] args) 
   {
	   String str = "Data";
	   accept(str);
	   System.out.println(str);  //Data	     
   }
   
   public static void accept(String s1)
   {
	   s1 = "Data base";
   }
}
----------------------------------------------------------------
--
Overloaded valueOf() method :
-----------------------------
We have 3 overloaded valueOf() method :
----------------------------------------
1) public static Integer valueOf(int x) : It will convert the given int value into Integer Object.

2) public static Integer valueOf(String str) : It will convert
   the given String into Integer Object.
   [valueOf() method will convert the String into Wrapper object where as parseInt() method will convet the String into primitive type]

3) public static Integer valueOf(String str, int radix/base) :
   It will convert the given String number into Integer object 
   by using the specified radix or base.

 Note :- We can pass base OR radix upto 36
i.e A to Z (26) + 0 to 9 (10) -> [26 + 10 = 36], It can be 
calculated by using Character.MAX_RADIX.

Output will be generated on the basis of radix

System.out.println(Character.MAX_RADIX); //36
MAX_RADIX is a final and static variable of Character class.
----------------------------------------------------------------
//Integer.valueOf(int);
public class AutoBoxing1
{
	public static void main(String[] args) 
	{
		int a = 12;
		Integer x = Integer.valueOf(a); //Upto 1.4 version
		System.out.println(x);

		
                int y = 15;
		Integer i = y;   //From 1.5 onwards compiler takes care
		System.out.println(i);		
	}
}
---------------------------------------------------------------
public class AutoBoxing2
{  
	public static void main(String args[])
	{  
		byte b = 12;
	    Byte b1 = Byte.valueOf(b);
	   System.out.println("Byte Object :"+b1);
	   
	   short s = 17;
	   Short s1 = Short.valueOf(s);
	   System.out.println("Short Object :"+s1);
	   
	   int i = 90;
	   Integer i1 = Integer.valueOf(i);
	   System.out.println("Integer Object :"+i1);
	   
	  	long g = 12;
		Long h =  Long.valueOf(g);
		System.out.println("Long Object :"+h);
		
		float f1 = 2.4f;
		Float f2 = Float.valueOf(f1);
		System.out.println("Float Object :"+f2);
		
		double k = 90.90;
		Double l = Double.valueOf(k);
		System.out.println("Double Object :"+l);
		
		char ch = 'A';
		Character ch1 = Character.valueOf(ch);
		System.out.println("Character Object :"+ch1);
		
		boolean x = true;
		Boolean x1 = Boolean.valueOf(x);
		System.out.println("Boolean Object :"+x1);
	   
	   
			}   
}  
---------------------------------------------------------------
//Integer.valueOf(String str)
//Integer.valueOf(String str, int radix/base)
public class AutoBoxing3 
{
	public static void main(String[] args) 
	{
			Integer a = Integer.valueOf(15);
			
			Integer b = Integer.valueOf("25");

            Integer c = Integer.valueOf("111",36); //Here Base we can take upto 36

			System.out.println(a);
			System.out.println(b);
			System.out.println(c);
			
           
	}
}
----------------------------------------------------------------
public class AutoBoxing4 
{
	public static void main(String[] args) 
	{
		Integer i1 = new Integer(100);
		Integer i2 = new Integer(100);
		System.out.println(i1==i2);  //false

		Integer a1 = Integer.valueOf(15);
		Integer a2 = Integer.valueOf(15);
		System.out.println(a1==a2); //true
	}
}

Note : It will generate Compilation warning because new Integer(int val) is marked for removal.

       a1 and a2 reference variable, both are pointing to the same object (immutable) so == operator will provide 
       true.
----------------------------------------------------------------
How to convert int value into String :
--------------------------------------
Integer class has provided a predefined static method 
toString() through which we can convert the int value into String Object 

   public static String toString()
   
   //Converting integer value to String
public class AutoBoxing5 
{
	public static void main(String[] args) 
	{
		int x = 12;
		String str = Integer.toString(x);
		System.out.println(str+2);
	}
}

----------------------------------------------------------------
Unboxing :
----------------
Converting wrapper object to corresponding primitive type is called Unboxing.

Wrapper            Primitive
Object               type               
----------            ----------
Byte		-	byte

Short		-	short

Integer		-	int

Long		-	long

Float		-	float

Double		-	double

Chracter	-	char

Boolean		-	boolean
----------------------------------------------------------------
We have total 8 Wrapper classes.

Among all these 8, 6 Wrapper classes (Byte, Short, Integer, Long, Float and Double) are the sub class of java.lang.Number class which represent numbers (either decimal OR non decimal)
so all the following six wrapper classes (Which are sub class of Number class) are providing the following common methods.

1) public byte byteValue()

2) public short shortValue()

3) public int intValue()

4) public long longValue()

5) public float floatValue()

6) public double doubleValue()

----------------------------------------------------------------
//Converting Wrapper object into primitive
public class AutoUnboxing1
{  
   public static void main(String args[])
	   {  
            Integer obj = 15;   //Upto 1.4
			int x = obj.intValue();
			System.out.println(x);
		}   
}  
--------------------------------------------------------------
public class AutoUnboxing2
{
	public static void main(String[] args) 
	{	
			Integer x = 25; 
			int y = x;        //JDK 1.5 onwards  
			System.out.println(y);  
	}
}
---------------------------------------------------------------
public class AutoUnboxing3
{
	public static void main(String[] args) 
	{	
			Integer i = 15;
			System.out.println(i.byteValue());  
			System.out.println(i.shortValue());
			System.out.println(i.intValue());
			System.out.println(i.longValue());
			System.out.println(i.floatValue());
			System.out.println(i.doubleValue());			
	}
}
---------------------------------------------------------------
public class AutoUnboxing4
{
	public static void main(String[] args) 
	{
		Character c1 = 'A';
		char ch = c1.charValue();
		System.out.println(ch);
	}
}
---------------------------------------------------------------
public class AutoUnboxing5
{
	public static void main(String[] args) 
	{
		Boolean b1 = true;
		boolean b = b1.booleanValue();
		System.out.println(b);
	}
}
---------------------------------------------------------------
class BufferTest 
{
	public static void main(String[] args) 
	{		
		Integer i = 127;
		Integer j = 127;
		System.out.println(i==j);  //true
		System.out.println(i.equals(j)); //true
		
		Integer a = 128;
		Integer b = 128;
		System.out.println(a==b);  //false
		System.out.println(a.equals(b)); ///true
		
		Integer p = 130;
		Integer q = 130;
		System.out.println(p.equals(q)); //true	
		
	}
}

Note : Integer i = 127; This statement will accept the range of
       byte(-128 to 127) after this range it will craete another object in another memory location.

       While comparing the Wrapper object, It will always better
       to compare to Wrapper object by using equals(Object obj).
       Each Wrapper class has overidden equals(Object obj) and hashCode() method.
 ---------------------------------------------------------------
 Unlike primitive types we can't convert one wrapper type object to another wrapper object.

Example :

Long l = 12;  //Invalid

Float f = 90; //Invalid

Double d = 123; //Invalid

package com.ravi.basic;

public class Conversion 
{
	public static void main(String[] args) 
	{
	  long l = 12; //Implicit OR Widening	  
	  byte b = (byte) 12L; //Explicit OR Narrowing
	  
	  Long a = 12L;
	  Double d = 90D;
	  Double d1 = 90.78;
	  Float f = 12F;
	}

}
---------------------------------------------------------------
Ambiguity issue while overloading a method :
---------------------------------------------
When we overload a method then compiler is selecting appropriate method among the available methods based on the following types.

1. Different number of parameters 
2. Different data type of parameters 
3. Different sequence(order) of data type of parameters

In case of ambiguity where compiler can select more than one method then compiler will provide the priority by using following rules :

1) Most Specific Type :
-----------------------
Compiler alwyas provide more priority to most specific data type or class type.

double > float [Here float is the most specific type]  
float > long 
long > int
int > char     
int > short  //[No relation between short and char]
short > byte     

2) WAV [Widening ->  Autoboxing  -> Var Args]

   Compiler gives the priority to select appropriate method by using the following sequence :
   Widening ---> Autoboxing  ----> Var args

3) Nearest Data type or Nearest class (sub class) 
   
   While selecting the appropriate method in ambiguity issue compiler provides priority to nearest data type or nearest class i.e sub class

----------------------------------------------------------------
class Test
{
	public void accept(double d) 
	{
		System.out.println("double");
	}
	public void accept(float d)
	{
		System.out.println("float");
	}	
}
public class AmbiguityIssue {

	public static void main(String[] args) 
	{
		Test t = new Test();
		t.accept(6);

	}
}

Note : Here float will be executed becuase float is the most specific type.
---------------------------------------------------------------
class Test
{
	public void accept(int d)
	{
		System.out.println("int");
	}
	public void accept(char d)
	{
		System.out.println("char");
	}	
}
public class AmbiguityIssue {

	public static void main(String[] args) 
	{
		Test t = new Test();
		t.accept(6);
	}
}
Here 6 is int type so int will be executed.
---------------------------------------------------------------
class Test
{
	public void accept(int ...d)
	{
		System.out.println("int");
	}
	public void accept(char ...d)
	{
		System.out.println("char");
	}	
}
public class AmbiguityIssue {

	public static void main(String[] args) 
	{
		Test t = new Test();
		t.accept();
	}
}
char will be executed becoz char is more specific type.
---------------------------------------------------------------
class Test
{
	public void accept(short ...d)
	{
		System.out.println("short");
	}
	public void accept(char ...d)
	{
		System.out.println("char");
	}	
}
public class AmbiguityIssue {

	public static void main(String[] args) 
	{
		Test t = new Test();
		t.accept();
	}
}
Here we will get compilation error because there is no relation between char and short based on the specific type rule.
--------------------------------------------------------------
 class Test
{
	public void accept(short ...d)
	{
		System.out.println("short");
	}
	public void accept(byte ...d)
	{
		System.out.println("byte");
	}	
}
public class AmbiguityIssue {

	public static void main(String[] args) 
	{
		Test t = new Test();
		t.accept();
	}
}
Here byte will be executed because byte is the specific type.
--------------------------------------------------------------
class Test
{
	public void accept(double ...d)
	{
		System.out.println("double");
	}
	public void accept(long ...d)
	{
		System.out.println("long");
	}	
}
public class AmbiguityIssue {

	public static void main(String[] args) 
	{
		Test t = new Test();
		t.accept();
	}
}

Here long will be executed because long is the most specific type.
--------------------------------------------------------------
class Test
{
	public void accept(byte d)  
	{
		System.out.println("byte");
	}
	public void accept(short s)  
	{
		System.out.println("short");
	}	
}
public class AmbiguityIssue {

	public static void main(String[] args)
	{
		Test t = new Test();
		//t.accept(18); //compilation error
		t.accept((short)9);
		t.accept((byte)9);
	}
}

Here value 18 is of type int so, we can't assign directly to byte and short, If we want, explicit type casting is reqd.
---------------------------------------------------------------
class Test
{
	public void accept(int d)
	{
		System.out.println("int");
	}
	public void accept(long s)
	{
		System.out.println("long");
	}	
}
public class AmbiguityIssue {

	public static void main(String[] args) 
	{
		Test t = new Test();
		t.accept(9);
	}
}
Note : Here int will be executed because int is the nearest type
--------------------------------------------------------------
class Test
{
	public void accept(Object s)
	{
		System.out.println("Object");
	}
	public void accept(String s)
	{
		System.out.println("String");
	}	
}
public class AmbiguityIssue {

	public static void main(String[] args) 
	{
		Test t = new Test();
		t.accept(9);  

	}
}

Here Object will be executed.
--------------------------------------------------------------
class Test
{
	public void accept(Object s)
	{
		System.out.println("Object");
	}
	public void accept(String s)
	{
		System.out.println("String");
	}	
}
public class AmbiguityIssue {

	public static void main(String[] args) 
	{
		Test t = new Test();
		t.accept("NIT");
	}
}
Here String will be executed
--------------------------------------------------------------
class Test
{
	public void accept(Object s)
	{
		System.out.println("Object");
	}
	public void accept(String s)
	{
		System.out.println("String");
	}	
	public void accept(Integer i)
	{
		System.out.println("Integer");
	}	
}
public class AmbiguityIssue {

	public static void main(String[] args) 
	{
		Test t = new Test();
		t.accept(null);

	}
}

Here We will get compilation error
---------------------------------------------------------------
class Alpha
{
}
class Beta extends Alpha
{
}
class Test
{	
	public void accept(Alpha s)
	{
		System.out.println("Alpha");
	}	
	public void accept(Beta i)
	{
		System.out.println("Beta");
	}	
}
public class AmbiguityIssue {

	public static void main(String[] args) 
	{
		Test t = new Test();
		t.accept(null);
	}
}

Here Beta will be executed.
--------------------------------------------------------------
class Test
{	
	public void accept(Number s)
	{
		System.out.println("Number");
	}	
	public void accept(Integer i)
	{
		System.out.println("Integer");
	}	
}
public class AmbiguityIssue {

	public static void main(String[] args) 
	{
		Test t = new Test();
		t.accept(12);        

	}
}

Here Integer will be executed.
--------------------------------------------------------------
class Test
{	
	public void accept(long s)
	{
		System.out.println("Widening");
	}	
	public void accept(Integer i)
	{
		System.out.println("Autoboxing");
	}	
}
public class AmbiguityIssue {

	public static void main(String[] args) 
	{
		Test t = new Test();
		t.accept(12);        
    }
}
Here widening is having more priority
--------------------------------------------------------------
class Test 
{	
	public void accept(int ...s)
	{
		System.out.println("Var args");
	}	
	public void accept(Integer i)
	{
		System.out.println("Autoboxing");
	}	
}
public class AmbiguityIssue {

	public static void main(String[] args) 
	{
		Test t = new Test();
		t.accept(12);        
     
    }
}
Here Autoboxing will be executed.
--------------------------------------------------------------
class Test 
{	
	public void accept(Number n)
	{
		System.out.println("Number");
	}	
	public void accept(Double d)
	{
		System.out.println("Double");
	}	
}
public class AmbiguityIssue {

	public static void main(String[] args) 
	{
		Test t = new Test();
		t.accept(12);        
     
    }
}
Here Number will be executed.
==============================================================
****Method Overriding :
------------------------
Writing two or more non static methods in super and sub class in such a way that method name along with method parameter (Method Signature) must be same as well as return type must be compaitable is called Method Overriding.

Method Overriding is not possible without inheritance.

Generally we can't change the return type of the method while overriding a method (compatibility issue) but from JDK 1.5v there is a concept called Co-variant (In same direction) through which we can change the return type of the method.

Example :
---------
class Super
{
	public void m1()
	{
	}
}
class Sub extends Super
{
	public void m1() //Overridden Method
	{
		
	}
}

Method overriding is mainly used to replacing the implementation of super class method by sub class method body.

Advantage of Method Overriding :
---------------------------------
The advantage of Method Overriding is, each sub class is specifying its own specific behavior.
--------------------------------------------------------------
Upcasting :- 
------------
It is possble to assign sub class object to super class reference variable (up) using dynamic polymorphism. It is known as Upcasting.

Example:-    Animal a = new Lion();  //valid [upcasting]

Downcasting :
-------------
By default we can't assign super class object to sub class reference variable.

       Lion l = new Animal();  //Invalid

  Even if we type cast Animal to Lion type then compiler will allow but at runtime JVM will not convert Animal object (Generic type) into Lion object (Specific type) and it will throw an exception java.lang.ClassCastException

   Lion l = (Lion) new Animal(); //At runtime we will get
                                   java.lang.ClassCastException

Note : To avoid this ClassCastException we should use instanceof opertor.

Downcasting is a technique to assign sub class object (Only reference is super type) to sub class reference variable as shown below.

             Animal a1 = new Lion();	     
	     Lion l = (Lion) a1;  //Downcasting


Downcasting is not possible without upcasting.
---------------------------------------------------------------
Program on Method Overriding :
------------------------------
package com.ravi.scenario_based_mo;

class Payment
{
	public void makePayment()
	{
		System.out.println("Generic Payment");
	}
}

class Cash extends Payment
{
	public void makePayment()
	{
		System.out.println("Payment through Cash");
	}
}
class CreditCard extends Payment
{
	public void makePayment()
	{
		System.out.println("Payment through Credit Card");
	}
}

class DebitCard extends Payment
{
	public void makePayment()
	{
		System.out.println("Payment through Debit Card");
	}
}

public class MethodOverridingDemo1 
{
	public static void main(String[] args) 
	{
		
		Payment p = null;
		
		p = new Cash(); p.makePayment();
		p = new DebitCard(); p.makePayment();
		p = new CreditCard(); p.makePayment();
		

	}

}
---------------------------------------------------------------
14-12-2024
-----------
package com.nit.overriding;

class Animal
{
	public void sleep()
	{
		System.out.println("Generaic Aninmal is sleeping here");
	}
}
class Dog extends Animal
{
	public void sleep()
	{
		System.out.println("Dog Aninmal is sleeping here");
	}
}
class Puppy extends Dog
{
	public void sleep()
	{
		System.out.println("Dog Aninmal is sleeping here");
	}
}

public class MethodOverridingDemo2 {

	public static void main(String[] args) 
	{
		Animal a1 = new Puppy();
		a1.sleep();

	}

}

Note : In the above program, compiler willsearch the method from 
Animal class but JVM will start executing from Puppy class followd by Dog, Animal and Object.
------------------------------------------------------------------
@Override Annotation :
--------------------------
In Java we have a concept called Annotation, introduced from JDK 1.5 onwards. All the annotations must be start with @ symbol.

@Override annotation is metadata (Giving information that method is overridden) and it is optional but it is always a good practice to write @Override annotation before the Overridden method so compiler as well as user will get the confirmation that the method is overridden method and it is available in the super class.

If we use @Override annotation before the name of the overridden method in the sub class and if the method is not available in the super class then it will generate a compilation error so it is different from comments because comment will not generate any kind of compilation error if method is not an overridden method, so this is how it is different from comment.


package com.nit.overriding;

class Bird
{
	public  void fly()
	{
		System.out.println("Generic Bird is flying");
	}
}
class Parrot extends Bird
{
    @Override
	public void fly()
	{
		System.out.println("Parrot Bird is flying");
	}
}

class Peacock extends Bird
{
	public void fly()
	{
		System.out.println("Peacock Bird is flying");
	}
}
public class OverridingDemo3 
{
	public static void main(String[] args) 
	{
	   Bird b = null;	
	   
	   b = new Parrot();  b.fly();  //Dynamic Method Dispatch
	   b = new Peacock();  b.fly();  //Dynamic Method Dispatch

	}

}
-------------------------------------------------------------------
package com.ravi.annotation;

class Vehicle
{
	public int fuelCapacity()
	{
		return 40;
	}	
	
	public void printTankCapacity()
	{
		System.out.println(this.fuelCapacity());
	}
}
class Car extends Vehicle
{
	@Override
	public int fuelCapacity()
	{
		return 18;
	}
	
	public void printTankCapacity()
	{
		System.out.println(super.fuelCapacity());
	}
	
}

public class IQ {

	public static void main(String[] args)
	{
		Vehicle v1 = new Car();
		v1.printTankCapacity();

	}

}
--------------------------------------------------------------------
package com.nit.overriding;

class Bird
{
	public void fly()
	{
		System.out.println("Genric Bird is flying");
	}
	
	public void roam()
	{
		System.out.println("Generic Bird is roamig");
	}	
	
}
class Parrot extends Bird
{
	//Method Overloading
	public int fly(double height)
	{
		System.out.println("Parrot is flying with :"+height+" height");
		return 0;
	}
	
	@Override
	public void roam()
	{
		System.out.println("Parrot Bird is roamig");
		
	}
}
public class MethodOverridingDemo1 {

	public static void main(String[] args) 
	{
		Parrot p = new Parrot();
		p.fly(15.6);
		p.roam();
	}

}

Note : From the above program It is clear that Method overloading is also possible in super and sub class.
-----------------------------------------------------------
Variable Hiding concept in upcasting :
---------------------------------------
class Super
{
   int x = 100;
 
}
class Sub exetnds Super
{
   int x = 200;  //Variable Hiding
}

Only non static methods are overridden in java but not the variables[variables are not overridden in java] because behavior will change but not the property(variable).

Note : In upcasting, variable will be always executed besed on the current reference class variable.


Note : static variable, non static variable and static methods 
       are always executed using current reference.

package com.nit.overriding;

class RBI
{
	protected String ifscCode = "RBIHYD0914567";
	
	public String loan()
	{
		return "Provide loan";
	}	
}
class SBI extends RBI
{
	protected String ifscCode = "SBIAMEERPET15679";
	
	@Override
	public String loan()
	{
		return "9.2% ROI";
	}	
}

public class VariableHidingDemo1    
{                                 

	public static void main(String[] args) 
	{
		RBI r = new SBI();
		System.out.println(r.ifscCode+"  : "+r.loan());
	}

}
-----------------------------------------------------------
16-12-2024
-----------
Can we override private method ?
--------------------------------
No, We can't override private method of super class because private methods are not visible (not available) to the sub class hence we can't override.

We can't use @Override annotation on private method of sub class because it is not overridden method, actually it is re-declared by sub class developer.

class Super
{
	private void m1()
	{
	   System.out.println("M1 method in super class");
	}
}
class Sub extends Super
{	
	
	public void m1()  //Re-Declarartion
	{
	   System.out.println("M1 method in Sub class");
	}
}
public class MethodAccessibility 
{
	public static void main(String[] args) 
	{
		new Sub().m1();
	}
}


Note :- private method of super class is not available or not inherited in the sub class so if the sub class declare the method with same signature then it is not overridden method, actually it is re-declared in the sub class. 
----------------------------------------------------------------
Role of access modifier while overriding a method :
---------------------------------------------------
While overriding the method from super class, the access modifier of sub class method must be greater or equal in comparison to access modifier of super class method otherwise we will get compilation error.

In terms of accessibility, public is greater than protected, protected is greater than default (public > protected > default)
[default < protected < public]

**So the conclusion is we can't reduce the visibility of the method while overriding a method.

Note :- private method is not availble (visible) in sub class so it is not the part of method overriding.
----------------------------------------------------------
class Vehicle
{
	public void run()
	{
		System.out.println("Generic Vehicle is running");
	}	
}
class Car extends Vehicle
{
	@Override
	protected void run() //error
	{
		System.out.println("Car Vehicle is running");
	}	
}
public class AccessibilityLevel 
{
	public static void main(String[] args) 
	{
		Vehicle v = new Car();
		v.run();
	}
}
-----------------------------------------------------------
Co-variant in java :
--------------------
As we know while method overriding, the method signature must be same as well as return type must be compaitable,
If return type is not compaitable we will get compilation error as shown in the program.

class Shape
{
	public void draw()
	{
		System.out.println("Generic Draw");
	}
	
}
class Square extends Shape
{
	@Override
	public int draw()
	{
		System.out.println("Drawing Square");
		return 0;
	}
}

public class Incompaitable 
{
	public static void main(String[] args) 
	{
		Shape s1 = new Square();
		s1.draw();
	}
}

Note : error, return type int is not compaitable with void.
-----------------------------------------------------------
-----------------------------------------------------------
But from JDK 1.5 onwards we can change the return type of the method in only one case that the return type of both the METHODS(SUPER AND SUB CLASS METHODS) MUST BE IN INHERITANCE RELATIONSHIP (IS-A relationship so it is compatible) called Co-Variant as shown in the program below.

Note :- Co-variant will not work with primitive data type, it will work only with classes. 

Co-variant represents only one direction that meanse sub class method return type object we can assign super class method return object i.e in one direction.


package com.nit.co_variant;

class Alpha{}
class Beta extends Alpha
{}

class Bird
{
	public Alpha fly()
	{
		System.out.println("Generic Bird is flying");
		return new Alpha();
	}
}
class Parrot extends Bird
{
	@Override
	public Beta  fly()
	{
		System.out.println("Parrot Bird is flying");
		return new Beta();
	}
}

public class CoVariantDemo 
{
	public static void main(String[] args) 
	{
		Bird b = new Parrot();
		b.fly();
	}

}
-----------------------------------------------------------package com.nit.co_variant;

class RBI
{
	public Object loan()
	{
		System.out.println("Bank should provide loan");
		return this;
	}
}
class SBI extends RBI
{
	public Double loan()
	{
		System.out.println("Providing loan @ 9.2% ROI");
		return null;
	}
}

public class CoVariantDemo2 
{
	public static void main(String[] args) 
	{
	   RBI r = new SBI();
	   r.loan();	
           
	}

}
-----------------------------------------------------------
17-12-2024
----------
Polymorphic behavior of Method while using Method Overriding :
-----------
package com.ravi.polymorphic_behavior;

class Payment
{
	public double makePayment(double amount)
	{
	  System.out.println("Payment is in process...");
	  return 0.0;
	}
}
class UPI extends Payment
{
	@Override
	public double makePayment(double amount)
	{
	  System.out.println("Making a payment of "+amount+" using UPI");
	  return amount;
	}
}
class CreditCard extends Payment
{
	@Override
	public double makePayment(double amount)
	{
	  System.out.println("Making a payment of "+amount+" using Credit Card");
	  return amount;
	}
}

public class PolymorphicBehavior
{
	public static void main(String[] args)
	{
		Payment p1 = null;		
		p1 = new UPI();		
		acceptPayment(p1);	
		
		p1 = new CreditCard();
		acceptPayment(p1);
	}
	
	public static void acceptPayment(Payment payment)
	{
		payment.makePayment(12000);
	}

}
-----------------------------------------------------------
How to call specific method of a particular class :
---------------------------------------------------
package com.ravi.poly_behavior;

class Payment
{
	public double makePayment(double amount)
	{
	  System.out.println("Payment is in process...");
	  return 0.0;
	}
}

class UPI extends Payment
{
	@Override
	public double makePayment(double amount)
	{
	  System.out.println("making a payment of "+amount+ " by using UPI");
	  return 0.0;
	}
	
	public void offer()
	{
		System.out.println("2 days Holiday in GOA");
	}	
}
class CreditCard extends Payment
{
	@Override
	public double makePayment(double amount)
	{
	  System.out.println("making a payment of "+amount+ " by using CreditCard");
	  return 0.0;
	}
	
	public void offer()
	{
		System.out.println("Get 1000 RS cash back offer");
	}	
}

public class PolymorphicBehavior {

	public static void main(String[] args) 
	{
		Payment p = null;		
		p = new UPI();
		acceptPayment(p);	
	
	}
	
	public static void acceptPayment(Payment payment)
	{
		UPI upi = (UPI)payment;  //Down-casting
		upi.makePayment(12000);
		upi.offer();
	}

}

Note : By using UPI reference variable we can call UPI class specific method like offer, In order to call specific method of a class we need that corresponding class reference.
-----------------------------------------------------------
package com.ravi.poly_behavior;

class Payment
{
	public double makePayment(double amount)
	{
	  System.out.println("Payment is in process...");
	  return 0.0;
	}
}

class UPI extends Payment
{
	@Override
	public double makePayment(double amount)
	{
	  System.out.println("making a payment of "+amount+ " by using UPI");
	  return 0.0;
	}
	
	public void offer()
	{
		System.out.println("2 days Holiday in GOA");
	}	
}
class CreditCard extends Payment
{
	@Override
	public double makePayment(double amount)
	{
	  System.out.println("making a payment of "+amount+ " by using CreditCard");
	  return 0.0;
	}
	
	public void offer()
	{
		System.out.println("Get 1000 RS cash back offer");
	}	
}

public class PolymorphicBehavior {

	public static void main(String[] args) 
	{
		Payment p = null;		
		p = new UPI();
		acceptPayment(p);
		
		p = new CreditCard();
		acceptPayment(p);
	
	}
	
	public static void acceptPayment(Payment payment)
	{
		UPI upi = (UPI)payment;  //Down-casting
		upi.makePayment(12000);
		upi.offer();
	}

}

Note : When we try to assign CreditCard object into Payment parameter variable, It is ok but we can't convert this CreditCard object into UPI type we will get Runtime 
Exception java.lang.ClassCastException i.e. CreditCard can't be converted into UPI.
-----------------------------------------------------------
instanceof Operator :
---------------------
It is a relational operator which returns true/false.

It is also a keyword.

It is used to verify whether a reference variable is pointing to a particular type of Object or not?

It is used to resolve the issue of ClassCastException.

While working with instanceof operator we must have IS-A
relation in between reference variable and class/interface 
type otherwise we will get compilation error.
-----------------------------------------------------------
Program on instanceof operator :
---------------------------------
package com.ravi.instance_of_demo;

class Alpha
{
	
}
class Beta extends Alpha
{
	
}
class Gamma extends Beta
{
	
}

public class InstanceOfDemo1 
{
	public static void main(String[] args) 
	{
		Gamma g = new Gamma();
		
		if(g instanceof Gamma)
		{
			System.out.println("g is pointing to Gamma Object");
		}
		if(g instanceof Beta)
		{
			System.out.println("g is pointing to Beta Object");
		}
		if(g instanceof Alpha)
		{
			System.out.println("g is pointing to Alpha Object");
		}
		if(g instanceof Object)
		{
			System.out.println("g is pointing to Object Object");
		}
	}

}
-----------------------------------------------------------
package com.ravi.instance_of_demo;

class Bird
{
	public void fly()
	{
		System.out.println("Can fly");
	}
}
class Fish 
{
	public void swim()
	{
		System.out.println("Can swim");
	}
}


public class InstanceOf {

	public static void main(String[] args) 
	{
		Fish f = new Fish();

		if(f instanceof Bird)  //Compilation error
		{
			
		}

	}

}

Here we will get compilation error becoz there is no relation between Bird and Fish
-----------------------------------------------------------
package com.ravi.instance_of_demo;

public class InstanceOfDemo3 
{
	public static void main(String[] args)
	{
		String str = "India";
		
		if(str instanceof String)
		{
			System.out.println("str is pointing to String object");
		}

	}

}
-----------------------------------------------------------
package com.ravi.instance_of_demo;

class Vehicle
{
	public void run()
	{
		System.out.println("Vehicle is running");
	}
}

class BMW extends Vehicle
{
	
}

class Audi extends Vehicle
{
	
}



public class InstanceOfDemo4 {

	public static void main(String[] args) 
	{
		
		//BMW b = new BMW();
		//acceptCarType(b);
		
		Audi a = new Audi();
		acceptCarType(a);	
	}
	
	public static void acceptCarType(Vehicle v)
	{
		
		if(v instanceof BMW)
		{
			System.out.println("BMW Car");
		}
		else
		{
			System.out.println("AUDI Car");
		}	
		
	}

}

==========================================================
 package com.ravi.poly_behavior;

class Payment
{
	public double makePayment(double amount)
	{
	  System.out.println("Payment is in process...");
	  return 0.0;
	}
}

class UPI extends Payment
{
	@Override
	public double makePayment(double amount)
	{
	  System.out.println("making a payment of "+amount+ " by using UPI");
	  return 0.0;
	}
	
	public void offer()
	{
		System.out.println("2 days Holiday in GOA");
	}	
}
class CreditCard extends Payment
{
	@Override
	public double makePayment(double amount)
	{
	  System.out.println("making a payment of "+amount+ " by using CreditCard");
	  return 0.0;
	}
	
	public void offer()
	{
		System.out.println("Get 1000 RS cash back offer");
	}	
}

class DebitCard extends Payment
{
	@Override
	public double makePayment(double amount)
	{
	  System.out.println("making a payment of "+amount+ " by using DebitCard");
	  return 0.0;
	}
	
}


public class PolymorphicBehavior {

	public static void main(String[] args) 
	{
		UPI u = new UPI();
		CreditCard cc = new CreditCard();
		DebitCard dc = new DebitCard();
		
		acceptPayment(u,cc,dc);
	
	}
	
	public static void acceptPayment(Payment ...payment)
	{
		for(Payment p : payment)
		{
			if(p instanceof UPI)
			{
				UPI upi = (UPI)p;
				upi.makePayment(15000);
				upi.offer();
			}
			else if(p instanceof CreditCard)
			{
				CreditCard cc = (CreditCard) p;
				cc.makePayment(22000);
				cc.offer();
			}
			else if(p instanceof DebitCard)
			{
				DebitCard d = (DebitCard) p;
				d.makePayment(12000);
			}
			
			else if(p instanceof Cash)
			{
				DebitCard d = (DebitCard) p;
				d.makePayment(12000);
			}
		}
	}

}
===========================================================
 final keyword in java :
-----------------------
It is used to provide some kind of restriction in our program.
We can use final keyword in ways 3 ways in java.

1) To declare a class as a final. (Inheritance is not possible)
2) To declare a method as a final (Overriding is not possible)
3) To declare a variable (Field) as a final (Re-assignment is not possible)    
     
18-12-2024
----------
1) To declare a class as a final :
-----------------------------------
Whenever we declare a class as a final class then we cann't extend or inherit that class otherwise we will get a compilation error.

We should declare a class as a final if the composition of the class (logic of the class) is very important and we don't want to share the feature of the class to some other developer to modify the original behavior of the existing class, In that situation we should declare a class as a final.

Declaring a class as a final does not mean that the variables and methods declared inside the class will also become as a final, only the class behavior is final that means we can modify the variables value as well as we can create the object for the final classes.

Note :- In java String and All wrapper classes are declared as final class.
--------------------------------------------------------------
final class A
{
	private int x = 100;

	public void setData()
	{
		x = 120;
		System.out.println(x);
	}
}
class B extends A 
{   
}
public class FinalClassEx
{
	public static void main(String[] args)
	{
		B b1 = new B();
		b1.setData();		
	}
}
Note : class A is final so we can't inherit hence we will get compilation error.
---------------------------------------------------------------
final class Test
{
	private int data = 100;

	public Test(int data)
	{
		this.data = data;
		System.out.println("Data value is :"+data);
	}
}
public class FinalClassEx1 
{
	public static void main(String[] args) 
	{
		Test t1 = new Test(200);
		
	}
}
Note : for final class we can create object as well as we can modify the data.
--------------------------------------------------------------
Whenever we declare a constructor as private then we should declare the class with final modifier. If constructor is private then we can't create a sub class because super class constructor is not visible from sub class constructor.

final class Sample
{
	private Sample() //Constructor is private so declare
	                    the class with final modifier
	{
	  System.out.println("Private Constructor");	
	}
}

public class FinalClassEx2 
{
	public static void main(String[] args) 
	{
		
	}
}
---------------------------------------------------------------
Sealed class in Java :
-----------------------
It is a new feature introduced from java 15v (preview version) and become the integral part of java from 17v.

It is an improvement over final keyword.

By using sealed keyword we can declare classes and interfaces as sealed.

It is one kind of restriction that describes which classes and interfaces can extend or implement from Sealed class Or interface.

It is similar to final keyword with less restriction because here we can permit the classes to extend from the original Sealed class.

The class which is inheriting from the sealed class must be final, sealed or non-sealed.

The sealed class must have atleast one sub class.

We can also create object for Sealed class.

It provides the following modifiers :

1) sealed : Can be extended only through permitted class.

2) non-sealed : Can be extended by any sub class, if a user wants to give permission to its sub classes.

3) permits : We can provide permission to the sub classes, which are inheriting through Sealed class OR sealed interface

4) final : we can declare permitted sub class as final so, it cannot be extended further.


package com.ravi.sealed;

sealed class Bird permits Parrot, Sparrow
{
	public void roam()
	{
		System.out.println("Generic Bird is roaming");
	}
}
non-sealed class Parrot extends Bird
{
	@Override
	public void roam()
	{
		System.out.println("Parrot Bird is roaming");
	}
}
final class Sparrow extends Bird
{
	@Override
	public void roam()
	{
		System.out.println("Sparrow Bird is roaming");
	}
}


public class SealedDemo1 {

	public static void main(String[] args) 
	{
		Bird b = null;
		
		b = new Parrot(); b.roam();   //Dynamic Method Dispatch
		b = new Sparrow(); b.roam();   //Dynamic Method Dispatch

	}

}
-------------------------------------------------------------
package com.nit.sealed;

sealed class OnlineClass permits Laptop, Mobile
{
	public void attendJavaOnline()
	{
		System.out.println("Sunday online class at 9: 30AM");
	}
}
final class Laptop extends OnlineClass
{
	@Override
	public void attendJavaOnline()
	{
		System.out.println("Attending online class through Laptop");
	}
}
final class Mobile extends OnlineClass
{
	@Override
	public void attendJavaOnline()
	{
		System.out.println("Attending online class through Mobile");
	}
}

public class SealedDemo2 {

	public static void main(String[] args) 
	{
      OnlineClass onlineClass = null;
      
      onlineClass = new Laptop(); onlineClass.attendJavaOnline();
      onlineClass = new Mobile(); onlineClass.attendJavaOnline();
      
	}

}
--------------------------------------------------------------
2) To declare a method as a final (Overriding is not possible)
---------------------------------------------------------------
Whenever we declare a method as a final then we can't override that method in the sub class otherwise there will be a compilation error.

We should declare a method as a final if the body of the method i.e the implementation of the method is very important and we don't want to override or change the super class method body by sub class method body then we should declare the super class method as final method.
---------------------------------------------------------------
class A
{
	protected int a = 10;
	protected int b = 20;

     public final void calculate()
	 {
		int sum = a+b;
		System.out.println("Sum is :"+sum);
	 } 
}
class B extends A
{	
	@Override
	public void calculate() //error
	{
		int mul = a*b;
		System.out.println("Mul is :"+mul);	
	}
}
public class FinalMethodEx 
{
	public static void main(String [] args) 
	{
		 A a1 = new B();
		 a1.calculate();
	}
}
---------------------------------------------------------------
class Alpha   
{
	private final void accept()
	{
		System.out.println("Alpha class accept method");
	}
}
class Beta extends Alpha
{
	public void accept()
	{
		System.out.println("Beta class accept method");
	}
}
public class FinalMethodEx1 
{
	public static void main(String [] args) 
	{
		new Beta().accept();
	}
}

Note : Here Program will compile and execute because private method of super class is not available to sub class.
-------------------------------------------------------------
3) To declare a variable/Field as a final :
--------------------------------------------
In older langugaes like C and C++ we use "const" keyword to declare a constant variable but in java, const is a reserved word for future use so instead of const we should use "final" keyword.

If we declare a variable as a final then we can't perform re-assignment (i.e nothing but re-initialization) of that variable.

In java It is always a better practise to declare a final variable by uppercase letter according to the naming convention.

---------------------------------------------------------------
class A
{
	final int A = 10;       //re-assignment is not possible     
	public void setData()
	{
		 A = 10;  //error
		 System.out.println("A value is :"+A);
	}
}
class FinalVarEx 
{
	public static void main(String[] args) 
	{
		final A a1 = new A();
		a1.setData();
		
		a1 = new A(); //error
		a1.setData();
	}
}
---------------------------------------------------------------
19-12-2024
-----------
What is Method Hiding in java ?
           OR
Can we override static Method ?
           OR
Can we override main Method ?

In order to work with Method Hiding we have different Cases :

Case 1 :
---------
Any public static method of super class is by default available 
to sub class so from sub class we can call super class static method as shown in the program below :

class Super
{
	public static void m1()
	{
		System.out.println("m1 static method of super class");
	}
}
class Sub extends Super
{
	
}

public class MethodHiding 
{
	public static void main(String[] args) 
	{
		Super.m1();
		Sub.m1();
		Sub s1 = new Sub();
		s1.m1();
	}
}
---------------------------------------------------------------
Case 2 :
-------
We can't override a static method with non static method because static method belongs to class and non static method belongs to object, If we try to override static method with non static method then it will generate an error i.e overridden method is static as shown below.

class Super
{
	public static void m1()
	{
		System.out.println("m1 static method of super class");
	}
}
class Sub extends Super
{
	public void m1() //error
	{
		System.out.println("m1 non static method of Sub class");
	}
}

public class MethodHiding1 
{
	public static void main(String[] args) 
	{
		
	}
}
---------------------------------------------------------------
Case 3 :
--------
We can't override any non static method with static method, If we try then it will generate an error, Overriding method is static.

class Super
{
	public void m1()
	{
		System.out.println("m1 non static method of super class");
	}
}
class Sub extends Super
{
	public static void m1()
	{
		System.out.println("m1 static method of Sub class");
	}
}

public class MethodHiding1 
{
	public static void main(String[] args) 
	{
		
	}
}

So, the conclusion is we cannot overide static with non static method as well as non-static with static method because static method belongs to class and non-static method belongs to object.
---------------------------------------------------------------
Can we show that the following program is Method Hiding but not Overriding :

class Super
{
	public static void m1()
	{
		System.out.println("m1  static method of super class");
	}
}
class Sub extends Super
{
	
	public static int m1()  
	{
		System.out.println("m1 static method of Sub class");
		return 0;
	}
}

public class MethodHiding 
{
	public static void main(String[] args) 
	{
		
	}
}

From the above program it is clear that :
Method Hiding belons to static Method 
Method Overriding belons to non-static Method 

Case 4 :
---------
We can't override static method because It belong to class but not object, If we write static method in the sub class with same signature and compaitable return type then It is Method Hiding but not Method Overriding here compiler will search the method of super class and JVM will also execute the method of super class because method is not overridden.[Single copy and belongs to class area, sharable by all the objects]

Note :- 1) We can't apply @Override annotation on static methods.

        2) Static methods can't be overridden so behavior is 
	   same for all the Objects hence it is Static Polymorphism.

package com.ravi.method_hiding;

class Animal
{
	public static void checkup()
	{
		System.out.println("Check Up rule for all the Animals :");		
	}
}

class Dog extends Animal
{
	public static void checkup()
	{
		System.out.println("Check Up rule for Dog Animal");		
	}
}
class Lion extends Animal
{
	public static void checkup()
	{
		System.out.println("Check Up rule for Lion Animal");		
	}
}
public class OverriidngStaicMethod {

	public static void main(String[] args) 
	{
        Animal a = null;
        
        a = new Dog();  a.checkup();
        a = new Lion();  a.checkup();
        
 
	}

}

static method always executed by using current reference
---------------------------------------------------------------
Abstraction [Hiding the complexcity]
------------------------------------
Showing the essential details without showing the background details is called Abstraction.

In order to acheive abstraction we can use the following two concepts of Java :

1) Abstract class and abstract Method (It provides 0 - 100% abstraction so Partial Abstraction)

2) Interface (100% abstraction)

-------------------------------------------------------------
20-12-2024
------------
Abstract class and abstract methods :
-------------------------------------------
A class that does not provide complete implementation (partial implementation) is defined as an abstract class.

An abstract method is a common method which is used to provide easiness to the programmer because the programmer faces complexcity to remember the method name.

An abstract method observation is very simple because every abstract method contains abstract keyword, abstract method does not contain any method body and at the end there must be a terminator i.e ; (semicolon)

In java, whenever action is common but implementations are different then we should use abstract method, Generally we declare abstract method in the super class and its implementation must be provided in the sub classes.

if a class contains at least one method as an abstract method then we should compulsory declare that class as an abstract class.

Once a class is declared as an abstract class we can't create an object for that class.

*All the abstract methods declared in the super class must be overridden in the sub classes otherwise the sub class will become as an abstract class hence object can't be created for the sub class as well.

In an abstract class we can write all abstract method or all concrete method or combination of both the method. 

It is used to acheive partial abstraction that means by using abstract classes we can acheive partial abstraction(0-100%).

*An abstract class may or may not have abstract method but an abstract method must have abstract class.

Note :- We can't declare an abstract method as final, private and static (illegal combination of modifiers)

We can't declare an abstract class as a final.
-------------------------------------------------------------
abstract class Shape
{
	public abstract void draw();	
}
class Square extends Shape
{
   @Override
   public void draw()
   {
	   System.out.println("Drawing Square");
   }
}
class Rectangle extends Shape
{
   @Override
   public void draw()
   {
	   System.out.println("Drawing Rectangle");
   }
}

public class AbstractDemo1 
{
	public static void main(String[] args) 
	{
		Shape s = new Square();  
		s.draw();
		
		Shape s1 = new Rectangle();  
		s1.draw();
	}
}
-------------------------------------------------------------
package com.ravi.asbatrct_demo;

abstract class Vehicle
{
	protected int speed = 120;
	
	public Vehicle()
	{
		System.out.println("Vehicle class Constructor");
	}
	
	public void getVehicleDetails()
	{
		System.out.println("Vehicle has 4 wheels...");
	}
	
	public abstract void run();	
}

class Car extends Vehicle
{
	@Override
	public void run() 
	{
		System.out.println("Car is Running");		
	}	
}


public class IQ 
{
	public static void main(String[] args) 
	{
        Vehicle v = new Car();
        System.out.println("Speed is :"+v.speed);
        v.getVehicleDetails();
        v.run();
	}

}

Note : abstracr class constructor will be executed through 
       sub class object by using super()
 -----------------------------------------------------------
IQ :
-----
What is the advantage of writing instance variable(Object properties) and constructor inside an abstract class, If we can't create an object for abstract class ?

Yes, We can't create an object for abstract class but still we can write instance variable and constructor that means 
abstract class also contains properties and behavior but these properties will initialize through sub class object using super() so we can write object properties as well as 
constructor.
-------------------------------------------------------------
WAP to initailize super abstract class properties by using sub class object.

package com.ravi.asbatrct_demo;

abstract class Shape 
{
	protected String shapeType;

	public Shape(String shapeType) 
	{
		super();
		this.shapeType = shapeType;
	}

	public abstract void draw();
}

class Square extends Shape
{
	public Square(String shape)
	{
		super(shape);
	}

	@Override
	public void draw()
	{
		System.out.println("Drawing :"+shapeType);		
	}
}
class Rectangle extends Shape
{
	public Rectangle(String shape)
	{
		super(shape);
	}

	@Override
	public void draw()
	{
		System.out.println("Darwing :"+shapeType);		
	}
}

public class AbstractDemo1 
{
	public static void main(String[] args) 
	{
		Square ss = new Square("Square");
		ss.draw();
		
		Rectangle rr = new Rectangle("Rectangle");
		rr.draw();
	}

}
-------------------------------------------------------------
WAP that describes overriding of abstract method is compulsory in the sub classes otherwise sub class will also 
become as an abstract class.

package com.ravi.asbatrct_demo;

abstract class Alpha
{
	public abstract void show();
	public abstract void demo();
}
abstract class Beta extends Alpha
{
	@Override
	public void show()  //demo();
	{
		System.out.println("Show Method Overridden in Beta class");
	}
}
class Gamma extends Beta
{
	@Override
	public void demo() 
	{
		System.out.println("Demo Method Overridden in Gamma class");		
	}	
}
public class AbstractDemo2 
{
	public static void main(String[] args) 
	{
		Gamma g = new Gamma();
		g.show();
		g.demo();
	}

}
------------------------------------------------------------
WAP to show that abstract method is working as Business Rule
so all the sub classes will follow this rule :

package com.ravi.asbatrct_demo;

abstract class Animal
{
	protected String name;	
	
	public Animal(String name) 
	{
		super();
		this.name = name;
	}
	
	public abstract void checkup();
}

class Lion extends Animal
{
	public Lion(String name)
	{
		super(name);
	}
		
	@Override
	public void checkup() 
	{
		System.out.println(name+" is going for Check up");		
	}
	
}
class Elephant extends Animal
{
	public Elephant(String name)
	{
		super(name);
	}
		
	@Override
	public void checkup() 
	{
		System.out.println(name+" is going for Check up");		
	}	
}
class Dog extends Animal
{
	public Dog(String name)
	{
		super(name);
	}
		
	@Override
	public void checkup() 
	{
		System.out.println(name+" is going for Check up");		
	}	
}

public class AbstractDemo3 
{
	public static void main(String[] args) 
	{
       Lion lions[] = {new Lion("Simba"), new Lion("Scar"),new Lion("Alex")};  
       
       Elephant [] elephants = {new Elephant("Airavata"), new Elephant("My ele")};
       
       Dog [] dogs = {new Dog("Tommy"), new Dog("Tiger"), new Dog("My Dog")};
       
       checkAnimal(lions);
       System.out.println("..............");
       checkAnimal(elephants);
       System.out.println("..............");
       checkAnimal(dogs);
       
       
	}	
	
	
	public static void checkAnimal(Animal ...animals)
	{
		for(Animal animal : animals)
		{
			animal.checkup();
		}
		
	}

}
------------------------------------------------------------
21-12-2024
-----------
Anonymous inner class concept :
--------------------------------
If we declare a class inside a method without any name and with ; (terminator) then it is called Anonymous inner class.

All the .class files are represented by $ symbol.An anonymous inner class .class files are represented by numbers like $1, $2 and so on

The main purpose of Anonymous inner class to extend a class OR to implement an interface that means to create sub type.

Anonymous inner class, class declaration and object creation by using new keyword is possible in the same line at the time of declartion the anonymous inner class body.
-------------------------------------------------------------
//Program to implement Anonymous inner class by using Concrete class

AnonymousDemo1.java
---------------------
package com.ravi.anonymous;

class Super
{
	public void show()
	{
		System.out.println("Super class Show Method.");
	}

}

public class AnonymousDemo1 {

	public static void main(String[] args)
	{
		//Anonymous inner class(Without any Name)
		Super sub = new Super()
		{
			@Override
			public void show()
			{
				System.out.println("Sub class Show Method.");
			}		
			
		};
		
		sub.show();
		

	}

}


//Program to implement Anonymous inner class by using abstract class

package com.ravi.anonymous;

abstract class Vehicle
{
	public abstract void run();
}

public class AnonymousDemo2 {

	public static void main(String[] args)
	{
		Vehicle car = new Vehicle()
		{
			@Override
			public void run() 
			{
			  System.out.println("car is Running");				
			}
			
		};

		Vehicle bike = new Vehicle() 
		{			
			@Override
			public void run() 
			{
				System.out.println("Bike is running");				
			}
		};
		
		car.run();  bike.run();
		
	}

}
============================================================
interface :
-----------

interface upto java 1.7
------------------------
An interface is a keyword in java which is similar to a class which defines working functionality of a class.

Upto JDK 1.7 an interface contains only abstract methods that means there is a guarantee that inside an interfcae we don't have concrete or general or instance methods.

From java 8 onwards we have a facility to write default and static methods.

By using interface we can achieve 100% abstraction concept because it contains only abstract methods.

In order to implement the member of an interface, java software people has provided implements keyword.

All the methods declared inside an interface is by default public and abstract so at the time of overriding we can't reduce the accessibility level.

All the variables declared inside an interface is by default public, static and final.

We should override all the abstract methods of interface to the sub classes otherwise the sub class will become as an abstract class hence object can't be created.

We can't create an object for interface, but reference can be created.

By using interface we can acheive multiple inheritance in java.

We can achieve loose coupling using interface.

Note :- inside an interface we can't declare any blocks (instance, static), instance variables (No properties) as well as we can't write constructor inside an interface.
===========================================================
23-12-2024
-----------
//Programs using interface concept :
-----------------------------------
package com.ravi.interface_demo;

sealed interface Moveable permits Car
{
	int SPEED = 100;   //public  + static + final
	void move();       //public + abstract

}
final class Car implements Moveable

{
	@Override
	public void move() 
	{
		//SPEED = 120;	//Invalid
		System.out.println("Car speed is :"+SPEED);
	}	
}
public class InterfaceDemo1 
{
		public static void main(String[] args) 
		{
		    Moveable m = new Car();
		    m.move();
		    
		    System.out.println("Speed of the Car is :"+Moveable.SPEED);
	    }

}
------------------------------------------------------------
package com.ravi.interface_demo;

interface Bank
{
	void deposit(double amount);
	void withdraw(double amount);
}

class Customer implements Bank
{
	protected double balance;

	public Customer(double balance) 
	{
		super();
		this.balance = balance;
	}

	@Override
	public void deposit(double amount) 
	{
		if(amount <=0)
		{
			System.err.println("Amount can't be deposited");
			System.exit(0);
		}
		else
		{
			this.balance = this.balance + amount;
			System.out.println("Balance after deposit :"+this.balance);
		}
		
	}

	@Override
	public void withdraw(double amount) 
	{
		if(amount > this.balance)
		{
			System.err.println("Insufficient Balance!!");
			System.exit(0);
		}
		else
		{
			this.balance = this.balance - amount;
			System.out.println("Amount after Witdraw is :"+this.balance);
		}		
	}
	
	public double getCurrentBalance()
	{
		return this.balance;
	}
}

public class InterfaceDemo2 {

	public static void main(String[] args) 
	{
		Customer scott = new Customer(1000);
        System.out.println("Current Balance is :"+scott.getCurrentBalance());
        scott.deposit(1000);
        scott.withdraw(500);
	}

}
-------------------------------------------------------------
Program on loose coupling : (Industry Standard Program)
--------------------------------------------------------
Loose Coupling :- If the degree of dependency from one class object to another class is very low then it is called loose coupling. [interface is reqd]

Tightly coupled :- If the degree of dependency of one class to another class is very high then it is called Tightly coupled.

According to IT industry standard we should always prefer loose coupling so the maintenance of the project will become easy.

High Cohesion [Encapsulation]:
------------------------------
Our private data must be accessible via public methods (setter and getters) so, in between data and method we must have high cohesion.
(tight coupling) so, validation of outer data is possible.

6 files :
----------
HotDrink.java(I)
package com.ravi.loose_coupling;

public interface HotDrink 
{
   void prepare();
}

Tea.java
--------
package com.ravi.loose_coupling;

public class Tea implements HotDrink 
{
	@Override
	public void prepare() 
	{
		System.out.println("Preparing Tea");
	}

}

Coffee.java
-------------
package com.ravi.loose_coupling;

public class Coffee implements HotDrink 
{
	@Override
	public void prepare() 
	{
		System.out.println("Preparing Coffee");

	}

}
Horlicks.java
--------------
package com.ravi.loose_coupling;

public class Horlicks implements HotDrink {

	@Override
	public void prepare() 
	{
		System.out.println("Preparing Horlicks");

	}

}

Restaurant.java
----------------
package com.ravi.loose_coupling;

public class Restaurant 
{
   public static void acceptObject(HotDrink hd)  //hd = new Tea();
   {
	   hd.prepare();
   }
}

LooseCoupling.java
--------------------
package com.ravi.loose_coupling;

public class LooseCoupling 
{
   public static void main(String[] args) 
   {
	  Restaurant.acceptObject(new Tea());
	  Restaurant.acceptObject(new Coffee());
	  Restaurant.acceptObject(new Horlicks());
   }
}

Method retutn type as a interface :
-----------------------------------
It is always better to take method return type as interface so we can return any implementer class object as shown in the example below

public HotDrink accept()
{
   return new Tea() OR new Coffee() OR new Horlicks() OR any future
   implementer class object...........................
}

-------------------------------------------------------------
Compile time constant :
-----------------------
A compile time constant is a constant that is evaluated and replaced with its value at compile time rather than runtime.

It must be declared with static and final modifier as well as initialized with constant expression. (Must not be initialized by method call)

At compile time constant value will be converted by compiler at the time of compilation itself so, at runtime JVM can see the value but not the class name so class will not be loaded as shown in the program.

Example :  public static final int A = 100; //Valid
       
           public static final int A = m1(); //valid [Here
	   class will be loaded by JVM]

class Foo
{
	public static final int A = 100; //compile time Constant
	
	static 
	{
		System.out.println("Static Block");
	}
}

public class CompileTimeConstant 
{
	public static void main(String[] args) 
	{
		System.out.println(Foo.A);
	}
}

Note : SB will not be executed.
-------------------------------------------------------------
class Foo
{
	public static final int A = returnValue(); 
	
	static 
	{
		System.out.println("Static Block");
	}
	
	public static int returnValue()
	{
		return 500;
	}
}

public class CompileTimeConstant1 
{
	public static void main(String[] args) 
	{
		System.out.println(Foo.A);
	}
}

Note : SB will be executed
------------------------------------------------------------
2 files :

Test.java
---------
public class Test 
{
	public static final int MAX_VALUE = 999;
}

Main.java
---------
public class Main 
{
	public static void main(String[] args) 
	{
		System.out.println(Test.MAX_VALUE);
	}
}

Note : If we compile and execute both programs we will get 999 value, now change the 999 to 1500, Re- compile only Test.java so a new .class file will be acreated which will hold 1500 value. Now without re-compilation of main.java if we execute Main.java then we wil get 999 so it takes the value at compile time.
-----------------------------------------------------------
24-12-2024
-----------
Multiple Inheritance by using interface :
-----------------------------------------
In a class we have a constructor so, it is providing ambiguity issue but inside an interface we don't have constructor so multiple inheritance is possible using interface as shown in the program below.

The Implementer class constructor's super keyword will directly move to Object class constructor.[24-DEC]

package com.ravi.interface_demo;

interface A
{
	void m1();
}

interface B
{
	void m1();
}

class Implementer implements A,B
{
	@Override
	public void m1() 
	{
		System.out.println("Multiple Inheritance is Possible");		
	}
	
}

public class MultipleInheritance {

	public static void main(String[] args) 
	{
		new Implementer().m1();
	}

}
-----------------------------------------------------------------
Extending an interface :
-------------------------
One interface can extend another interface but it can't implement an interface as shown in the program.

package com.ravi.interface_demo;

abstract interface Alpha
{
	void m1();
}

abstract interface Beta extends Alpha
{
	void m2();
}

class Sub implements Beta
{
	@Override
	public void m1() 
	{
		System.out.println("M1 method implemented");		
	}

	@Override
	public void m2() 
	{
		System.out.println("M2 method implemented");			
	}
	
}

public class ExteningInterface {

	public static void main(String[] args)
	{
		Sub s1 = new Sub();
		s1.m1();  s1.m2();

	}

}
------------------------------------------------------------------
java 8 fetaures :
-----------------
Interface from JDK 1.8V
------------------------
What is the limitation of abstract method in project maintenance :
-------------------------------------------------------------
Java 8 fetaures are introduced in java from March 2014.

intreface from JDK 1.8V  [Java 8 = March 2014]
----------------------------------------------
Limitation of abstract method    
           OR
Maintenance problem with interface in an Industry upto JDK 1.7

The major maintenance problem with interface is, if we add any new abstract method at the later stage of development inside an existing interface then all the implementer classes have to override that abstract method otherwise the  implementer class will become as an abstract class so it is one kind of boundation.

We need to provide implementation for all the abstract methods available inside an interface whether it is required or not?

To avoid this maintenance problem java software people introduced default method inside an interface.

-------------------------------------------------------------
What is default method :
-------------------------
We can write default method (method with body) inside an interface with default keyword from Java 8v.

This default method provides "default implementation" so the implementer class can override to provide specific implementation in the class.

Unlike abstract method, default method does not provide any kind of boundation to override this default method in the sub class.

By default the access modifier of default method is public.

We can't write default method inside a class, we can write 
only inside an interface.
------------------------------------------------------------------
4 files :
---------
Vehicle.java(I)
-------------
package com.ravi.java8;

public interface Vehicle 
{	
   void run();
   void horn();
   
   default void digitalMeter()  //java 8
   {
	  System.out.println("Digital Meter Facility is coming soon!!!"); 
   }
}

Car.java
----------
package com.ravi.java8;

public class Car implements Vehicle
{
	@Override
	public void run() 
	{
		System.out.println("Car is Running");		
	}

	@Override
	public void horn() 
	{
		System.out.println("Car has Horn");		
	}
	
	@Override
	public void digitalMeter()  //java 8
	{
	  System.out.println("Car has Digital Meter Facility");	  
	}
	
}

Bike.java
---------
package com.ravi.java8;

public class Bike implements Vehicle
{
	
	@Override
	public void run() 
	{
		System.out.println("Bike is Running");		
	}
	
	@Override
	public void horn() 
	{
		System.out.println("Bike has Horn");		
	}
}

DefaultMethod.java
------------------
package com.ravi.java8;

public class DefaultMethod 
{
	public static void main(String[] args) 
	{
		
		Vehicle v = null;
		
		v = new Car(); v.run(); v.horn(); v.digitalMeter();
		v = new Bike(); v.run(); v.horn();v.digitalMeter();
	}

}
-------------------------------------------------------------
What is static method of an interface :
----------------------------------------
We can write static method inside an interface from java 8 version.

Example :
---------
public interface Calculate
{
   static double getCube(int num) //java 8 [AM is public]
   {
   }
}

by default this static method access modifier is public.

static method we can write inside an interafce to provide common functionality.

A static method of interface is not available to the implementer classes so static method of an interface can 
be accessible through interface only.
-------------------------------------------------------------
Program that describes static method of an interface is by default public so we can access from another package.


Calculate.java(com.ravi.interface_static_method)
package com.ravi.interface_static_method;

public interface Calculate 
{
  static double getCube(int num)
  {
	  return (num*num*num);
  }
  
  static double getSquare(int num)
  {
	  return (num*num);
  }
  
}

package com.ravi.priority;

import com.ravi.interface_static_method.Calculate;

public class ELC //This class is in another package.
{
	public static void main(String[] args)
	{
		double result = Calculate.getCube(8);
		System.out.println("Cube of 8 is :"+result);
		
		result = Calculate.getSquare(12);
		System.out.println("Square of 12 is :"+result);


	}

}
-------------------------------------------------------------
From java 8 version It is also possible to write main method 
inside an interface and it will be executed.

package com.ravi.interface_static_method;

public interface Callable 
{
  public static void main(String[] args) 
  {
	System.out.println("Main method inside interface");
  }
}
-------------------------------------------------------------
Program that describes interface static methods are available to interafce only.

package com.ravi.interface_static_method;

interface Printable
{
	static void m1()
	{
		System.out.println("M1 static Method");
	}
}
public class ScopeOfStaticMethod implements Printable
{
	public static void main(String[] args) 
	{
		Printable.m1();
		//ScopeOfStaticMethod.m1();		
		//new ScopeOfStaticMethod().m1();
	}

}
------------------------------------------------------------
Interface Static Method:
------------------------
   a) Accessible using the interface name.
   b) Cannot be hidden by implementing classes.(Not Available)
   c) Can be called using the interface name only.

Class Static Method:
--------------------
   a) Accessible using the class name.
   b) Can be hidden (not overridden) in subclasses by redeclaring a static method with the same signature and compaitable return type.
   c) Can be called using the super class, sub class name as well as sub class object.
-------------------------------------------------------------
Priority of deafult and concrete method :
-----------------------------------------
While working with class and interface, default method is having low
priority than concrete method, In the same way class is more powerfult than interface.

interface A
{
}
class B
{
}

class C extends B implements A  {}  //Valid

class C implements A extends B {} //Invalid
-------------------------------------------------------------
package com.ravi.default_method;

interface A
{
   default void m1()
   {
	   System.out.println("default method of interface A");
   }
}
class B 
{
	public void m1()
	{
		System.out.println("Concrete method of class B");
	}
}

class C extends B implements A 
{
	
}
public class Priority 
{
	public static void main(String[] args)
	{
		C c1 = new C();
		c1.m1();
	}

}
-------------------------------------------------------------
Can we achieve multiple inheritance using default method :
----------------------------------------------------------
Multiple inheritance is possible in java by using default method inside an interface, here we need to use super keyword to differenciate the super interface methods.
Before java 1.8, we have abstract method inside an interface but now we can write method body(default method) so, to execute the default method inside an interface we need to take super keyword with interface name(Alpha.super.m1()).

package com.ravi.default_method;

interface Alpha
{
	default void m1()
	{
		System.out.println("m1 method of Alpha interface ");
	}
}
interface Beta
{
	default void m1()
	{
		System.out.println("m1 method of Beta interface ");
	}
}
class Foo implements Alpha, Beta
{	
	@Override
	public void m1() 
	{
	  Alpha.super.m1();
	  Beta.super.m1();
      System.out.println("MI is possible using default method");		
	}	
}
public class MultipleInheritance {

	public static void main(String[] args) 
	{
		new Foo().m1();
	}

}
-------------------------------------------------------------
package com.ravi.default_method;

interface Hello
{
	int x = 100;
}
abstract class Test
{
	int x = 200;
}
class MyClass extends Test implements Hello
{
   int x = 300; //Variable Hiding to solve ambiguity issue
   public void show() 
   {
	 System.out.println(x);   
   }
}

public class VariableHiding {

	public static void main(String[] args) 
	{
		new MyClass().show();

	}

}
-------------------------------------------------------------
Introduction to Functional Programming ?
----------------------------------------
From JDK 8 onwards, Java also concentrated on function/method and introduced Functional Programming.

It is mainly used to write concise coding so the length of the method will be reduced.

What is a Functional interface in java ?
----------------------------------------
If an interface contains exactly one abstract method then 
that interface is known as Functional interafce.

Example :
----------
public interface Drawable
{
  void draw();  //SAM [Single abstract method]
}


It may contain 'n' number of default and static methods but It must contain only one abstract method.

In order to restrict developer to take more than one abstract method, Java software people has introduced @FunctionalInterface annotation.

Example :
---------
@FunctionalInterface
interface Vehicle
{
	void run();	
}
-------------------------------------------------------------
package com.ravi.default_method;

@FunctionalInterface
interface Vehicle
{
	void run();	
}
public class MultipleInheritance 
{
	public static void main(String[] args) 
	{
		Vehicle car = new Vehicle() 
		{		
			@Override
			public void run() 
			{
				System.out.println("Car is Running");				
			}
		};
		
		Vehicle bike = new Vehicle() 
		{		
			@Override
			public void run() 
			{
				System.out.println("Bike is Running");				
			}
		};
		
		car.run();  bike.run();
	}

}
-------------------------------------------------------------
27-12-2024
-----------
What is Lambda Expression in java ?
------------------------------------
It is a new feature introduced in java from JDK 1.8 onwards.
It is an anonymous function i.e function without any name.
In java it is used to enable functional programming.
It is used to concise our code as well as we can remove boilerplate code.
Lambda will work only with functional interface.
If the body of the Lambda Expression contains only one statement then curly braces are optional.
We can also remove the variables type while defining the Lambda Expression parameter.
If the lambda expression method contains only one parameter then we can remove () symbol also.

In lambda expression return keyword is optional but if we use return keyword then {} are compulsory.

Independently Lamda Expression is not a statement.

It requires a target variable i.e functional interface reference only.

Lamda target can't be class or abstract class, it will work with functional interface only. 
-------------------------------------------------------------
package com.ravi.lambda;

interface Vehicle
{
	void run();  //SAM [Single Abstract Method]
}

public class LambdaDemo1 {

	public static void main(String[] args) 
	{
		Vehicle car = () -> System.out.println("Car is Running");
		car.run();

		Vehicle bike = () -> System.out.println("Bike is Running");
		bike.run();
		
		
		Vehicle bus = () -> System.out.println("Bus is Running");
		bus.run();
		
	}

}
-------------------------------------------------------------
package com.ravi.lambda;

@FunctionalInterface
interface Calculate
{
	void doSum(int x , int y);
}

public class LambdaDemo2 
{
   public static void main(String[] args) 
   {
	  Calculate c1 = (c,  d)-> System.out.println("Sum is :"+(c+d));
	  c1.doSum(12, 12);
   }
}
-------------------------------------------------------------
package com.ravi.lambda;

import java.util.Scanner;

interface Length
{
	public abstract int findLength(String str);
}

public class LambdaDemo3 
{
	public static void main(String[] args) 
	{
		Length length = str -> str.length();
		
		
		Scanner sc = new Scanner(System.in);
		System.out.println("Please Enter your city Name :");
		String cityName = sc.next();
		System.out.println("Length of "+cityName+" is :"+length.findLength(cityName));
        sc.close();
	}

}
-------------------------------------------------------------
The following program explains that Lambda target must be 
functional interface only.

@FunctionalInterface
interface Drawable
{
	void draw();
}

public class Main 
{	
	public static void main(String[] args) 
	{
	  Drawable d1 =	()-> System.out.println("Drawing"); 
	  d1.draw();
	}
}
-------------------------------------------------------------
What is type parameter<T> in java ?
------------------------------------
It is a technique through which we can make our application indepenedent of data type. It is represented by <T>

In java we can pass Wrapper classes as well as User-defined classes to this type parameter(Only Reference type is reqd).

We cannot pass any primitive type to this type parameter.

package com.ravi.type_parameter;

class Box<T>
{
	private T data;

	public Box(T data) //Student data = 
	{
		super();
		this.data = data;
	}

	public T getData() 
	{
		return data;
	}	
}

public class TypeParameterDemo 
{
	public static void main(String[] args) 
	{
		Box<Integer> intType = new Box<Integer>(12);
		System.out.println("Integer Type :"+intType.getData());
		
		
		Box<Double> doubleType = new Box<Double>(23.89);
		System.out.println("Double Type :"+doubleType.getData());
		
		
		Box<Boolean> booleanType = new Box<Boolean>(true);
		System.out.println("Boolean Type :"+booleanType.getData());
		
		
		Box<Student> studentType = new Box<Student>(new Student(111));
		System.out.println("Student Type :"+studentType.getData());
	}

}

class Student
{
	private int id;

	public Student(int id)
	{
		super();
		this.id = id;
	}

	@Override
	public String toString() 
	{
		return "Student [id : " + id + "]";
	} 
	
}
-------------------------------------------------------------
28-12-2024
-----------
//Program by using Lambda to verify whether a number is even or
  odd
  
import java.util.*;

@FunctionalInterface
interface Predictable
{
	boolean predict(int x);
}

public class Main 
{	
	public static void main(String[] args) 
	{
	   Predictable p1 =  num -> 
		{
		    return num % 2 == 0;
		};
		
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter a Number :");
		int no = sc.nextInt();
		boolean isEven = p1.predict(no);
		System.out.println("Is "+no+ " even number "+isEven);
	}
}
---------------------------------------------------------------
Working with predefined functional interfaces :
------------------------------------------------------
In order to help the java programmer to write concise  java code in day to day programming java software people has provided the following predefined functional interfaces

1) Predicate<T>          boolean test(T x);
2) Consumer<T>           void accept(T x); 
3) Function<T,R>         R apply(T x);
4) Supplier<T>           T get();
5) BiPredicate<T,U>      boolean test(T x, U y);
6) BiConsumer<T, U>      void accept(T x, U y);
7) BiFunction<T,U,R>     R apply(T x, U y);
8) UnaryOperator<T>      T apply(T x)
9) BinaryOperator<T>     T apply(T x, T y)

Note :-
-------
All these predefined functional interfaces are provided as a part of java.util.function sub package.

Predicate<T> functional interface  :
-------------------------------------------
It is a predefined functional interface available in java.util.function sub package.

It contains an abstract method test() which takes type parameter <T> and returns boolean value. The main purpose of this interface to test one argument boolean expression.

@FunctionalInterface
public interface Predicate<T>   
{
  boolean test(T x);
}


Note :- Here T is a "type parameter" and it can accept any type of User defined class as well as  Wrapper class like Integer, Float, Double and so on.

We can't pass primitive type.
-----------------------------------------------------------
Programs on Predicate :
-----------------------
package com.ravi.predicate_demo;

import java.util.Scanner;
import java.util.function.Predicate;

public class PredicateDemo1
{
	public static void main(String[] args) 
	{
	  //Verify whether a person is eligible for vote or not
		
	  Predicate<Integer> p1 =  age -> 
	  {
		  return age >=18;  
	  };
	 	

	  Scanner sc = new Scanner(System.in);
	  System.out.print("Enter your Age :");
	  int age = sc.nextInt();
	  
	  boolean isEligible =  p1.test(age);
	  
	  if(isEligible)
	  {
		  System.out.println("You are eligible for Voting");
	  }
	  else
	  {
		  System.out.println("You are not eligible for Voting");
		  
	  }
	  sc.close();

	}

}
--------------------------------------------------------------
package com.ravi.predicate_demo;

import java.util.Scanner;
import java.util.function.Predicate;

public class PredicateDemo2 
{
	public static void main(String[] args)
	{
	  //Verify whether my name is Ravi or not
		
	  Predicate<String> p2 = str -> str.equalsIgnoreCase("Ravi");
	  
	  Scanner sc = new Scanner(System.in);
	  System.out.print("Enter your Name :");	 
      String name = sc.next();		

      System.out.println("Are you Ravi :? "+p2.test(name));
      sc.close();
      
      
      
	}

}
---------------------------------------------------------------
package com.ravi.predicate_demo;

import java.util.Scanner;
import java.util.function.Predicate;

public class PredicateDemo3 {

	public static void main(String[] args) 
	{
		//Verify whether my name starts with Character 'A' or not
		
		Predicate<String> p3 = str -> str.startsWith("A");
		
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter your Name :");	 
	    String name = sc.next();	
	    
	    System.out.println("The name "+name+" starts with character A ?:"+p3.test(name));
	    sc.close();

	}

}
---------------------------------------------------------------
Consumer<T> functional interface :
-----------------------------------------
It is a predefined functional interface available in java.util.function sub package.

It contains an abstract method accept() which takes T type parameter and returns nothing (void). It is used to accept the parameter value or consume the value.

@FunctionalInterface
public interface Consumer<T>
{
    void accept(T x);
}
---------------------------------------------------------------
package com.ravi.consumer_demo;

import java.util.function.Consumer;

public class ConsumerDemo {

	public static void main(String[] args) {
		Consumer<Integer> c1 = num -> System.out.println(num);
		c1.accept(12);

		Consumer<String> c2 = str -> System.out.println(str);
		c2.accept("Java");
		
		
		Consumer<Employee> c3 = emp -> System.out.println(emp);
        c3.accept(new Employee(111, "Scott"));
	}

}

class Employee 
{
	private int empId;
	private String empName;

	public Employee(int empId, String empName) 
	{
		super();
		this.empId = empId;
		this.empName = empName;
	}

	@Override
	public String toString()
	{
		return "Employee [empId=" + empId + ", empName=" + empName + "]";
	}

}
---------------------------------------------------------------
Function<T,R> functional interface :
-----------------------------------------
Type Parameters:
T - the type of the input to the function.
R - the type of the result of the function.

It is a predefined functional interface available in java.util.function sub package.

It provides an abstract method apply that accepts one argument(T) and produces a result(R).

Note :- The type of T(input) and the type of R(Result) both will be decided by the user.

@FunctionalInterface
public interface Function<T,R>
{
   public abstract R apply(T x);        
}
--------------------------------------------------------------
package com.ravi.function;

import java.util.function.Function;

public class FunctionDemo1 {

	public static void main(String[] args)
	{
	  //Find the cube of a number
	  Function<Integer,Integer> fn1 = num -> num*num*num;
	  System.out.println(fn1.apply(5));
	}

}
--------------------------------------------------------------
package com.ravi.function;

import java.util.Scanner;
import java.util.function.Function;

public class FunctionDemo2 {

	public static void main(String[] args) 
	{
		// I want to find the length of the given city
		
		Function<String,Integer> fn2 = city -> city.length();
		
		Scanner sc = new Scanner(System.in);
		System.out.print("Enter your City Name :");
		String city = sc.next();
		
		System.out.println("The length of "+city+" is :"+fn2.apply(city));

       	
		sc.close();
	}

}
---------------------------------------------------------------
30-12-2024
----------
package com.ravi.interface_demo;

import java.sql.SQLSyntaxErrorException;
import java.util.Scanner;
import java.util.function.Function;

public class FunctionDemo3 {

	public static void main(String[] args) 
	{
		//Verify whether my name starts with "Ravi" or not
		Function<String,Boolean> fn3 = str -> str.equals("Ravi");

		Scanner sc = new Scanner(System.in);
		System.out.print("Enter your Name :");	 
	    String name = sc.next();
	    
	    Boolean isRavi = fn3.apply(name);
	    
	    if(isRavi)
	    {
	    	System.out.println("Yes He is Ravi");
	    }
	    else
	    {
	    	System.err.println("No He is not Ravi");
	    }
	    sc.close();
	    
	}

}                     
---------------------------------------------------------------
Supplier<T> prdefined functional interface :
--------------------------------------------
It is a predefined functional interface available in java.util.function sub package. 

It provides an abstract method get() which does not take any argument but produces/supply/return a value of type T.

@FunctionalInterface
public interface Supplier<T>
{
   T get();
}
--------------------------------------------------------------
//Psssing String to the Supplier

package com.ravi.interface_demo;

import java.util.function.Supplier;

public class SupplierDemo1 
{
	public static void main(String[] args) 
	{
		Supplier<String> s1 = () -> 12 + 90+ " " + 34 ;		
		String data = s1.get();
		System.out.println(data);
	}

}
---------------------------------------------------------------
//Passing an Employee to the Supplier
package com.ravi.interface_demo;

import java.util.Objects;
import java.util.function.Supplier;

class Employee
{
	private Integer employeeId;
	private String employeeName;
	
	public Employee(Integer employeeId, String employeeName)
	{
		super();
		this.employeeId = employeeId;
		this.employeeName = employeeName;
	}

	@Override
	public String toString() 
	{
		return "Employee [employeeId=" + employeeId + ", employeeName=" + employeeName + "]";
	}

	public Integer getEmployeeId() {
		return employeeId;
	}

	public void setEmployeeId(Integer employeeId) {
		this.employeeId = employeeId;
	}

	public String getEmployeeName() {
		return employeeName;
	}

	public void setEmployeeName(String employeeName) {
		this.employeeName = employeeName;
	}

	@Override
	public int hashCode() 
	{
		return Objects.hash(employeeId, employeeName);
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Employee other = (Employee) obj;
		return Objects.equals(employeeId, other.employeeId) && Objects.equals(employeeName, other.employeeName);
	}
			
}

public class SupplierDemo2 
{
	public static void main(String[] args) 
	{
        Supplier<Employee> s2 = () -> 
        {
        	Employee e1 = new Employee(111, "Scott");
        	return e1;
        };
        
        System.out.println(s2.get());

	}

}
---------------------------------------------------------------
Object class equals(Object obj) :
----------------------------------
In java.lang.Object class, There is a predefined non static method called equals(Object obj) which is used to compere two objects by using == operator i.e memory reference. This method 
behavior is same as == operator behavior.

If we want to compare two objects based on the content but not by using == operator then we should override this equals(Object obj) from Object class.

Eclipse IDE auto generate hashCode() and equals(Object obj) method, both are overridden method from the Object class as 
shown below.

EqualsObjectComparison.java
-----------------------------
package com.ravi.interface_demo;

import java.util.Objects;

class Student
{
	private Integer studentId;
	private String studentName;
	
	public Student(Integer studentId, String studentName)
	{
		super();
		this.studentId = studentId;
		this.studentName = studentName;
	}

	public Integer getStudentId() {
		return studentId;
	}

	public void setStudentId(Integer studentId) {
		this.studentId = studentId;
	}

	public String getStudentName() {
		return studentName;
	}

	public void setStudentName(String studentName) {
		this.studentName = studentName;
	}

	@Override
	public String toString() {
		return "Student [studentId=" + studentId + ", studentName=" + studentName + "]";
	}

	//generate hashCode() and equals() method for content comparison
	@Override
	public int hashCode() {
		return Objects.hash(studentId, studentName);
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Student other = (Student) obj;
		return Objects.equals(studentId, other.studentId) && Objects.equals(studentName, other.studentName);
	}
	
		
}

public class EqualsObjectComparison {

	public static void main(String[] args) 
	{
		Student s1 = new Student(111, "Raj");
		Student s2 = new Student(111, "Raj");
		
		System.out.println(s1==s2); //false
		
		System.out.println(s1.equals(s2)); //true (Overridden Method)

	}

}
---------------------------------------------------------------
Record class in java :
-----------------------
public abstract class Record extends Object.

record Student(){} //final class Student extends Record [Compiler generated code]

It is a new feature introduced from java 17.(In java 14 preview version)

As we know only objects are moving in the network from one place to another place so we need to write BLC class with nessacery requirements to make BLC class as a Data carrier class.

Records are immutable data carrier so, now with the help of record we can send our immutable data (final data) from one application to another application.

It is also known as DTO (Data transfer object) OR POJO (Plain Old Java Object) classes.

It is mainly used to concise our code as well as remove the boiler plate code.

In record, automatically constructor will be generated which is known as canonical constructor and the variables which are known as components are by default final.

In order to validate the outer world data, we can write our own constructor which is known as compact constructor.

Record will automatically generate the implemenation of toString(), equals(Object obj) and hashCode() method.

We can define static and non static method as well as static variable  and static block inside the record. We cannot define instance variable and instance block inside the record.

We cann't extend or inherit records because by default every record is implicilty final and It is extending from java.lang.Reocrd class, which is an abstract class.

We can implement an interface by using record.

We don't have setter facility in record because by default components are final.
---------------------------------------------------------------

3 files :
----------
ProductClass.java
------------------
package com.ravi.record;

import java.util.Objects;

public class ProductClass 
{
	private Integer productId;
	private String productName;

	public ProductClass(Integer productId, String productName)
	{
		super();
		this.productId = productId;
		this.productName = productName;
	}

	@Override
	public String toString() {
		return "ProductClass [productId=" + productId + ", productName=" + productName + "]";
	}

	public Integer getProductId() {
		return productId;
	}

	public void setProductId(Integer productId) {
		this.productId = productId;
	}

	public String getProductName() {
		return productName;
	}

	public void setProductName(String productName) {
		this.productName = productName;
	}

	@Override
	public int hashCode() {
		return Objects.hash(productId, productName);
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		ProductClass other = (ProductClass) obj;
		return Objects.equals(productId, other.productId) && Objects.equals(productName, other.productName);
	}
}

ProductRecord.java
-------------------
package com.ravi.record;

public record ProductRecord(Integer productId, String productName) 
{
	//Compact Constructor
	public ProductRecord
	{
		if(productId<=0)
		{
			System.err.println("Id is Invalid");
		}		
	}

	
}

ClassAndRecordComparison.java
--------------------------------

package com.ravi.record;

public class ClassAndRecordComparison {

	public static void main(String[] args) 
	{
		ProductClass pc1 = new ProductClass(111, "Camra");
		System.out.println(pc1);
		ProductClass pc2 = new ProductClass(111, "Camra");
		System.out.println(pc1.equals(pc2));
		System.out.println(pc1.getProductName());
		
		System.out.println("..............");
		
        ProductRecord pr1 = new ProductRecord(-999, "Java Book");
        System.out.println(pr1);
        ProductRecord pr2 = new ProductRecord(999, "Java Book");
        System.out.println(pr1.equals(pr2));
        System.out.println(pr1.productName());
		
	}

}
--------------------------------------------------------------
//supply manager object by using Supplier

package com.ravi.interface_demo;

import java.util.function.Supplier;

record Manager(Integer managerId, String managerName)
{
	
}

public class SupplierDemo3 
{
   public static void main(String[] args) 
   {
	 Supplier<Manager> s3 = () -> new Manager(111, "John");
	 System.out.println(s3.get());
   }
}
---------------------------------------------------------------
31-12-2024
----------
Can we create our own functional interface with Type parameter:
---------------------------------------------------------------
Yes, We can create our own functional interface with type parameter as shown below.

package com.nit.custom_functional_interface;

@FunctionalInterface
interface TriFunction<T,U,V,R>
{
    public abstract R apply(T a, U b, V c);	
}

public class CustomFunctionalInterface {

	public static void main(String[] args) 
	{
		TriFunction<Integer, Integer, Integer, String> tn = (x,y,z) ->  ""+ x + y + z;
		
		System.out.println(tn.apply(100, 200, 300));
				
	}

}
---------------------------------------------------------------

BiPredicate<T,U> functional interface :
-----------------------------------
It is a predefined functional interface available in java.util.function sub package.

It is a functional interface in Java that represents a predicate (a boolean-valued function) OF TWO ARGUMENTS.

The BiPredicate interface has method named test, which takes two parameters and returns a boolean value, basically this BiPredicate is same with the Predicate, instead, it takes 2 arguments for the metod test.


@FunctionalInterface
public interface BiPredicate<T, U> 
{
    boolean test(T t, U u);
}

Type Parameters:

T - the type of the first argument to the predicate
U - the type of the second argument the predicate
Note : return type is boolean.

--------------------------------------------------------------
import java.util.function.*;
public class Lambda11 
{
	public static void main(String[] args)   
    {
        BiPredicate<String, Integer> filter = (x, y) -> 
		{
            return x.length() == y;  
        };

        boolean result = filter.test("Ravi", 4);
        System.out.println(result);  

        result = filter.test("Hyderabad", 10);
        System.out.println(result);
	}
}
--------------------------------------------------------------
import java.util.function.BiPredicate;

public class Lambda12
{
  public static void main(String[] args) 
  {
    // BiPredicate to check if the sum of two integers is even
    BiPredicate<Integer, Integer> isSumEven = (a, b) -> (a + b) % 2 == 0;

        System.out.println(isSumEven.test(2, 3));    
        System.out.println(isSumEven.test(5, 7));   
    }
}
--------------------------------------------------------------
BiConsumer<T, U> functional interface :
---------------------------------------
It is a predefined functional interface available in java.util.function sub package.

It is a functional interface in Java that represents an operation that accepts two input arguments and returns no result.

It takes a method named accept, which takes two parameters and performs an action without returning any result.

@FunctionalInterface
public interface BiConsumer<T, U> 
{
    void accept(T t, U u);
}
--------------------------------------------------------------
import java.util.function.BiConsumer;

public class Lambda13
{
   public static void main(String[] args) 
   {
     BiConsumer<Integer, String> updateVariables =  (num, str) -> 
		 {
            num = num * 2;
            str = str.toUpperCase();
            System.out.println("Updated values: " + num + ", " + str);
        };

        
        int number = 15;
        String text = "nit";

        updateVariables.accept(number, text);

        // Values after the update (note that the original values are unchanged)
        System.out.println("Original values: " + number + ", " + text);
    }
}
--------------------------------------------------------------
BiFunction<T, U, R> Functional interface :   
---------------------------------
It is a predefined functional interface available in java.util.function sub package.

It is a functional interface in Java that represents a function that accepts two arguments and produces a result R.

The BiFunction interface has a method named apply that takes two arguments and returns a result of type R.

@FunctionalInterface
public interface BiFunction<T, U, R> 
{
    R apply(T t, U u);
}
--------------------------------------------------------------
import java.util.function.BiFunction;

public class Lambda14
{
  public static void main(String[] args) 
  {
        // BiFunction to concatenate two strings
    BiFunction<String, String, String> concatenateStrings = (str1, str2) -> str1 + str2;

        String result = concatenateStrings.apply("Hello", " Java");
        System.out.println(result);  


      // BiFunction to find the length two strings
    BiFunction<String, String, Integer> concatenateLength = (str1, str2) -> str1.length() + str2.length();

        Integer result1 = concatenateLength.apply("Hello", "Java");
        System.out.println(result1);  


  }
}
--------------------------------------------------------------
UnaryOperator<T> :
------------------
It is a predefined functional interface available in java.util.function sub package.

It is a functional interface in Java that represents an operation on a single operand that produces a result of the same type as its operand. This is a specialization of Function for the case where the operand and result are of the same type.

It has a single type parameter, T, which represents both the operand type and the result type.

@FunctionalInterface
public interface UnaryOperator<T> extends Function<T,T>
{
  public abstract T apply(T x);
}
--------------------------------------------------------------
import java.util.function.*;
public class Lambda15  
{
	public static void main(String[] args) 
	{
		UnaryOperator<Integer> square = x -> x*x;
        System.out.println(square.apply(5));

		UnaryOperator<String> concat = str -> 
         str.concat("base");
		 System.out.println(concat.apply("Data"));
	}
}
--------------------------------------------------------------
BinaryOperator<T>
-----------------
It is a predefined functional interface available in java.util.function sub package.

It is a functional interface in Java that represents an operation upon two operands of the same type, producing a result of the same type as the operands. 

This is a specialization of BiFunction for the case where the operands and the result are all of the same type.

It has two parameters of same type, T, which represents both the operand types and the result type.

@FunctionalInterface
public interface BinaryOperator<T> extends BiFunction<T,T,T>
{
  public abstract T apply(T x, T y);
}




import java.util.function.*;
public class Lambda16  
{
	public static void main(String[] args) 
	{
		BinaryOperator<Integer> add = (a, b) -> a + b;
        System.out.println(add.apply(3, 5));  
	}
}
============================================================
Can we use all different types of variables in the lambda body ?
-----------------------------------------------------------------
Yes, we can use all different types of variables like static field, non static field and local variable in the lambda body.

The local variable must be final or effectively final otherwise we will get compilation error.


@FunctionalInterface
interface Drawable
{
	void draw();
}

public class Main 
{	
	
	public static void main(String[] args) 
	{
		String shapeType = "Rectangle";  //local variable
		
		// shapeType = "Square";  //[It is Invalid]
		
	    Drawable d1 = ()->
		{
		   System.out.println("Drawing : "+shapeType);
		};
		
		d1.draw();
	}
}
==================================================================
01-01-2025
----------
Does an interface extend a class :
----------------------------------
No, an interface can't extend a class, An interface can extend another interface.

In order to support upcasting concept in java, all the public and non final methods of Object class are re-declared inside an interface as an abstract method if that interface does not extend from another interface.


InterfaceMemberDemo1.java
-----------------------------
package com.ravi.interface_member;

interface Printable
{
	//public String toString();   //added by compiler
	//public int hashCode();   //added by compiler
	//public boolean equals(Object obj);   //added by compiler
}
class Print extends Object implements Printable
{
	/*public String toString()
	 * {
	 *     //Inherited from Object class
	 * }
	 * 
	 * public int hashCode()
	 * {
	 * //Inherited from Object class
	 * }
	 * 
	 * public boolean equals(Object obj)
	 * {
	 *    //Inherited from Object class
	 * }
	 * 
	 * 
	 */
}

public class InterfaceMemberDemo1 
{
	public static void main(String[] args) 
	{
		Printable p = new Print();
		p.toString()
		p.equals(null);
		p.hashCode();

	}

}


Note : java compiler will not add any final method of Object class inside an interface because abstract method we can't declare as final.
---------------------------------------------------------------
package com.ravi.interface_member;

@FunctionalInterface
interface Drawable
{
	void draw();
	public String toString();
	public int hashCode();
	public boolean equals(Object obj);	
}

public class InterfaceMemberDemo2 
{
	public static void main(String[] args) 
	{
		

	}

}
-----------------------------------------------------------------
Can a default method of interface override/write the public method of Object class with same signature and return type.

No, a default method of an interface can't override/write the public method of Object class due to the following two reasons :
(01-JAN)

1) Ambiguity issue : Object class already contain the method which
                     interface wants to define as a default method hence it will provide Ambiguity to sub class
		     (Implementer class)


2) Priority : Concrete method is having more priority than 
              default method that means Object class method is having more priority than default method of interface so compiler will not allow to write any default method as a public method of Object class.
               

package com.ravi.interface_member;

interface Moveable
{
	default String toString() //error becoz it is Object class {
		return "NIT";
	}
}



public class ELC
{
	public static void main(String[] args) 
	{
		// TODO Auto-generated method stub

	}

}
==================================================================
Interface from JAVA 9V
----------------------
We can write private static and private non static (not public)
methods inside an interface from java 9 version.

The main purpose of providing these two methods inside an 
interface are as follows :

1) Code Reusability 
--------------------
If two or more than two default methods want to share a common code (Helper Method code) then we can write these common code in private methods so it will enhance code reusability.

2) Hide the Logic from Outer World 
----------------------------------
By writing these code in private static and private non static methods the actual logic is not visible to the outer world so, It is way to make our interface as a fully abstract class so 100% abstraction is possible.

Note : By default interface is not Fully abstract but we can make it full abstract from java 9V by writing the logic inside private method.

Note : from default method we can call private static as well as private non static methods but from public static method of interface we can call only private static method.
-----------------------------------------------------------------
package com.ravi.interface_member;

interface Moveable
{
	void move();  //JDK 1.0
	
	default void m1() //JDK 8V
	{	
		m3();
		m4();
	}
	
	static void m2() //JDK 8V
	{	
		m4();
	}
	
	private void m3() //JDK 9 [private non static method]
	{
		System.out.println("Private non static method of interface");
	}
	
	private static void m4() //JDK 9 [private static method]
	{	
		System.out.println("Private static method of interface");
	}	
}
class Move implements Moveable
{
	@Override
	public void move() 
	{
	 System.out.println("It is moving");		
	}	
}


public class ELC
{
	public static void main(String[] args) 
	{
		Moveable m = new Move();
		m.move();
		m.m1();
		Moveable.m2();

	}

}
-----------------------------------------------------------------
What is a Marker interface ?
-----------------------------
If an interface does not contain any field or methods, Basically an empty interface is known as Marker interface.

Example :
-----------
interface Drawable   //Marker interface
{
   //Empty interface
}

In java, we have few predefined marker interfaces are available which are as follows :

   1) java.lang.Cloneable
   2) java.io.Serializable
   3) java.util.RandomAccess

**The main purpose of marker interface to provide additional information to the JVM reagarding the Object like Object is Serializable, Cloneable OR Randomly Accessible.  
------------------------------------------------------------------
 ****What is difference between abstract class and interface ?
----------------------------------------------------------------
The following are the differences between abstract class and interface.

1) An abstract class can contain instance variables but interface variables are by default public , static and final (no instance variable).

2) An abstract class can have state (properties) of an object but interface can't have state of an object.

3) An abstract class can contain constructor but inside an interface we can't define constructor.

4) An abstract class can contain instance and static blocks but inside an interface we can't define any blocks.

5) Abstract class can't refer Lambda expression but using Functional interface we can refer Lambda Expression.	

6) By using abstract class multiple inheritance is not possible but by using interface we can achieve multiple inheritance.

--------------OOPs Completed.................................

Offline :  (38 - 40)
---------
1) Exception Handling
2) Array and String (Logical Session)
3) Multithreading
4) Collections Framework (Generic, Concurrent Collection, STREAM API)

Online : 
---------
Inner class
Object class and its Method
File handling and Input and Output in java

==============================================================
02-01-2025
----------
Exception Handling :
--------------------
An exception is an abnormal situation OR un-expected situation in a normal execution flow.

Due to an exception, the execution of the program will be disturbed first and then terminated permanently.

Exception always encounter at runtime only.

Exception encounter due to the following reasons :

  1) The Wrong input given by the user.
  2) Due to dependency, When one part of the program is dependent to another part to complete the task then there might be a chance of getting an exception. 

Different Criteria for Exception generation :
----------------------------------------------
1) java.lang.ArithmeticException :
----------------------------------
Whenever we divide a number by 0 (int value) then we will get an exception i.e java.lang.ArithmeticException 

int x = 100;
int y = 0;
int z = x /y;  //java.lang.ArithmeticException

2) java.lang.ArrayIndexOutOfBoundsException
-------------------------------------------
Whenever we try to access the index of the array where element is not available then we will get java.lang.ArrayIndexOutOfBoundsException

int []arr = {10,20,30};
System.out.println(arr[3]);

3) java.lang.NegativeArraySizeException 
----------------------------------------
The size of an array must be positive integer, if we pass -ve size then we will get an exception java.lang.NegativeArraySizeException 

int [] arr = new int[-10];

4) java.lang.NumberFormatException
----------------------------------
If we try to convert any String value into corresponding primitive type OR Warpper type and if the String data is not available in numeric format then we will get an exception java.lang.NumberFormatException

 String str = "h";
 int x = Integer.parseInt(str); 
 System.out.println(x+2);	  
		 
		
String s1 = "NIT";		
Integer y = Integer.valueOf(s1);
System.out.println(y+2);


5) java.lang.NullPointerException :
------------------------------------
If a reference variable is pointing to null and if we try to invoke any non static method or field by using reference variable then we will get java.lang.NullPointerException

Case 1 :
--------
String str = null;
System.out.println(str.length());  //Exception

Case 2 :
--------
String str = "null";
System.out.println(str.length()+" : "+str.toUpperCase());

Case 3 :
--------
Scanner sc = new Scanner(System.in);
System.out.println("Enter your name :");
String name = sc.nextLine();  //"null"
		  
System.out.println(name.length()+" : "+name.toUpperCase());

6) java.util.InputMismatchException :
--------------------------------------
If we try to read the data by using Scanner class method and if the data is not in a proper format/input then we will get exception java.util.InputMismatchException


Scanner sc = new Scanner(System.in);
System.out.println("Enter your Salary :");
double salary = sc.nextDouble(); //Eleven [Exception]
System.out.println("Your Salary is :"+salary);

7) java.lang.StringIndexOutOfBoundsException :
-----------------------------------------------
If we try to access the index of String (character Array) which index is not available then we will get java.lang.StringIndexOutOfBoundsException

String str = "hyderabad";
System.out.println(str.substring(-2,5));


Note : ArrayIndexOutOfBoundsException class StringIndexOutOfBoundsException class both are sub class of java.lang.IndexOutOfBoundsException.
--------------------------------------------------------------
06-01-2025
-----------
Exception Hierarchy :
----------------------
Hierarchy is available in paint diagram[06th-JAN-24]

Note :- As a developer we are responsibe to handle the Exception. System admin is responsibe to handle the error because we cannot recover from error.
--------------------------------------------------------------
WAP to show that Exception is the super class of all types of 
Exception whether it is checked Or unchecked

package com.ravi.excp;

public class ExceptionSuper { 

	public static void main(String[] args) 
	{
		Exception e1 = new ArithmeticException("Ravi divides by zero");
		System.out.println(e1.toString());  //java.lang.AE : Ravi divides by zero
		
		
		Exception e2 = new InterruptedException();
		System.out.println(e2.toString()); //java.lang.IE

	}

}
-------------------------------------------------------------
Exception format :
------------------
The java software people has provided the format of exception so whenever we print exception object by using toString() then the format is 

Fully Qualified Name : errorMesage

Package Name + Class Name : errorMessage
------------------------------------------------------------
WAP that desribes, whenever an exception is encounter in the 
program then our program will be terminated abnormally (halt in the middle)

package com.ravi.excp;

import java.util.Scanner;

public class AbnormalTermination {

	public static void main(String[] args) 
	{
       System.out.println("Main method Started!!!");
		
		Scanner sc = new Scanner(System.in);
		
		System.out.print("Enter the value of x :");
		int x = sc.nextInt();
		
		System.out.print("Enter the value of y :");
		int y = sc.nextInt();
		
		int result = x/y;
		
		System.out.println("Result is :"+result);
		
		System.out.println("Main method Completed!!!");
		sc.close();

	}

}

Note :

In the above program, If we put the value of y as 0 then program will be terminated in the middle, IT IS CALLED ABNORMAL TERMINATION.
Actually JVM has a default exception handler which is responsible to handle the execption and terminate the program in the middle abnormaly.
--------------------------------------------------------------
In order to handle the exception and to work with exception. java software people has provided the following keywords :

1) try block
2) catch block
3) finally block (try with resourses)
4) throw
5) throws

-------------------------------------------------------------
07-01-2025
-----------
Key points to remember :
--------------------------------
-> With try block we can write either catch block or finally block or both.
-> In between try and catch we can't write any kind of statement.
-> try block will trace our program line by line.
-> If we have any exception inside the try block,With the help of JVM, try block will automatically  create the appropriate Exception object and then throw the Exception Object to the nearest catch block.
-> In the try block whenever we get an exception the control will directly jump to the nearest catch block so the remaining code of try block will not be executed.
 -> catch block is responsible to handle the exception.
 -> catch block will only execute if there is an exception inside try block.
 --------------------------------------------------------------
try block :
-----------
Whenever our statement is error suspecting statement OR Risky statement then we should write that statement inside the try block.

try block must be followed either by catch block or finally block or both.

*try block is responsible to trace our code line by line, if any execption is encountered then with the help of JVM, TRY BLOCK WILL CREATE APPROPRIATE EXECPTION OBJECT, AND THROW THIS EXCEPTION OBJECT to the nearest catch block.

After the execption in the try block, the remaining code of try block will not be executed because control will directly transfer to the catch block.

In between try and catch block we cannot write any kind of statement.

catch block :
--------------
The main purpose of catch block to handle the exception which is thrown by try block.

catch block will only executed if there is an exception in the try block.
-------------------------------------------------------------
package com.ravi.basic;

import java.util.Scanner;

public class TryDemo 
{
	public static void main(String[] args)  
	{		
		   System.out.println("Main method started....");	
		   Scanner sc = new Scanner(System.in);
		   
		   try
		   {
			   System.out.print("Enter the value of x :");
			   int x = sc.nextInt();
			   

			   System.out.print("Enter the value of y :");
			   int y = sc.nextInt();
			   
			   
			   int result = x /y;
			   System.out.println("Result is :"+result);
			   System.out.println("End of try block");

		   }
		   catch(Exception e)
		   {
			   System.out.println("Inside Catch");
			   System.err.println(e);
		   }
		   System.out.println("Main method ended....");
		   sc.close();
	}
}


In the above program if we put the value of y as 0 but still program will be executed normally because we have used try-catch so it is a 
normal termination even we have an exception in the program.
-------------------------------------------------------------
package com.ravi.basic;

public class ThrowException 
{
	public static void main(String[] args) 
	{
		try
		{	
		  //System.out.println(10/0);
		            //OR
	     throw new ArithmeticException("Ravi is dividing a number by zero");			
		}
		
		catch(Exception e)
		{
			System.out.println("Catch Block");
			System.err.println(e);
		}
		System.out.println("Main completed!!!");
	}

}

From the above program it is clear that try block implicitly creating the exception object with the help of JVM and throwing the execption object to the nearest catch block.

We can also create the exception object manually and can throw the exception object to the catch block.

After throw keyword we can't write any kind of statement, It 
will become un-reachable code. 
--------------------------------------------------------------

class Foo
{
	
}

public class ExceptionDemo 
{
	public static void main(String[] args) 
	{
		try
		{
			throw new Foo();
		}
		catch (Exception e)
		{
			System.out.println(e);
		}
	}
}

Note : We will get compiletion error because Foo class does not belong to exception hierarchy so it is not a throwable object.
--------------------------------------------------------------
Note : The main purpose of exception handling to provide user-friendly message so client can enjoy the services of software/websites.

Exception handlinag = No Abnormal Termination + User-friendly message on wrong input given by the client.



package com.ravi.basic;

import java.util.Scanner;

public class CustomerDemo 
{
	public static void main(String[] args) 
	{
		System.out.println("Hello Client, Welcome to my application :");
		
		Scanner sc = new Scanner(System.in);
		try
		  {
			   System.out.print("Enter the value of x :");
			   int x = sc.nextInt();
			   

			   System.out.print("Enter the value of y :");
			   int y = sc.nextInt();
			   
			   
			   int result = x /y;
			   System.out.println("Result is :"+result);		 

		   }
		   catch(Exception e)
		   {
			    System.err.println("Please don't put zero here");
		   }

		   System.out.println("Thank you for Visiting my application !!");
		   sc.close();
	}

}
-------------------------------------------------------------
Throwable class Method to print Exception :
--------------------------------------------
Throwable class has provided the following three methods :

1) public String getMessage() :- It will provide only error message.

2) public void printStackTrace() :-  It will provide the complete details regarding exception like exception class name, exception error message, exception class location, exception method name and exception line number.

3) public String toString() :- It will convert the exception into String representation.
-------------------------------------------------------------
package com.ravi.basic;

public class PrintStackTrace 
{
	public static void main(String[] args) 
	{
		System.out.println("Main Method started");
		
		try
		{
			String str = null;
			System.out.println(str.toUpperCase());			
		}
		catch(Exception e)
		{
			System.out.println("Ref variable is pointing to null");
			System.out.println("...............");
			System.out.println(e.getMessage());
			System.out.println("...............");
			System.out.println(e.toString());
			System.out.println("...............");
			e.printStackTrace();				
		}	
		
		System.out.println("Main Method ended");
	}

}
--------------------------------------------------------------
Working with Specific Exception :
---------------------------------
While working with exception, in the corresponding catch block we can take Exception (super class) which can handle any type of Exception.

On the other hand we can also take specific type of exception (ArithmetiException, InputMismatchException and so on) which will handle only one type i.e specific type of exception.

package com.ravi.basic;

public class PrintStackTrace 
{
	public static void main(String[] args) 
	{
		System.out.println("Main Method started");
		
		try
		{
			String str = null;
			System.out.println(str.toUpperCase());			
		}
		catch(NullPointerException e)
		{
			System.out.println("Ref variable is pointing to null");
			System.out.println("...............");
			System.out.println(e.getMessage());
			System.out.println("...............");
			System.out.println(e.toString());
			System.out.println("...............");
			e.printStackTrace();				
		}	
		
		System.out.println("Main Method ended");
	}

}
-------------------------------------------------------------

public class ExceptionDemo 
{
	public static void main(String[] args) 
	{
		try
		{
			System.out.println("Inside Try!!!");
			throw new OutOfMemoryError();
		}
		catch (Exception e)
		{
			System.out.println("Inside Catch!!!");
			System.out.println(e);
		}
	}
}

Note : OutOfMemoryError can't be handled by Exception class.We need to write Error OR Throwable class.
--------------------------------------------------------------
Working with Infinity and Not a number(NaN) :
---------------------------------------------
10/0    -> Infinity (Java.lang.ArithmeticException)
10/0.0  -> Infinity  (POSITIVE_INFINITY)

0/0     -> Undefined (Java.lang.ArithmeticException)
0/0.0   -> Undefined  (NaN)

While dividing a number with Integral literal in both the cases i.e Infinity (10/0) and Undefined (0/0) we will get java.lang.ArithmeticException because java software people has not provided any final, static variable support to deal with Infinity and Undefined.

On the other hand while dividing a number with with floating point literal in the both cases i.e Infinity (10/0.0) and Undefined (0/0.0) we have final, static variable support so the program will not be terminated in the middle which are as follows

10/0.0 = POSITIVE_INFINITY
-10/0.0 = NEGATIVE_INFINITY
0/0.0 = NaN

java.lang.Float and java.lang.Double classes are provided the support for these final and static variable, the same OR same type of variables are not available in Integeral Literal classes.

package com.ravi.basic;

public class InfinityFloatingPoint 
{	
	public static void main(String[] args) 
	{
	   System.out.println("Main Started");
	   System.out.println(10/0.0); 
	   System.out.println(-10/0.0); 
	   System.out.println(0/0.0);  
	   System.out.println(10/0); 
	   System.out.println("Main Ended");
	}

}
--------------------------------------------------------------
08-01-2025
-----------
Working with multiple try catch :
---------------------------------
According to our application requirement we can provide multiple try-catch in my application to work with multiple execptions.

package com.ravi.basic;
public class MultipleTryCatch 
{
	public static void main(String[] args) 
	{
	  System.out.println("Main method started!!!!");
	  
	  try
	  {
		  int arr[] = {10,20,30};
		  System.out.println(arr[3]);
	  }
	  catch(ArrayIndexOutOfBoundsException e)
	  {
		  System.err.println("Array index is out of limit!!!");
	  }
	  
	  try
	  {
		 String str = null;
		 System.out.println(str.length());
	  }
	  catch(NullPointerException e)
	  {
		  System.err.println("ref variable is pointing to null");
	  } 
	  
	  System.out.println("Main method ended!!!!");	
	}
}

Note : In the above program the drawback is, Client will get all the error messages at once which is not a recommended way.

In order to avoid this drawback we introduced multiple catch blocks with single try.
--------------------------------------------------------------
try with multiple catch blocks :
---------------------------------
According to industry standard we should write try with multiple catch blocks so we can provide proper information for each and every exception to the end user.

While working with multiple catch block always the super class catch block must be last catch block.

From java 1.7v this multiple exceptions we can write in a single catch block by using | symbol.

If try block is having more than one exception then always try block will entertain only first exception because control will transfer to the nearest catch block.
--------------------------------------------------------------
package com.ravi.basic;
public class MultyCatch 
{
	public static void main(String[] args) 
	{
		System.out.println("Main Started...");		
		try
		{
			int c = 10/2;			
			System.out.println("c value is :"+c);	
			
			int []x = {12,78,56};
			System.out.println(x[4]);			
		}
				
		catch(ArrayIndexOutOfBoundsException e1)
		{
			System.err.println("Array is out of limit...");
		}
		catch(ArithmeticException e1)
		{
			System.err.println("Divide By zero problem...");
		}
		catch(Exception e1)
		{
			System.out.println("General");
		}								
		System.out.println("Main Ended...");
	}
}
-------------------------------------------------------------
package com.ravi.basic;

public class MultyCatch1 
{
	public static void main(String[] args) 
	{
		System.out.println("Main method started!!!");
		try
		{
		   String str1 = "null";
		   System.out.println(str1.toUpperCase()); //NULL
		   
		   String str2 = "Ravi";
		   int x = Integer.parseInt(str2);
		   System.out.println("Number is :"+x);
		}
		catch(NumberFormatException  | NullPointerException  e)
		{
		  if(e instanceof NumberFormatException)
		  {
			  System.err.println("Number is not in a proper format");
		  }
		  else if(e instanceof NullPointerException)
		  {
			  System.err.println("ref variable is pointing to null");
		  }
		}

		System.out.println("Main method ended!!");
	}

}
--------------------------------------------------------------
finally is a block which is meant for Resource handling purposes.

According to Software Engineering, the resources are memory creation, buffer creation, opening of a database, working with files, working with network resourses and so on hence these resourses must be closed properly.

Whenever the control will enter inside the try block always the finally block would be executed.

We should write all the closing statements inside the finally block because irrespective of exception finally block will be executed every time.

If we use the combination of try and finally then only the resources will be handled but not the execption, on the other hand if we use try-catch and finally then execption and resourses both will be handled.
--------------------------------------------------------------
package com.ravi.basic;

public class FinallyBlock 
{
	public static void main(String[] args) 
	{
		System.out.println("Main method started");
		try
		{		
			
			System.out.println(10/0);
		}		
		finally
		{	
			System.out.println("Finally Block");
		}
		
		System.out.println("Main method ended");
	}

}


Note :- In the above program finally block will be executed, even we have an exception in the try block but here only the resourses will be handled but not the exception.
--------------------------------------------------------------
package com.ravi.basic;

public class FinallyWithCatch 
{
	public static void main(String[] args) 
	{		
		try
		{			
		    int []x = new int[-2];	
		    x[0] = 12;
		    x[1] = 15;
		    System.out.println(x[0]+" : "+x[1]);	   
		   
		}
		catch(NegativeArraySizeException e)
		{		
			System.err.println("Array Size is in negative value...");			 
		}
		finally
		{
		   System.out.println("Resources will be handled here!!");		   
		}
		System.out.println("Main method ended!!!");
	}
}


In the above program exception and resourses both are handled because we have a combination of try-catch and finally.

Note :- In the try block if we write System.exit(0) and if this line is executed then finally block will not be executed.
--------------------------------------------------------------
Limitation of finally block :
------------------------------

The following are the limitation of finally block :

1) In order to close the resourses, user is responsible to write finally block manually.

2) Due to finally block the length of the program will be increased.

3) In order to close the resourses inside the finally block, we need  to declare the resourses outside of try block.

package com.ravi.basic;

import java.util.InputMismatchException;
import java.util.Scanner;

public class FinallyLimitation 
{	
	public static void main(String[] args) 
	{
		Scanner sc = null;
        try
        {
        	sc = new Scanner(System.in);
        	System.out.print("Enter your Age :");
        	int age = sc.nextInt();
        	System.out.println("Age is :"+age);
        	
        }
        catch(InputMismatchException e)
        {
        	System.err.println("Input mismatched..");
        }
		finally
		{
			System.out.println("Inside finally");
			sc.close();
		}
	}
}


--------------------------------------------------------------
09-01-2025
----------
try with Resourses (Automatic Closing Facility)
------------------------------------------------
To avoid all the limitation of finally block, Java software people introduced a separate concept i.e try with resources from java 7 onwards.

Case 1:
-------
try(resource1 ; resource2)  //Only the resources will be handled
{
}

Case 2 :
----------
//Resources and Exception both will be  handled
try(resource1 ; resource2) 
{                          
}
catch(Exception e)
{
}

Case 3 :
----------
try with resourses enhancement from java 9v

Resourse r1 = new Resourse();
Resourse r2 = new Resourse();

try(r1; r2)
{
}
catch(Exception e)
{
}

Note : The Resourse class must implements either from Closeable or AutoCloseable.

There is a predefined interface available in java.lang package called AutoCloseable from JDK 1.7 which contains predefined abstract method i.e close() which throws Exception.

There is another predefined interface available in java.io package called Closeable from JDK 1.5, this Closeable interface is the sub interface for AutoCloseable interface.

public interface java.lang.AutoCloseable
{
   public abstract void close() throws Exception;
}
public interface java.io.Closeable extends java.lang.AutoCloseable
{
   void close() throws IOException;
}

Whenever we pass any resourse class object as part of try with resources as a parameter then that class must implements either Closeable or AutoCloseable interface so, try with resourses will automatically call the respective class
close() method even an exception is encountered in the try block.

ResourceClass rc = new ResourceClass();
try(rc)  
{                                              
}                                               
catch(Exception e)                             
{                                          

}

This ResourceClass must implements either Closeable or AutoCloseable interface so, try block will automatically call the close() method as well as try block will get the guarantee of close() method support in the respective class.


The following program explains how try block is invoking the close() method available in DatabaseResource class and FileResourse class.

-------------------------------------------------------------
3 files :
----------
package com.ravi.try_with_resourses;

import java.io.Closeable;
import java.io.IOException;

public class FileResourse implements Closeable
{
	@Override
	public void close() throws IOException 
	{
		System.out.println("File Resourse Closed!!!");
		
	}

}


package com.ravi.try_with_resourses;

public class DatabaseResourse implements AutoCloseable
{
	@Override
	public void close() throws Exception 
	{
		System.out.println("Database Resourse Closed!!!");
		
	}

}

package com.ravi.try_with_resourses;

public class TryWithResourseDemo {

	public static void main(String[] args) throws Exception
	{
		System.out.println("Main Started");
		
		FileResourse fr = new FileResourse();
		DatabaseResourse dr = new DatabaseResourse();
		
		try(fr ; dr)
		{
			System.out.println(10/0);
		}
		catch(ArithmeticException e)
		{
			System.err.println("Divide by zero problem");
		}
		
		System.out.println("Main Ended");

	}

}
--------------------------------------------------------------
package com.ravi.try_with_resourses;

import java.util.InputMismatchException;
import java.util.Scanner;

public class TryWithResourseDemo1 
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		
		try(sc)
		{
			System.out.println("Enter your Roll Number :");
			int roll = sc.nextInt();
			System.out.println("Your roll number is :"+roll);
		}
		catch(InputMismatchException e)
		{
			System.err.println("Input is mismatched!!!");
		}

	}

}
--------------------------------------------------------------
***Difference between Checked Exception and Unchecked Exception :
------------------------------------------------------------
Checked Exception :
----------------------
A checked exception is a common exception that must be declared or handled by the application code where it is thrown, Here compiler takes very much care and wanted the clarity regarding the exception by saying that, by using this code you may face some problem at runtime and you did not report me how would you handle this situation at runtime are called Checked exception, so provide either try-catch or declare the method as throws.

Except RuntimeException, all the checked exceptions are directly sub class of java.lang.Exception OR Throwable.

Eg:
---
FileNotFoundException, IOException, InterruptedException,ClassNotFoundException, SQLException, CloneNotSupportedException, EOFException and so on

Unchecked Exception :-
--------------------------
An unchecked exception is rare and any exception that does not need to be declared or handled by the application code where it is thrown, here compiler does not take any care are called unchecked exception.

Unchecked exceptions are directly entertain by JVM because they are rarely occurred in java.

All the un-checked exceptions are sub class of RuntimeException as well as Error and all the sub classes of Error are considered as Unchecked Exception.

RuntimeException is also Unchecked Exception.

Eg:
---
ArithmeticException, ArrayIndexOutOfBoundsException, NullPointerException, NumberFormatException, ClassCastException, ArrayStoreException and so on.
-------------------------------------------------------------
Some Bullet points regarding Checked and Unchecked :
-----------------------------------------------------
Checked Exception :
------------------
  1) Common Exception
  2) Compiler takes care (Will not compile the code)
  3) Handling is compulsory (try-catch OR throws)
  4) Directly the sub class of java.lang.Exception OR Throwable

Unchecked Exception :
----------------------
  1) Rare Exception
  2) Comiler will not take any care
  3) Handling is not Compulsory
  4) Sub class of RuntimeException OR Error

*Why compiler takes very much care regarding the checked Exception ?
---------------------------------------------------------------
As we know Checked Exceptions are very common exception so in case of checked exception "handling is compulsory" because checked Exception depends upon other resources as shown below.

IOException  (we are depending upon System Keyboard OR Files )
FileNotFoundException(We are depending upon the file)
InterruptedException (Thread related problem)
ClassNotFoundException (class related problem)
SQLException (SQL related or database related problem)
CloneNotSupportedException (Object is the resourse)
EOFException(We are depending upon the file)

----------------------------------------------------------
When to provide try-catch or declare the method as throws for Checked Exception :-

try-catch
----------
We should provide try-catch if we want to handle the exception in the method where checked exception is encountered, as well as if we want to provide user-defined messages to the client.

throws :
--------
throws keyword describes that the method might throw an Exception, It also might not. It is used only at the end of a method declaration to indicate what exceptions it supports OR what type of Exception it might throw which will be handled by JVM or caller method.

Note :- It is always better to use try catch so we can provide appropriate user defined messages to our client.
------------------------------------------------------------
11-01-2025
----------
Exception propagation [Propagation of Exception from Callee to Caller]
--------------------------------------------------------------
Whenever we call a method and if the the callee method contains any kind of exception (checked OR Unchecked) and if callee method doesn't contain any kind of exception handling mechanism (try-catch OR throws) then JVM will propagate the exception object to caller method for handling purpose. This is called Exception Propagation.

If the caller method also does not contain any exception handling mechanism then JVM will terminate the method from the stack frame hence the remaining part of the method(m1 method) will not be executed even if we handle the exception in another caller method like main.

If any of the the caller method does not contain any exception handling mechanism then exception will be handled by JVM, JVM has default exception handler which will provide the exception message and terminates the program abnormally.
--------------------------------------------------------------
 package com.ravi.exception_propagation;

import java.util.Scanner;

public class ExceptionPropagationUsingUnchecked
{
	public static void main(String [] args)
	{
	   System.out.println("Main method Started!!!");
	   try
	   {
		   m1();
	   }
	   catch(ArithmeticException e)
	   {
		   System.out.println("Handled by main");
	   }
	   System.out.println("Main method Ended!!!");
	}

	public static void m1()
	{
	   System.out.println("M1 method Started!!!");
	   m2();
	   System.out.println("M1 method Ended!!!");
	}
	
	public static void m2()
	{
	       Scanner sc = new Scanner(System.in);
	   	   System.out.print("Enter the value of x :");
		   int x = sc.nextInt();
		   System.out.print("Enter the value of y :");
		   int y = sc.nextInt();
		   int result = x /y;
		   System.out.println("result is :"+result);
	       sc.close();
	   
	}

}

package com.ravi.exception_propagation;

import java.util.Scanner;

public class ExceptionPropagationUsingChecked {

	public static void main(String [] args) 
	{
	   System.out.println("Main method Started!!!");
	   try
	   {
		   m1();
	   }
	   catch(ClassNotFoundException e)
	   {
		   System.out.println("Handled by main method");
	   }
	   System.out.println("Main method Ended!!!");
	}

	public static void m1() throws ClassNotFoundException
	{
	   System.out.println("M1 method Started!!!");
	   m2();
	   System.out.println("M1 method Ended!!!");
	}
	
	public static void m2() throws ClassNotFoundException
	{
	       Scanner sc = new Scanner(System.in);
	       System.out.println("Enter your FQN (class Name :) :");
	       String className = sc.next();
	       
	       Class.forName(className);
	       sc.close();
	   
	}


}

class Foo
{
	static
	{
		System.out.println("Static Block");
	}
}

Note : It is strongly recommended that if, while working with checked exception, method uses throws keyword to skip from the current situation and try to send the exception object to the called method then any of the caller method must handle the 
exception.
---------------------------------------------------------------
Some important rules regarding the checked Exception :
------------------------------------------------------

a) If the try block does not throw any checked exception then in the corresponding catch block we can't handle checked exception.It will generate compilation error i.e "exception never thrown from the corresponding try statement"

Example :-

public class Test 
{
	public static void main(String[] args) 
	{
		try
		{
	          //try block is not throwing checked exception
		  //i.e. InterruptedException
		}
		catch (InterruptedException e) //error
		{
		}

	}

}

Note :- The above rule is not applicable for Unchecked Exception

               try
		{
			
		}
		catch(ArithmeticException e)  //Valid
		{
			e.printStackTrace();
		}
-----------------------------------------------------------------------
b) If the try block does not throw any exception then in the corresponding catch block we can write Exception OR Throwable because both are the super classes for all types of Exception whether it is checked or unchecked.

package com.ravi.method_related_rule;

public class CatchingWithSuperClass 
{
	public static void main(String[] args) 
	{		
		
		try
		{
			
		}
		catch(Exception e)  //Exception and Throwable both are allowed
		{
          e.printStackTrace();			
		}

	}

}
---------------------------------------------------------------
c) At the time of method overriding if the super class method does not reporting or throwing checked exception then the overridden method of sub class not allowed to throw checked exception otherwise it will generate compilation error but overridden method can throw Unchecked Exception.

package com.ravi.method_related_rule;

class Super
{
	public void show()  
	{
		System.out.println("Super class method not throwing checked Exception");
	}
}
class Sub extends Super
{
	@Override
	public void show()  //throws CloneNotSupportedException
	{
		System.out.println("Sub class method should not throw checked Exception");
	}
}

public class MethodOverridingWithChecked {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}

---------------------------------------------------------------

d) If the super class method declare with throws keyword to throw a checked exception, then at the time of method overriding, sub class method may or may not use throws keyword.
               If the Overridden method is also using throws
 keyword to throw checked exception then it must be either same exception class or sub class, it should not be super class as well as we can't add more exceptions in the overridden method.

package com.ravi.method_related_rule;

import java.io.FileNotFoundException;
import java.io.IOException;

class Base
{
	public void show() throws FileNotFoundException
	{
		System.out.println("Super class method ");
	}
}
class Derived extends Base
{
	public void show() //throws IOException  [error]
	{
		System.out.println("Sub class method ");
	}
}

public class MethodOverridingWithThrows 
{
	public static void main(String[] args) 
	{
	  System.out.println("Overridden method may or may not throw checked exception but if it is throwing then must be same or sub class");	
	}

}
---------------------------------------------------------------
e) Just like return keyword, we can't use throw keyword inside static and non static block  to throw an exception because all initializers must be executed normally.

We can use throw keyword in the protection of try-catch so the code will be executed normally.

public class Main 
{
	public static void main(String[] args)  
	{
		
	}	
	
	static
	{
		try
		{
			throw new ArithmeticException();
		}
		catch (ArithmeticException e)
		{
			System.out.println("Exception Handled");
		}
		
	}
	
}
---------------------------------------------------------------
f) If we call any method and if the method throws java.lang.Exception OR java.lang.Throwable then handling is compulsory at caller Method otherwise it will generate compilation error because Exception and Throwable both are representing checked and Unchecked.



public class Main 
{
	public static void main(String[] args)  
	{
		m1();
	}	
	
	public static void m1() throws Throwable //OR Exception
	{                                           [Error]
	}
	
	
}
=============================================================
20-01-2025
-----------
Nested try block :
------------------
If we write a try block inside another try block then it is called Nested try block.

try  //Outer try             
{
  statement1;
     try  //Inner try
     {
        statement2;
     }
     catch(Exception e) //Inner catch
     {
     }
}
catch(Exception e) //Outer Catch
{
}

The execution of inner try block depends upon outer try block that means if we have an exception in the Outer try block then inner try block will not be executed.
-------------------------------------------------------------
package com.ravi.basic;

public class NestedTryBlock 
{
	public static void main(String[] args) 
	{		
	      try  //outer try
	      {
	    	    String x = null;
	    	    System.out.println("It's length is :"+x.length());
	    	        
		    	  try  //inner try
		    	  {
		    		 String y = "NIT"; 
		    		 int z = Integer.parseInt(y);
		    		 System.out.println("z value is :"+z);	    				    		  
		    	  }
		    	  catch(NumberFormatException e)
		    	  {
		    		System.err.println("Number is not in a proper format");  
		    	  }
	      }
	      catch(NullPointerException e)
	      {
	    	  System.err.println("Null pointer Problem"); 	    	 
	      }	      
	}
}
-------------------------------------------------------------
Writing try-catch inside catch block :
---------------------------------------
We can write try-catch inside catch block but this try-catch block will be exceuted if the catch block will executed that means if we have an exception in the try block.

package com.ravi.basic;

import java.util.InputMismatchException;
import java.util.Scanner;

public class TryWithCatchInsideCatch 
{	
	public static void main(String[] args)
	{
		Scanner sc = new Scanner(System.in);
		
		try(sc)
		{			
			System.out.print("Enter your Roll number :");
			int roll = sc.nextInt();
			System.out.println("Your Roll is :"+roll);			
			
		}	
		catch(InputMismatchException e)
		{
			System.err.println("Provide Valid input!!");
			
			try
			{
				System.out.println(10/0);
			}
			catch(ArithmeticException e1)
			{
			  System.err.println("Divide by zero problem");	
			}
			
		}
		finally
		{
			System.out.println("Finally block");
			try
			{
				Object []obj = new String[3];
				obj[0] = "12";
				obj[1] = "14";
				obj[2] = 90;  //Invalid
			}
			catch(ArrayStoreException e)
			{
				System.err.println("Invalid element so can't store in array");
			}
		}
	}

}
-------------------------------------------------------------

try-catch with return statement
-------------------------------
If we write try-catch block inside a method and that method is returning some value then we should write return statement in both the places i.e inside the try block as well as inside the catch block.

We can also write return statement inside the finally block only, if the finally block is present. After this return statement we cannot write any kind of statement. (Unrechable)

Always finally block return statement having more priority then try-catch return statement.

package com.ravi.advanced;
public class ReturnExample
{
    public static void main(String[] args) 
    {     	
       System.out.println(methodReturningValue());        
    }	
	
    public static int methodReturningValue()
    {
        try
        {
            System.out.println("Try block");
            return 10/0;    
        }
        catch (Exception e)
        {
            System.out.println("catch block");         
           return 20;  //return statement is compulsory  
        }
        
       // System.out.println("Unreachable code");
               
    }
}
-------------------------------------------------------------
package com.ravi.advanced;

public class ReturnExample1 {

	public static void main(String[] args)
	{
		System.out.println(m1());
	}

	@SuppressWarnings("finally")
	public static int m1()
	{	
		try
		{
			System.out.println("Inside try");
			return 100;
		}
		catch(Exception e)
		{
			System.out.println("Inside Catch");
			return 200;
		}
		finally
		{
			System.out.println("Inside finally");
			return 300;
		}
		
		// System.out.println("....");   Unreachable line
	}
}
-------------------------------------------------------------
Initialization of a variable in try and catch :
-----------------------------------------------
A local variable must be initialized inside try block as well as catch block OR at the time of declaration.

If we initialize inside the try block only then from catch block we cannot access local variable value, Here initialization is compulsory inside catch block.

package com.ravi.basic;

public class VariableInitialization 
{
	public static void main(String[] args)
	{      
	  int x;
	  
	  try
	  {		  
		  int []arr = new int[-10];
		  x = 190;
		  System.out.println(x);
	  }
	  catch(Exception e)
	  {
		  x = 200;
		 System.out.println(x);
	  }
		
		
	}

}
-------------------------------------------------------------
*** Difference between throw and throws :
------------------------------------------
throw [THROWING THE EXCEPTION OBJCET EXPLICITLY.]
------------------------------------------------------
We should use throw keyword to throw the exception object explicitly, In case of try block, try block is responsible to create the exception object with JVM as well as throw the exception object to the nearest catch block. 
but if a developer wants to throw exception object explicitly then we use throw keyword.

           throw new ArithmeticException();
	   throw new LowBalanceException();

after using throw keyword the control will transfer to the nearest catch block so after throw keyword statement, the remaining statements are un-reachable.

throws :- 
---------
throws keyword describes that the method might throw an Exception, It also might not. It is used only at the end of a
method declaration to indicate what exceptions it supports OR what type of Exception it might throw at runtime.

It is used to skip from the current situation so now the execption will be propagated to the caller method OR JVM for 
handling purpose.

It is mainly used to work with Checked Exception.
-------------------------------------------------------------
Types of exception in java :
-------------------------------
Exception can be divided into two types :

1) Predefined Exception OR Built-in Exception

2) Userdefined Exception OR Custom Exception

Predefined Exception :-
-------------------------
The Exceptions which are already defined by Java software people for some specific purposes are called predefined Exception or Built-in exception.
Ex :
----
IOException, ArithmeticException and so on

Userdefined Exception :-
---------------------------
The exceptions which are defined by user according to their own use and requirement are called User-defined Exception.

Ex:-
----
InvalidAgeException, GreaterMarksException
------------------------------------------------------------
How to develop User-defined Exceptions :
-----------------------------------------
As a developer we can develop user-defined checked and user-defined unchecked exception.

If we want to develop checked exception then our user-defined class must extends from java.lang.Exception, on the other hand if we want to develop un-checked exception then our user-defined class must extends from java.lang.RuntimeException.

In the user-defined exception class we should write No argument constructor(in case if we don't want to pass any error message) and we should write parameterized constructor with String errorMessage as a parameter (in case if we  want to pass any error message) with super keyword.

In order to throw the exception object explicitly we should use throw keyword as well as our user-defined class object must be of Throwable type.

package com.ravi.exception;

@SuppressWarnings("serial")
class InvalidAgeException extends Exception
{
	public InvalidAgeException()
	{		
	}
	
	public InvalidAgeException(String errorMessage)
	{
		super(errorMessage);
	}
}

public class CustomCheckedException 
{
	public static void main(String[] args)
	{
		try
		{
			validateAge(12);
		}
		catch(InvalidAgeException e)
		{
			System.err.println(e);
		}
	}	
	
	public static void validateAge(int age) throws InvalidAgeException
	{		
		if(age < 18)
		{
			throw new InvalidAgeException("Age is invalid");
			
		}
		else
		{
			System.out.println("You are eligible for vote becuause your age is :"+age);
		}
		
	}	

}
------------------------------------------------------------
package com.ravi.exception;

import java.util.Scanner;

@SuppressWarnings("serial")
class GreaterMarksException extends RuntimeException
{
	public GreaterMarksException()
	{
		
	}
	public GreaterMarksException(String errorMessage)
	{
		super(errorMessage);
	}
}

public class CustomUncheckedException {

	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		try(sc)
		{
			System.out.println("Enter your Marks :");
			int marks = sc.nextInt();
			validateMarks(marks);
		}
		catch(GreaterMarksException e)
		{
			System.err.println("Your marks must not be greater than 100");
			e.printStackTrace();
		}
	}
    
	
	public static void validateMarks(int marks)
	{
		if(marks > 100)
		{
			throw new GreaterMarksException("Invalid Marks");
		}
		else
		{
			System.out.println("Your Marks is :"+marks);
		}
		
	}
}
-------------------------------------------------------------
21-01-2025
-----------
Multithreading :
----------------


Uniprocessing :- 
----------------
In uniprocessing, only one process can occupy the memory So the
major drawbacks are 

1) Memory is westage
2) Resources are westage
3) Cpu is idle

To avoid the above said problem, multitasking is introduced.

In multitasking multiple tasks can concurrently work with CPU so, our task will be completed as soon as possible.

Multitasking is further divided into two categories.

a) Process based Multitasking [Diagram : 21st JAN]
b) Thread based Multitasking  [Diagram : 21st JAN]


Process based Multitasking :
----------------------------
If a CPU is switching from one subtask(Thread) of one process to another subtask of another process then it is called Process based Multitasking.

Thread based Multitasking :
---------------------------
If a CPU is switching from one subtask(Thread) to another subtask within the same process then it is called Thread based Multitasking.

What is Thread in java ?
-------------------------
A thread is light weight process and it is the basic unit of CPU which can run concurrently with another thread within the same context (process).

It is well known for independent execution. The main purpose of multithreading to boost the execution sequence.

A thread can run with another thread concurrently within the same process so our task will be completed as soon as possible.

In java whenever we define main method then JVM internally creates a thread called main thread under main group.

Program that describes that main is a Thread :
-----------------------------------------------
Whenever we define main method then JVM will create main thread internally under main group, the purpose of this main thread to execute the entire main method code.

In java there is a predefined class called Thread available in java.lang package, this class contains a predefined static factory method currentThread() which will provide currently executing Thread Object.

Thread t = Thread.currentThread(); //static Factory Method

Thread class has provided predefined method getName() to get the name of the Thread.
                 public final String getName();

Program :
----------
package com.ravi.mt;

public class MainThread 
{
	public static void main(String[] args)
	{
		Thread t1 = Thread.currentThread();
		System.out.println("Current Thread Name is :"+t1.getName());
		
		        //OR
		String name = Thread.currentThread().getName(); //Method chaining
		System.out.println("Running thread name is :"+name);
		
	}
}
------------------------------------------------------------
How to create user-defined thread ?
-----------------------------------
We can create user-defined thread by using the following two packages 

  1) By using java.lang package [JDK 1.0]
  2) By using java.util.concurrent sub package [JDK 1.5]

Creating user-defind Thread by using java.lang package :
--------------------------------------------------------
By using java.lang package we can create user-defined thread by using any one of the following two approaches :

 1) By extending java.lang.Thread class
 2) By implementing java.lang.Runnable interface 

 Note :- Thread is a predefined class available in java.lang package where as Runnable is a predefined interface available in java.lang Package.
-------------------------------------------------------------
Creating user-defined Thread by using extending Thread class :
--------------------------------------------------------------
public synchronized void start() :
-----------------------------------
start() is a predefined non static method of Thread class which internally performs the following two tasks :

1) It will make a request to the O.S to assign a new thread for concurrent execution.

2) It will implicitly call run() method on the current object.


package com.ravi.multithreading;

class MyThread extends Thread
{
	@Override
	public void run()
	{
		System.out.println("Child thread is Running..");
	}
}
public class CustomThread 
{
	public static void main(String[] args) throws InterruptedException 
	{
		System.out.println("Main thread started.....");		
		MyThread mt = new MyThread();
		mt.start();			
		System.out.println("Main thread ended.....");
	}

}


In the above program, we have two threads, main thread which is responsible to execute 
main method and Thread-0 thread which is responsible to execute run() method. [22-JAN]

In entire Multithreading concept start() is the only method which is responsible to create a new thread.
---------------------------------------------------------------
public final boolean isAlive() :-
-----------------------------
It is a predefined non static method of Thread class through which we can find out whether a thread has started or not ?

As we know a new thread is created/started after calling start() method so if we use isAlive() method before start() method, it will return false but if the same isAlive() method if we invoke after the start() method, it will return true.

We can't restart a thread in java if we try to restart then It will generate an exception i.e java.lang.IllegalThreadStateException
---------------------------------------------------------------
package com.ravi.basic;

class Foo extends Thread
{
	@Override
	public void run()
	{
		System.out.println("Child thread is running...");
		System.out.println("It is running with separate stack memory");		
	}	
}
public class IsAlive 
{
	public static void main(String[] args) 
	{
		System.out.println("Main Thread started...");
		
		Foo f1 = new Foo();
		System.out.println("Is Thread alive : "+f1.isAlive());
		
		f1.start(); 
		
		System.out.println("Thread is alive or not : "+f1.isAlive());
		
		//f1.start();  //java.lang.IllegralThreadStateException
		
		System.out.println("Main Thread ended...");
		
		
	}
}
----------------------------------------------------------------
package com.ravi.basic;

class Stuff extends Thread
{
	@Override
	public void run() 
	{		
		String name = Thread.currentThread().getName();		
		System.out.println("Child Thread is Running, name is :"+name);
	}	
}
public class ExceptionDemo 
{
	public static void main(String[] args)
	{		
		String name = Thread.currentThread().getName();		
	    System.out.println(name+" thread started");		
	
		Stuff s1 = new Stuff(); 
		Stuff s2 = new Stuff(); 		
				
		s1.start();
		s2.start();
		
		System.out.println(10/0);
		
		System.out.println("Main Thread Ended");
	}

}

Note :- Here main thread is interrupted due to AE but still child thread will be executed because child threads are executing with separate Stack.
----------------------------------------------------------------
package com.ravi.basic;

class Sample extends Thread  
{
	@Override
	public void run()
	{
		String name = Thread.currentThread().getName();
		
		for(int i=1; i<=10; i++)
		{
		   System.out.println("i value is :"+i+" by "+name+ " thread");	
		}
	}
}
public class ThreadLoop 
{	
	public static void main(String[] args)
	{	
		Sample s1 = new Sample();
		s1.start();
		
        String name = Thread.currentThread().getName();
		
		for(int i=1; i<=10; i++)
		{
		   System.out.println("i value is :"+i+" by "+name+ " thread");	
		}
		
		int x = 1;
		do
		{
			System.out.println("Batch 40");
		    x++;
		}
		while(x<=10);
		
	}
}

Note : Here processor is frequently switching from main thread to Thread-0 thread so output is un-predicatable.
---------------------------------------------------------------
23-01-2025
-----------
How to set and get the name of the Thread : 
--------------------------------------------------
Whenever we create a userdefined Thread in java then by default JVM assigns the name of thread is Thread-0, Thread-1, Thread-2 and so on.

If a user wants to assign some user defined name of the Thread, then Thread class has provided a predefined method called setName(String name) to set the name of the Thread.

On the other hand we want to get the name of the Thread then Thread class has provided a predefined method called getName().

public final void setName(String name)  //setter

public final String getName()  //getter
---------------------------------------------------------------
package com.ravi.basic;
class DoStuff extends Thread  
{
	@Override
	public void run()
	{
		String name = Thread.currentThread().getName();
		System.out.println("Running Thread name is :"+name);
	}
}
public class ThreadName 
{
	public static void main(String[] args) 
	{
		DoStuff t1 = new DoStuff(); 
		DoStuff t2 = new DoStuff(); 
		
				
		t1.start();			
		t2.start();		
			
			
	System.out.println(Thread.currentThread().getName()+" thread is running.....");
	}
}


We are not providing the user-defined names so by default the name of thread would be Thread-0, Thread-1.
---------------------------------------------------------------
package com.ravi.basic;

class Demo extends Thread
{
	@Override
	public void run()
	{
		 String name = Thread.currentThread().getName();
		 System.out.println("Running Thread name is :"+name);
	}
}
public class ThreadName1 
{
	public static void main(String[] args) 
	{
	   Thread t = Thread.currentThread();
	   t.setName("Parent");
	   
	   Demo d1 = new Demo();
	   Demo d2 = new Demo();
	   
	   d1.setName("Child1");
	   d2.setName("Child2");
	   
	   d1.start();
	   d2.start();
	   
	   String name = Thread.currentThread().getName();
	   System.out.println(name + " Thread is running Here..");
	   
	   
	}
}


Note : Here we are providing the user-defined name i.e child1 and child2 for both the user-defined thread.
---------------------------------------------------------------
package com.ravi.basic;

import java.util.InputMismatchException;
import java.util.Scanner;

class BatchAssignment extends Thread
{
	@Override
	public void run()
	{
		String name = Thread.currentThread().getName();
		
		if(name !=null && name.equalsIgnoreCase("Placement"))
		{
			this.placementBatch();
		}
		else if(name !=null && name.equalsIgnoreCase("Regular"))
		{
			this.regularBatch();
		}
		else
		{
			throw new NullPointerException("Name can't be null");
		}
	}
	
	public void placementBatch()
	{
		System.out.println("I am a placement batch student.");
	}
	
	public void regularBatch()
	{
		System.out.println("I am a Regular batch student.");
	}
}


public class ThreadName2 
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);	
		try(sc)
		{
			System.out.print("Enter your Batch Title [Placement/Regular] :");
			String title = sc.next();
			
			BatchAssignment b = new BatchAssignment();
			b.setName(title);
			
			b.start();
		}
		catch(InputMismatchException e)
		{
			System.out.println("Invalid Input");
		}
		
		
	}

}
---------------------------------------------------------------

Thread.sleep(long millisecond) :   
-------------------------------
If we want to put a thread into temporarly waiting state then we should use sleep() method.

The waiting time of the Thread depends upon the time specified by the user in millisecond as parameter to sleep() method.

It is a static method of Thread class.

Thread.sleep(1000); //Thread will wait for 1 second


It is throwing a checked Exception i.e InterruptedException because there may be chance that this sleeping thread may be interrupted by a thread so provide either try-catch or declare the method as throws.
--------------------------------------------------------------
package com.ravi.basic;

class Sleep extends Thread
{
   @Override
   public void run()
   {	      
	  for(int i=1; i<=10; i++)
	  {
		System.out.println("i value is "+i);  
		try
		{
			Thread.sleep(1000); //Here thread will wait for 1 sec
		}
		catch(InterruptedException e)
		{
			System.err.println(e);//java.lang.InterruptedException:sleep interrupted
		}
	  } 	   
   }   
}
public class SleepDemo 
{
	public static void main(String[] args) 
	{
	   Sleep s1 = new Sleep();
	   s1.start(); 
	  	  	  
	}
}

Note : Here child thread is not interrupted, so catch block will not be executed.
--------------------------------------------------------------
package com.ravi.basic;

class MyTest extends Thread 
{			
		
	@Override
	public void run()  
	{		
		System.out.println("Child Thread id is :"+Thread.currentThread().getId()); 
		
		for(int i=1; i<=5; i++)
		{
			System.out.println("i value is :"+i);  //11  22   33   44   55
			try
			{
				Thread.sleep(1000);
			}
			catch(InterruptedException e)
			{
				e.printStackTrace();
			}
		}
		
	}
}
public class SleepDemo1 
{
	public static void main(String[] args) 
	{		
		System.out.println("Main Thread id is :"+Thread.currentThread().getId());  //1
		
		MyTest m1 = new MyTest();		
		MyTest m2 = new MyTest();
		
		m1.start();
		m2.start();			
	}
}
---------------------------------------------------------------
package com.ravi.basic;

class MyThread1 extends Thread
{
	@Override
	public void run()
	{
		System.out.println("Child Thread is running");
	}
}

public class SleepDemo2 {

	public static void main(String[] args) throws InterruptedException
	{
		System.out.println("Main Thread started!!!");
		MyThread1 m1 = new MyThread1();
		m1.start();
		
		m1.sleep(5000);
	
		System.out.println("Main Thread ended!!!");
		

	}

}

Here main thread will wait for 5 sec
--------------------------------------------------------------
Assignment :
------------
Thread.sleep(long mills, int nanos);
--------------------------------------------------------------
Old Thread life cycle (Before Java 1.5V) :[23rd JAN 25]
-----------------------------------------
As we know a thread is well known for Independent execution and it contains a life cycle which internally contains 5 states (Phases). 

During the life cycle of a thread, It can pass from thses 5 states. At a time a thread can reside to only one state of the given 5 states.

1) NEW State (Born state)

2) RUNNABLE state (Ready to Run state) [Thread Pool]

3) RUNNING state

4) WAITING / BLOCKED state

5) EXIT/Dead state

----------------------------------------------------------------------
New State :-
-------------
Whenever we create a thread instance(Thread Object) a thread comes to new state OR born state. New state does not mean that the Thread has started yet only the object or instance of Thread has been created.

Runnable state :-
-------------------
Whenever we call start() method on thread object, A thread moves to Runnable state i.e Ready to run state. Here Thread schedular is responsible to select/pick a particular Thread from Runnable state and sending that particular thread to Running state for execution.

Running state :-
-----------------
If a thread is in Running state that means the thread is executing its own run() method in a separate stack Memory.

From Running state a thread can move to waiting state either by an order of thread schedular or user has written some method(wait(), join() or sleep()) to put the thread into temporarly waiting state.

From Running state the Thread may also move to Runnable state directly, if user has written Thread.yield() method explicitly.

Waiting state :-
------------------
A thread is in waiting state means it is waiting for it's time period to complete OR in some cases it is also waiting for lock (monitor) OR another thread to complete. Once the time period will be completed then it will re-enter inside the Runnable state to complete its remaining task.

Dead or Exit :
----------------
Once a thread has successfully completed its run method in the corresponding stack then the thread will move to dead state. Please remember once a thread is dead we can't restart a thread in java.
---------------------------------------------------------------------
IQ :- If we write Thread.sleep(1000) then exactly after 1 sec the Thread will re-start?

Ans :- No, We can't say that the Thread will directly move from waiting state to Running state. 

The Thread will definetly wait for 1 sec in the waiting state and then again it will re-enter into Runnable state which is control by Thread Schedular so we can't say that the Thread will re-start just after 1 sec.
---------------------------------------------------------------
Anonymous inner class by using Thread class :
---------------------------------------------
Case 1 :
--------
Anonymous inner class using reference variable :
-------------------------------------------------
package com.ravi.anonymous;

public class AnonymousThreadWithReerence 
{
	public static void main(String[] args) 
	{
		//Anonymous inner class
		Thread t1 = new Thread()
		{
			@Override
			public void run()
			{
				String name = Thread.currentThread().getName();
				System.out.println("Running Thread name is :"+name);
			}
		};
		t1.start();

		String name = Thread.currentThread().getName();
		System.out.println("Current Thread name is :"+name);
		
	}

}

Case 2 :
--------
Anonymous inner class without reference variable :
-------------------------------------------------
package com.ravi.anonymous;

public class AnonymousThreadWithoutReference 
{
	public static void main(String[] args) 
	{
		//Anonymous inner class
		new Thread()
		{
			@Override
			public void run()
			{
				String name = Thread.currentThread().getName();
				System.out.println("Running Thread name is :"+name);
			}	
		}.start();

	}

}
---------------------------------------------------------------
join() method of Thread class :
-------------------------------
The main purpose of join() method to put the current thread into waiting state until the other thread finish its execution.

Here the currently executing thread stops its execution and the thread goes into the waiting state. The current thread remains in the wait state until the thread on which the join() method is invoked has achieved its dead state.

It also throws checked exception i.e InterruptedException so better to use try catch or declare the method as throws.

It is a non static method so we can call this method with the help of Thread object reference.

---------------------------------------------------------------
package com.ravi.basic;

class Join extends Thread   
{                                    
	@Override
	public void run()
	{
		String name = Thread.currentThread().getName();
		System.out.println(name+" Thread started");
		
		for(int i=1; i<=5; i++)
		{
			System.out.println("i value is :"+i+" by "+name+ " thread");
			try
			{
				Thread.sleep(1000);
			}
			catch(InterruptedException e)
			{
			  e.printStackTrace();	
			}			
		}
		System.out.println(name+" Thread ended");
	}
	
	
}

public class JoinDemo 
{
	public static void main(String[] args) throws InterruptedException  
	{
		System.out.println("Main Thread started");
		
		Join j1 = new Join();		
		Join j2 = new Join();		
		Join j3 = new Join();	
		
		j1.setName("j1");
		j2.setName("j2");
		j3.setName("j3");
		
		j1.start();
				
		System.out.println("Main Thread is going to block");
		j1.join();  //Main thread will wait Here
		System.out.println("Main Thread Wake up..");	
		
		j2.start();
		j3.start();
		
		System.out.println("Main Thread Ended");
	}

}
---------------------------------------------------------------
package com.ravi.basic;

class Alpha extends Thread   
{
	@Override
	public void run()
	{
		Thread t = Thread.currentThread();
		String name = t.getName();	//Alpha_Thread is current thread		
		
		Beta b1 = new Beta();
		b1.setName("Beta_Thread");
        b1.start();  
        try 
        {
			b1.join(); //Alpha thread is waiting 4 Beta Thread to complete
		
			System.out.println("Alpha thread re-started");
		} 
        catch (InterruptedException e) 
        {			
			e.printStackTrace();
		}
		
		for(int i=1; i<=10; i++)
		{
			System.out.println(i+" by "+name);
		}
		
	}
}

public class JoinDemo2 
{
	public static void main(String[] args) 
	{
		Alpha a1 = new Alpha();
		a1.setName("Alpha_Thread");
		a1.start();
	}
}

class Beta extends Thread
{
	@Override
	public void run()
	{
		Thread t = Thread.currentThread();
		String name = t.getName();	//Beta_Thread
		
		for(int i=1; i<=10; i++)
		{
			System.out.println(i+" by "+name);
			try
			{
				Thread.sleep(500);
			}
			catch(InterruptedException e) {
				
			}
		}
		System.out.println("Beta Thread Ended");
	}
}

Note : By using join() method we can control out threads a complete a particular task first.
---------------------------------------------------------------
package com.ravi.basic;

public class JoinDemo1 
{
	public static void main(String[] args) throws InterruptedException 
	{
       System.out.println("Main Thread started");
       
       Thread t = Thread.currentThread();
       
       for(int i=1; i<=10; i++)
       {
    	  System.out.println("i value is :"+i+" by "+t.getName());
    	  Thread.sleep(1000);
       }
       
       t.join(); //Main thread is waiting for main thread to complete  
       
       System.out.println("Main Thread completed");
       
      
	}
}

Note : Here main thread is waiting for main thread to complete.
---------------------------------------------------------------
Assignment :
join(long millis)
join(long millis, long nanos)
--------------------------------------------------------------
25-01-2025
-----------
Assigning target by Runnable interface :[Loose Coupling]
----------------------------------------------------------
Bu using this Loose Coupling concept we can assign target to different-different Threads.

package com.ravi.target;

class UserThread implements Runnable
{
	@Override
	public void run() 
	{
		System.out.println("Child Thread is Running");
		System.out.println("It is running in a separate Stack");
	}	
}

public class RunnableDemo1 {

	public static void main(String[] args) 
	{
	   System.out.println("main Thread Started..");
	   UserThread ut = new UserThread();
	   
       Thread t1 = new Thread(ut);
       t1.start();
       
       Thread t2 = new Thread(ut);
       t2.start();
	}

}
----------------------------------------------------------------
package com.ravi.target;

class Tatkal implements Runnable
{
	@Override
	public void run()
	{
		String name = Thread.currentThread().getName();
		System.out.println(name+" has booked the ticket under Tatkal Scheme");
	}
}

class PremimumTatkal implements Runnable
{
	@Override
	public void run()
	{
		String name = Thread.currentThread().getName();
		System.out.println(name+" has booked the ticket under PremimumTatkal Scheme");
	}
}
public class RunnableDemo2 
{
	public static void main(String[] args) 
	{
		Thread scott = new Thread(new Tatkal(),"Mr. Scott");		
		Thread smith = new Thread(new PremimumTatkal(),"Mr. Smith");
		
		scott.start();
		smith.start();

	}

}
-----------------------------------------------------------------
Thread class constructor :
---------------------------
We have total 10 constructors in the Thread class, The following are commonly used constructor in the Thread class

1) Thread t1 = new Thread();

2) Thread t2 = new Thread(String name);

3) Thread t3 = new Thread(Runnable target);

4) Thread t4 = new Thread(Runnable target, String name);

5) Thread t5 = new Thread(ThredGroup tg, String name);

6) Thread t6 = new Thread(ThredGroup tg, Runnable target);

7) Thread t7 = new Thread(ThredGroup tg, Runnable target, String name);
-----------------------------------------------------------------
Working with Anonymous inner class using Runnable interface :
-------------------------------------------------------------
Case 1 :
--------
package com.ravi.target;

public class AnonymousInnerWithRunnable {

	public static void main(String[] args) 
	{
		Runnable r1 = new Runnable()
		{
			@Override
			public void run() 
			{
				String name = Thread.currentThread().getName();
				System.out.println("Running Thread Name is :"+name);
				
			}			
		};
        Thread t1 = new Thread(r1);
        t1.start();


	}

}

case 2:
--------
package com.ravi.target;

public class RunnableUsingLambda {

	public static void main(String[] args) 
	{
		Runnable r1 = ()-> 
		{
			String name = Thread.currentThread().getName();
			System.out.println("Running Thread Name is :"+name);
		};
		
		Thread t1 = new Thread(r1);
		t1.start();

	}

}


Case 3 :
---------
package com.ravi.target;

public class RunnableUsingLambda {

	public static void main(String[] args) throws InterruptedException 
	{
		Thread t1 = new Thread(new Runnable()
				{
				  @Override
				  public void run()
				  {
					  String name = Thread.currentThread().getName();
					  System.out.println("Running Thread Name is :"+name);
				  }
				
				});
		
		t1.start();
		t1.join();
		
		System.out.println("_______________________________");
		
		new Thread(new Runnable() {
			
			@Override
			public void run() 
			{
				String name = Thread.currentThread().getName();
				System.out.println("Running Thread Name is :"+name);				
			}
		}).start();
		

	}

}

Case 4 :
----------
package com.ravi.target;

public class RunnableUsingLambda {

	public static void main(String[] args) throws InterruptedException 
	{
		new Thread(()->System.out.println(Thread.currentThread().getName()),"J1").start();
	}

}
-------------------------------------------------------------
27-01-2025
----------
Drawback of Multithreading :
----------------------------
Multithreading is very good to complete our task as soon as possible but in some situation, It provides some wrong data or wrong result.

In Data Race or Race condition, all the threads try to access the resource at the same time so the result may be corrupted.

In multithreading if we want to perform read operation and data is not updatable data then multithreading is good but if the data is updatable data (modifiable data) then multithreading may produce some wrong result or wrong data which is known as Data Race OR race condition as shown in the diagram.(27-JAN)
-------------------------------------------------------------
//Program on Railway reservation system :
------------------------------------------
package com.ravi.drawback_of_multithreading;

class Customer implements Runnable
{
	private  int availableSeat = 1;
	private  int wantedSeat;
	
	public Customer(int wantedSeat) 
	{
		super();
		this.wantedSeat = wantedSeat;
	}

	@Override
	public  void run() 
	{		
       String name = null;
       
       if(availableSeat >= wantedSeat)  
       {
    	  name = Thread.currentThread().getName(); 
    	  System.out.println(wantedSeat +" seat is reserved for :"+name);
    	  availableSeat = availableSeat - wantedSeat;    	   
       }
       else
       {
    	   name = Thread.currentThread().getName();
    	   System.err.println("Sorry!!!"+name+" seat is not available");
       }    
     	
	}
	
}

public class RailwayReservation 
{
	public static void main(String[] args)
	{
		Customer cust = new Customer(1);
		
		Thread t1 = new Thread(cust, "Scott");
		Thread t2 = new Thread(cust, "Smith");
		
		t1.start(); t2.start();
	}

}

In the above program both the threads i.e Smith and Scott will get the ticket.
--------------------------------------------------------------
//Program to withdraw the bank balance by multiple threads :
-------------------------------------------------------------
package com.ravi.drawback_of_multithreading;

class Customer 
{
	private double balance = 20000;
	private double amount;
	
	public Customer(double amount) 
	{
		super();
		this.amount = amount;
	}
	
	public  void withdraw()
	{
		String name = null;
		
	   if(this.balance >= this.amount)
	   {
		  name = Thread.currentThread().getName();
		  System.out.println(this.amount+" amount has withdrawn by :"+name);
		  this.balance = this.balance - this.amount;
		  System.out.println("After Withdraw the balance is :"+this.balance);
	   }
	   else
	   {
		   name = Thread.currentThread().getName();
		   System.err.println("Sorry!!!"+name+" balance is insufficient..");
	   }
	}
	
}

public class BankApplication {

	public static void main(String[] args) 
	{
		Customer cust = new Customer(20000);
		
		Runnable r1 = () -> cust.withdraw();
		
		Thread t1 = new Thread(r1,"Scott");
		Thread t2 = new Thread(r1,"Smith");
		
		t1.start();  t2.start();
		

	}

}

Note : Here also both the threads will get 20k balance.
------------------------------------------------------------
***Synchronization :
-------------------
In order to solve the problem of multithreading java software people has introduced synchronization concept.

In order to acheive sycnhronization in java we have a keyword called "synchronized".

It is a technique through which we can control multiple threads but accepting only one thread at all the time.

Synchronization allows only one thread to enter inside the synchronized area for a single object.

Synchronization can be divided into two categories :-

1) Method level synchronization

2) Block level synchronization

1) Method level synchronization :-
-----------------------------------
In method level synchronization, the entire method gets synchronized so all the thread will wait at method level and only one thread will enter inside the synchronized area as shown in the diagram.(27-JAN-25)


2) Block level synchronization
-------------------------------
In block level synchronization the entire method does not get synchronized, only the part of the method gets synchronized so all the thread will enter inside the method but only one thread will enter inside the synchronized block as shown in the diagram (27-JAN-25) 

Note :- In between method level synchronization and block level synchronization, block level synchronization is more preferable because all the threads can enter inside the method so only the PART OF THE METHOD GETS synchronized so only one thread will enter inside the synchronized block.

Note :  Synchronized area is a restricated area, with 
permission only a thread can enter inside synchronized area.
--------------------------------------------------------------
28-01-2025
----------
How synchronization mechanism controls multiple thread ?
--------------------------------------------------------
Every Object has a lock(monitor) in java environment and this lock can be given to only one Thread at a time.

Actually this lock is available with each individual object provided by Object class. 

The thread who acquires the lock from the object will enter inside the synchronized area, it will complete its task without any disturbance because at a time there will be only one thread inside the synchronized area(for single Object). *This is known as Thread-safety in java.

The thread which is inside the synchronized area, after completion of its task while going back will release the lock so the other threads (which are waiting outside for the lock) will get a chance to enter inside the synchronized area by again taking the lock from the object and submitting it to the synchronization mechanism.
This is how synchronization mechanism controls multiple Threads.

Note :- Synchronization logic can be done by senior programmers in the real time industry because due to poor synchronization there may be chance of getting deadlock.

//Program on Method Level Synchronization
package com.ravi.synchronization;

class Table
{
  public synchronized void printTable(int num) 
  {
     for(int i=1; i<=10; i++)
     {
        System.out.println(num+" X "+i+" = " +(num*i));
        try
        {
        	Thread.sleep(1000);
        }
        catch(InterruptedException e)
        {
        	e.printStackTrace();
        }
     }  
     System.out.println(".........................");
  }
}

public class MethodSynchronization {

	public static void main(String[] args) 
	{
		Table obj = new Table();  //Lock is created
		
		Thread t1 = new Thread()
		{
		   @Override
		   public void run()
		   {
		     	obj.printTable(5);   
		   }
		};
		
		Thread t2 = new Thread()
		{
		   @Override
		   public void run()
		   {
		     	obj.printTable(10);   
		   }
		};
				
        t1.start();  t2.start();
	}

}

Here both the Threads can't enter inside the synchronized area at a time because we have a single object and synchronized keyword 
demands the lock to enter inside synchronized area.
------------------------------------------------------------------
Program on Block Level Synchronization :
----------------------------------------
package com.ravi.synchronization;

class ThreadName
{
	public void printThreadName()
	{
		String name = Thread.currentThread().getName();
		System.out.println("Thread inside the method is  :"+name);
		
		synchronized(this)
		{
			System.out.println(name+" thread has entered inside Syn Block");
			for(int i=1; i<=10; i++)
			{
				System.out.println(i+" by "+name+" thread");
				try
				{
					Thread.sleep(500);
				}
				catch(InterruptedException e)
				{
					e.printStackTrace();
				}
			}
			System.out.println(name+" thread has completed Syn Block");
		}
		
	}
}

public class BlockLevelSynchronization {

	public static void main(String[] args) 
	{
		ThreadName tn = new ThreadName();
		
        Runnable r1 = ()-> tn.printThreadName();
        
        Thread t1 = new Thread(r1, "Child1");
        Thread t2 = new Thread(r1, "Child2");
        
        t1.start();  t2.start();

	}

}
------------------------------------------------------------------
Limitation of Object level Synchronization :
--------------------------------------------
From the given diagram it is clear that there is no interference between t1 and t2 thread because they are passing throgh Object1 where as on the other hand there is no interferenec even in between t3 and t4 threads because they are also passing through Object2 (another object).

But there may be chance that with t1 Thread (object1), t3 or t4 thread can enter inside the synchronized area at the same time, simillarly it is also possible that with t2 thread, t3 or t4 thread can enter inside the synchronized area so the conclusion is, synchronization mechanism does not work with multiple Objects.(Diagram 28-JAN-25)

package com.ravi.advanced;

class PrintTable
{
	    public synchronized void printTable(int n)
	    {
	       for(int i=1; i<=10; i++)
	       {
	    	   System.out.println(n+" X "+i+" = "+(n*i));
	    	   try
	    	   {
	    		   Thread.sleep(500);
	    	   }
	    	   catch(Exception e)
	    	   {	    		   
	    	   }
	       }
	       System.out.println(".......................");
	    }	
}

public class ProblemWithObjectLevelSynchronization
{
	public static void main(String[] args) 
	{
		
		PrintTable pt1 = new PrintTable(); //lock1 [2, 3]
		PrintTable pt2 = new PrintTable(); //lock2 [8, 9]
		
		Thread t1 = new Thread()  //Anonymous inner class concept
				{
			       @Override
			       public void run()
			       {
			    	   pt1.printTable(2);	//lock1
			       }			   
				};
		       	        
		        Thread t2 = new Thread()
				{
			       @Override
			       public void run()
			       {
			    	   pt1.printTable(3);	//lock1
			       }			   
				};
		                
		        Thread t3 = new Thread()
				{
			       @Override
			       public void run()
			       {
			    	   pt2.printTable(8);	//lock2
			       }			   
				};
		               
		        Thread t4 = new Thread()
				{
			       @Override
			       public void run()
			       {
			    	   pt2.printTable(9); //lock2
			       }			   
				};
				 t1.start();	t2.start();	 t3.start();  t4.start(); 
	}
}

From the above program It is clear that, Synchronization logic can't work with multiple Objects.
-----------------------------------------------------------------
In order to avoid the drawback of Object level synchronization, we introduced "static synchronization".

Static Synchronization :
-------------------------
If we make our synchronized method as static then it is called static synchronization.

For static synchronization "Object is not required". Static method we can call with the help of class name.

In static synchronization, the thread will take the lock from the class but not from the Object. [Every class has a lock]

Unlike objects, We can't create multiple classes in the same package. 

package com.ravi.advanced;

class PrintTable
{
	    //static Synchronization
	    public static synchronized void printTable(int n)
	    {
	       for(int i=1; i<=10; i++)
	       {
	    	   System.out.println(n+" X "+i+" = "+(n*i));
	    	   try
	    	   {
	    		   Thread.sleep(500);
	    	   }
	    	   catch(Exception e)
	    	   {	    		   
	    	   }
	       }
	       System.out.println(".......................");
	    }	
}

public class StaticSynchronization
{
	public static void main(String[] args) 
	{	
		
		Thread t1 = new Thread()  //Anonymous inner class concept
				{
			       @Override
			       public void run()
			       {
			    	  PrintTable.printTable(5);
			       }			   
				};
		       	        
		        Thread t2 = new Thread()
				{
			       @Override
			       public void run()
			       {
			    	   PrintTable.printTable(10);
			       }			   
				};
		                
		        Thread t3 = new Thread()
				{
			       @Override
			       public void run()
			       {
			    	   PrintTable.printTable(15);
			       }			   
				};
		               
		        Thread t4 = new Thread()
				{
			       @Override
			       public void run()
			       {
			    	   PrintTable.printTable(20);
			       }			   
				};
				 t1.start();	t2.start();	 t3.start();  t4.start(); 
	}
}
------------------------------------------------------------------
How to work with synchronized block, If we want to take the lock 
from the class.

synchronized(MyClass.class) //Taking the lock from the class
{

}
--------------------------------------------------------------
29-01-2025
-----------
Thread Priority :
-----------------
It is possible in java to assign priority to a Thread. Thread class has provided two predefined methods setPriority(int newPriority) and getPriority() to set and get the priority of the thread respectively.

In java we can set the priority of the Thread in numbers from 1- 10 only where 1 is the minimum priority and 10 is the maximum priority.

Whenever we create a thread in java by default its priority would be 5 that is normal priority.

The user-defined thread created as a part of main thread will acquire the same priority of main Thread.

Thread class has also provided 3 final static variables which are as follows :-

Thread.MIN_PRIORITY  :- 01

Thread.NORM_PRIORITY : 05

Thread.MAX_PRIORITY  :- 10

Note :- We can't set the priority of the Thread beyond the limit(1-10) so if we set the priority beyond the limit (1 to 10) then it will generate an exception java.lang.IllegalArgumentException.


package com.ravi.priority;

public class PriorityDemo1 {

	public static void main(String[] args) 
	{
		Thread t1 = new Thread();
		System.out.println("Default Priority is :"+t1.getPriority());

	}

}
-------------------------------------------------------------
package com.ravi.priority;

class Priority extends Thread
{
	@Override
	public void run()
	{
		int priority = Thread.currentThread().getPriority();
		System.out.println("Child Thread Priority is :"+priority);

	}
}

public class PriorityDemo2 
{
	public static void main(String[] args) //main group , main thread 
	{
		Thread t = Thread.currentThread();		
		t.setPriority(Thread.MIN_PRIORITY);		
		System.out.println("Main Thread Priority is :"+t.getPriority());
		
		new Priority().start();
	}

}
---------------------------------------------------------------
package com.ravi.priority;

class Foo implements Runnable
{
   @Override
   public void run()
   {
	   int counter = 0;
	   for(int i=1; i<=1000000; i++)
	   {
		   counter++;
	   }
	   
	   int priority = Thread.currentThread().getPriority();
	   String name = Thread.currentThread().getName();
	   
	   System.out.println("Completed thread name is :"+name+" and its priority is :"+priority);
	   
   }
}

public class PriorityDemo3 {

	public static void main(String[] args) 
	{
		Foo f1 = new Foo();
		
		Thread t1 = new Thread(f1,"Last");
		Thread t2 = new Thread(f1,"First");
		
		t1.setPriority(1);
		t2.setPriority(10);
		
		t1.start();  t2.start();

	}

}

Most of time the thread having highest priority will complete its task but we can't say that it will always complete its task first that means Thread schedular dominates Priority of the Thread.
--------------------------------------------------------------
Thread.yield() :
-----------------
Thread.yield() : [To Prevent a thread from over utilization of CPU]
----------------
It is a static method of Thread class.

It will send a notification to thread schedular to stop the currently executing Thread (In Running state) and provide a chance to Threads which are in Runnable state to enter inside the running state having same priority or higher priority than currently executing Thread. 

Here The running Thread will directly move from Running state to Runnable state.

The Thread schedular may accept OR ignore this notification message given by currently executing Thread.

Here there is no guarantee that  after using yield() method the running Thread will move to Runnable state and from Runnable state the thread can move to Running state.[That is the reason yield() method is throwing InterruptedExecption]

If the thread which is in runnable state is having low priority than the current executing thread in Running state, will continue its execution.

*It is mainly used to avoid the over-utilisation a CPU by the current Thread.

package com.ravi.yield;

class Test implements Runnable
{
	@Override
	public void run() 
	{
		String name = Thread.currentThread().getName();
		
		for(int i=1; i<=10; i++)
		{
		   System.out.println("i value is :"+i+" by "+name);	
		   
		   if(name.equals("Child1"))
		   {
			   Thread.yield(); //Give a chance to Child2
		   }
		}
		
	}	
}

public class YieldDemoExample {

	public static void main(String[] args) 
	{
		Test test = new Test();
		
		Thread t1 = new Thread(test,"Child1");
		Thread t2 = new Thread(test,"Child2");
		
		t1.start(); t2.start();

	}

}
-------------------------------------------------------------
30-01-2025
----------
** Inter Thread Communication(ITC) :
------------------------------------
It is a mechanism to communicate or co-ordinate between two synchronized threads within the context to achieve a particular task.

In ITC we put a thread into wait mode by using wait() method and other thread will complete its corresponding task, after completion of the task it will call notify() method so the waiting thread will get a notification to complete its remaining task.

ITC can be implemented by the following method of Object class.

1) public  final void wait() throws InterruptedException

2) public native final void notify()

3) public native final void notifyAll()


public  final void wait() throws InterruptedException :-
-------------------------------------------------------------
It is a predefined non static method of Object class. We can use this method from synchronized area only otherwise we will get java.lang.IllegalMonitorStateException.

It will put a thread into temporarly waiting state and it will release the Object lock, It will remain in the wait state till another thread provides a notification message on the same object, After getting the lock (not notification message), It will wake up and it will complete its remaining task.

public native final void notify() :-
-------------------------------------
It will wake up the single thread that is waiting on the same object.It will not release the lock , once synchronized area is completed then only lock will be released.

Once a waiting thread(wait()) will get the notification from the another thraed using notify()/notifyAll() method then the waiting thread will move from Blocked state to Runnable state(Ready to run state) but it will continue its execution after getting the lock.

public native final void notifyAll() :-
----------------------------------------
It will wake up all the threads which are waiting on the same object.It will not release the lock , once synchronized area is completed then only lock will be released.

IQ :
--
Why wait(), notify() and notifyAll() methods are defined in Object class but not in Thread class.

wait(), notify() and notifyAll() methods are defined in Object class but not in Thread class because in order to use these methods we need synchronized area otherwise it will generate a runtime execption i.e java.lang.IllegalMonitorStateException.

In order to call these methods lock is required (due to synchronized area) and lock is available with Object class hence these methods are defined in Object class but not in Thread class.

IQ :
-----
Difference between sleep() and wait()

Differences are available in paint Diagram [30-JAN]
--------------------------------------------------------------
WAP to show that these method must be used from synchronized area.

package com.ravi.itc;

public class ITCDemo1 
{
  public static void main(String[] args) throws InterruptedException 
  {
	 Object obj = new Object();
	 obj.wait();
	 
	 Thread.State
  }	
	
}
--------------------------------------------------------------
WAP to show that if we don't use any communication b/w the threads then output is un-predictable 

package com.ravi.itc;

class Test extends Thread
{
	private int data = 0;
	
	@Override
	public void run()
	{
		for(int i=1; i<=10; i++)
		{
			this.data = this.data + i;   //0   1   3    6   10   15  21
			
			   try
		       {
		    	   Thread.sleep(100);
		       }
		       catch(InterruptedException e)
		       {
		    	   e.printStackTrace();
		       }
		}
	}
	
	public int getData()
	{
		return this.data;
	}
	
}

public class ITCDemo2 
{
	public static void main(String[] args) throws InterruptedException 
	{
       System.out.println("Main Thread Started...");
       
       Test t1 = new Test();
       t1.start();
       
       try
       {
    	   Thread.sleep(100);
       }
       catch(InterruptedException e)
       {
    	   e.printStackTrace();
       }
       
     
       
      System.out.println(t1.getData());
      
	}

}


Output is un-predictable because there is no co-ordination between main thread and child thread.
-------------------------------------------------------------
package com.ravi.itc;

class Demo extends Thread
{
	private int val = 0;
	
	@Override
	public void run()
	{
		synchronized(this)
		{
			System.out.println("Child Thread got the lock");
			for(int i=1; i<=100; i++)
			{
				this.val = this.val + i;
			}
			System.out.println("Sending Notification..");
			notify();
			
		}
	}
	
	public int getVal()
	{
		return this.val;
	}
	
	
}

public class ITCDemo3 {

	public static void main(String[] args) throws InterruptedException
	{		
		System.out.println("Main Thread Started...");
		
		Demo d1 = new Demo();
		d1.start();
			
		
		synchronized(d1)
		{
		  System.out.println("Main Thread is waiting and lock is released..");
		  d1.wait(); //lock is released
		  System.out.println("Main thread got notification");
		  System.out.println(d1.getVal());
		}
		
		
		
	}

}
--------------------------------------------------------------
package com.ravi.itc;

class Customer
{
	private double balance = 10000;
	
	public synchronized void withdraw(double amount) 
	{
		System.out.println("Going for withdraw..");
		if(amount > this.balance)
		{
			System.err.println("Low Balance, Waiting for deposit");
			try
			{
				wait();
			}
			catch(InterruptedException e)
			{
				e.printStackTrace();
			}
			System.out.println("Got notification, Going to withdraw");
		}
		this.balance = this.balance - amount;
		System.out.println("Reamining Balance after withdraw is :"+this.balance);
	}
	
	public synchronized void deposit(double amount)
	{
		System.out.println("Going to deposit");
		this.balance = this.balance + amount;
		System.out.println("Balance After deposit is :"+this.balance);
		notify();
	}	
}

public class ITCDemo4 
{
	public static void main(String[] args)
	{
		Customer c1 = new Customer();
		
		Thread son = new Thread()
	         {
		   @Override
		   public void run()
		   {
			   c1.withdraw(15000);
		   }
	         };
		
	    son.start();
	    
	    Thread father = new Thread()
	    {
		   @Override
		   public void run()
		   {
			   c1.deposit(10000);
		   }
	    };
		
	      father.start();
 	}

}
-------------------------------------------------------------
31-01-2025
-----------
Is it possible to write wait() and notify() method in a same method.

Yes, We can call wait() and notify() in a single method to perform a particular task.

WAP for Railway Reservation System where few threads can book the tickets and few threads can cancel the ticket.

package com.ravi.itc;

class TicketSystem  
{
    private int availableTickets = 5;   //availableTickets = 5
    
    public synchronized void bookTicket(int numberOfTickets) //numberOfTickets = 4
    {
        while (availableTickets < numberOfTickets) // 5 < 4
        {
           System.out.println("Not enough tickets available, Waiting for cancellation...");
            try 
            {
                wait(); 
            }
            catch (InterruptedException e) 
            {
                e.printStackTrace();
            }
        }
        availableTickets = availableTickets - numberOfTickets;  //5 - 4
        
        System.out.println("Booked " + numberOfTickets + " ticket(s). Remaining tickets: " + availableTickets);
        notify();               
    }

    
  public synchronized void cancelTicket(int numberOfTickets)//numberOfTickets = 2
    {
        availableTickets = availableTickets + numberOfTickets;
        System.out.println("Canceled " + numberOfTickets + " ticket(s). Available tickets: " + availableTickets);
        notify(); 
    }
}


public class ITCDemo5 
{
    public static void main(String[] args) 
    {
        TicketSystem ticketSystem = new TicketSystem(); //lock is created

        Thread bookingThread = new Thread()
        {
        	@Override
            public void run() 
        	{
                int[] ticketsToBook = {2, 4, 4};  
                
                for (int ticket : ticketsToBook) //ticket = 4(3rd iteration)
                {
                    ticketSystem.bookTicket(ticket);
                    try 
                    {
                        Thread.sleep(1000); // give some time b/w booking
                    } 
                    catch (InterruptedException e)
                    {
                        e.printStackTrace();
                    }
                }
        	 }        	
        };
        bookingThread.start();
        
        
        Thread cancellationThread = new Thread()
       	{
        	@Override
            public void run() 
        	{
                int[] ticketsToCancel = {1, 3, 2};
                
                for (int ticket : ticketsToCancel) //ticket = 2
                {
                    ticketSystem.cancelTicket(ticket);
                    try 
                    {
                        Thread.sleep(1500);  // give some time b/w cancellation
                    } 
                    catch (InterruptedException e) 
                    {
                        e.printStackTrace();
                    }
                }
            }
        };
        cancellationThread.start();
            
        
        
    }
}
------------------------------------------------------------------
Program on wait() and notifyAll() method :
-----------------------------------------------------
package com.ravi.itc;

class Resource 
{
    private boolean flag = false;

    public synchronized void waitMethod() 
	{
		System.out.println("Wait");  
		
       	while (!flag)
		{
          try 
		  {
             System.out.println(Thread.currentThread().getName() + " is waiting...");
             System.out.println(Thread.currentThread().getName()+" is Waiting for Notification");
             wait(); //child1  child2  child3
          } 
		  catch (InterruptedException e) 
		  {
                e.printStackTrace();
          }
        }
        System.out.println(Thread.currentThread().getName() + " thread completed!!");
    }

    
    public synchronized void setMethod() 
	{
		System.out.println("notifyAll");
		this.flag = true;
        System.out.println(Thread.currentThread().getName() + " has make flag value as a true");
        notifyAll(); // Notify all waiting threads that the signal is set
    }
}

public class ITCDemo6
{
    public static void main(String[] args) 
		{   	
    	
    	
        Resource r1 = new Resource(); //lock is created

        Thread t1 = new Thread(() -> r1.waitMethod(), "Child1");
		Thread t2 = new Thread(() -> r1.waitMethod(), "Child2");
		Thread t3 = new Thread(() -> r1.waitMethod(), "Child3");

		t1.start();
        t2.start();
        t3.start();
       
		
		Thread setter = new Thread(() -> r1.setMethod(), "Setter_Thread");
      
		   try 
			{
	            Thread.sleep(2000);
	        } 
			catch (InterruptedException e) 
			{
	            e.printStackTrace();
	        }
		
	       setter.start();
    }
}
--------------------------------------------------------------
ThreadGroup :
------------
It is a predefined class available in java.lang Package.

By using ThreadGroup class we can put 'n' number of threads into a single group to perform some common/different operation.

By using ThreadGroup class constructor, we can assign the name of group under which all the thread will be executed.

ThreadGroup tg = new ThreadGroup(String groupName);

ThreadGroup class has provided the following methods :

public String getName() : To get the name of the Group

pubic int activeCount() : How many threads are alive and running under that particular group.

Thread class has provided constructor to put the thread into particular group.

Thread t1 = new Thread(ThreadGroup tg, Runnable target, String name);

By using ThreadGroup class, multiple threads will be executed under single group.
-----------------------------------------------------------------
package com.nit.testing;

class Foo implements Runnable
{
	@Override
	public void run() 
	{
		for(int i=1; i<=10; i++)
		{
			String name = Thread.currentThread().getName();
			System.out.println(i+" by "+name+" Thread");
			try
			{
				Thread.sleep(10);
			}
			catch(InterruptedException e)
			{
				
			}
		}
	}
	
}

public class ThreadGroupDemo1 
{
	public static void main(String[] args) throws InterruptedException 
	{
		ThreadGroup tg = new ThreadGroup("Batch 40");
		
		Thread t1 = new Thread(tg, new Foo(), "Scott");
		Thread t2 = new Thread(tg, new Foo(), "Smith");
		Thread t3 = new Thread(tg, new Foo(), "Alen");
		Thread t4 = new Thread(tg, new Foo(), "John");
		
		t1.start(); t2.start(); t3.start(); t4.start();
		
			
		System.out.println("Group Name is :"+tg.getName());
		System.out.println("Total number of active threads :"+tg.activeCount());
		
		

	}

}
----------------------------------------------------------------
package com.nit.testing;

class Tatkal implements Runnable
{
	@Override
	public void run() 
	{
		String name = Thread.currentThread().getName();
		System.out.println(name+" has booked the ticket under Tatkal Scheme");
	}
	
}

class PremimumTatkal implements Runnable
{
	@Override
	public void run() 
	{
		String name = Thread.currentThread().getName();
		System.out.println(name+" has booked the ticket under PremimumTatkal Scheme");	
	}
	
}


public class ThreadGroupDemo2 {

	public static void main(String[] args)
	{
		ThreadGroup tatkal = new ThreadGroup("Tatkal");
		ThreadGroup premimumTatkal = new ThreadGroup("Premimum_Tatkal");
		
		
		Thread t1 = new Thread(tatkal, new Tatkal(), "Scott");
		Thread t2 = new Thread(premimumTatkal, new PremimumTatkal(), "Raj");
		
		t1.start(); t2.start();

	}

}

package com.nit.testing;

public class ThreadGroupDemo3 {

	public static void main(String[] args) 
	{
		Thread t = Thread.currentThread();
		System.out.println(t.toString());
		
		
		
	}

}

Note : Here we will get the output as Thread[#1,main,5,main]

1     :  Id of the main thread
main  :  Name of the main thread
5     :  default priority of main thread
main  :  Group name, under which main thread is running
==============================================================
01-02-2025
----------
Daemon Thread [Service Level Thread]
------------------------------------
Daemon thread is a low- priority thread which is used to provide background maintenance.  

The main purpose of of Daemon thread to provide services to the user thread.              

JVM can't terminate the program till any of the non-daemon (user) thread is active, once all the user thread will be completed then JVM will automatically terminate all Daemon threads, which are running in the background to support user threads.

The example of Daemon thread is Garbage Collection thread, which is running in the background for memory management.

In order to make a thread as a Daemon thread as well as to verify whether a thread is daemon thread or not, Java software people has provided the following two methods 

1) public void setDaemon(boolean on) : If the boolean value 
   is true the thread will work as a Daemon thread.
   
2) public boolean isDaemon() : Will verify whether the 
   thread is daemon or thread.
   
package com.nit.testing;

class FooThread extends Thread
{
	@Override
	public void run()
	{
	  Thread t = Thread.currentThread();
	  System.out.println("Is it Daemon thread :"+t.isDaemon());	
	}
}

public class DaemonThreadDemo1 {

	public static void main(String[] args) throws InterruptedException 
	{
		System.out.println("Main Thread");
		FooThread ft = new FooThread();
		ft.setDaemon(true);
		ft.start();
        Thread.sleep(2000);		

	}

}
------------------------------------------------------------   package com.nit.testing;

public class DaemonThreadDemo2 {

	public static void main(String[] args) 
	{
		Thread daemonThread = new Thread(()-> 
		{
			while(true)
			{
				String name = Thread.currentThread().getName();
				System.out.println("Running Thread Name is :"+name);
				try
				{
					Thread.sleep(1000);
				}
				catch(InterruptedException e)
				{
					e.printStackTrace();
				}
			}
			
			
		});
		
		daemonThread.setName("Daemon");
	    daemonThread.setDaemon(true);
	    daemonThread.start();
	 
		Thread userThread = new Thread(()-> 
		{
			String name = Thread.currentThread().getName();
			
			for(int i=0; i<=20; i++)
			{
				System.out.println(i+" by "+name);
				try
				{
					Thread.sleep(2000);
				}
				catch(InterruptedException e)
				{
					e.printStackTrace();
				}
			}		
			
		});
		
		userThread.setName("User_Thread");
		userThread.start();
	    

	}

}

Note : In the above program, first user thread will be completed then only JVM will automatically terminate the daemon thread.
------------------------------------------------------------

public void interrupt() Method of Thread class :
--------------------------------------------------
It is a predefined non static method of Thread class. The main purpose of this method to disturb the execution of the Thread, if the thread is in waiting or sleeping state.

Whenever a thread is interupted then it throws InterruptedException so the thread (if it is in sleeping or waiting mode) will get a chance to come out from a particular logic.

Points :-
---------
If we call interrupt method and if the thread is not in sleeping or waiting state then it will behave normally.

If we call interrupt method and if the thread is in sleeping or waiting state then we can stop the thread  gracefully.

*Overall interrupt method is mainly used to interrupt the
thread safely so we can manage the resources easily.

Methods :
---------
1) public void interrupt () :- Used to interrupt the Thread but the thread must be in sleeping or waiting mode.

2) public boolean isInterrupted() :- Used to verify whether thread is interrupted or not.
-------------------------------------------------------------
class Interrupt extends Thread
{
   @Override
   public void run()
	{
	   Thread t = Thread.currentThread();
	   System.out.println("Is thread interrupted : "+t.isInterrupted()); 
       
	   for(int i=1; i<=5; i++)
		{
		   System.out.println(i);  
		   
           try
		   {
			Thread.sleep(1000);
		   }
		   catch (InterruptedException e)
		   {
			   System.err.println(e);
		   }
		   
		}
	}
}
public class  InterruptThread
{
	public static void main(String[] args) 
	{
        Interrupt it = new Interrupt();
		System.out.println("Thread State is "+it.getState());  //NEW
		it.start();
		it.interrupt();  //main thread is interrupting the child thread	
	}
}
--------------------------------------------------------------
class Interrupt extends Thread
{
   @Override
   public void run()
	{
	   try
	   {
	    Thread.currentThread().interrupt(); //self interruption

	   for(int i=1; i<=10; i++)
		{
		   System.out.println("i value is :"+i);
		   Thread.sleep(1000);
		}

	   }
		catch (InterruptedException e)
		{
			System.err.println("Thread is Interrupted :"+e);
		}
		System.out.println("Child thread completed...");
	}
}
public class  InterruptThread1
{
	public static void main(String[] args) 
	{	
		Interrupt it = new Interrupt();
		it.start();	
	}
}

Note : Here loop will be executed only one time.
--------------------------------------------------------------
public class InterruptThread2
{
    public static void main(String[] args) 
	{
        Thread thread = new Thread(new MyRunnable());
        thread.start();
     
        try 
		{
          Thread.sleep(3000); //Main thread is waiting for 3 Sec
        } 
		catch (InterruptedException e) 
		{
            e.printStackTrace();
        }
        
        thread.interrupt();  
    }
}

class MyRunnable implements Runnable 
{
    @Override
    public void run() 
	{
        try 
		{
            while (!Thread.currentThread().isInterrupted())
			{
                System.out.println("Thread is running by locking the resource");
                Thread.sleep(500);
            }
        } 
		catch (Exception e) 
		{
            System.out.println("Thread interrupted gracefully.");
        } 
		finally 
		{
            System.out.println("Thread resource can be release here.");
        }
    }
}
-------------------------------------------------------------
03-02-2025
----------
Deadlock :
------------
It is a situation where two or more than two threads are in blocked state forever, here threads are waiting to acquire another thread resource without releasing it's own resource.

This situation happens when multiple threads demands same resource without releasing its own attached resource so as a result we get Deadlock situation and our execution of the program will go to an infinite state as shown in the diagram. (3-FEB-25)

public class DeadlockExample
	{
  public static void main(String[] args) 
	 {
     String resource1 = new String("Ameerpet");  //(L1)
     String resource2 = new String("S R Nagar"); //(L2) 

    // t1 tries to lock resource1(L1) then resource2(L2)

    Thread t1 = new Thread() 
	 {
	  @Override
      public void run() 
		  {
			  synchronized (resource1) 
				  {
			   System.out.println("Thread 1: locked resource 1");
			      try 
				   { 
				   Thread.sleep(1000);
				   } 
				   catch (Exception e) 
				   {}				  
				
				//t1 thread is waiting here for Lock2
			   synchronized (resource2) //Nested synchronized block
			   {
				System.out.println("Thread 1: locked resource 2");
			   }
             }
      }
    };


    // t2 tries to lock resource2 then resource1
    Thread t2 = new Thread() 
	{
      @Override
      public void run() 
	  {
        synchronized (resource2) 
			{
          System.out.println("Thread 2: locked resource 2");
              try 
			  { 
			  Thread.sleep(1000);
			  } 
			  catch (Exception e) 
			  {}
			
			//t2 thread will wait for L1  (Resourse1)
          synchronized (resource1) //Nested synchronized block
		  {
            System.out.println("Thread 2: locked resource 1");
          }
        }
      }
    };    
    t1.start();
    t2.start();
  }
}

Note : Here this situation is known as Deadlock situation because both the threads are waiting for infinite state.
-------------------------------------------------------------
New Thread life cycle :
-----------------------
New thread life cycle which is available from java 5V. Java 
software people has provided an enum called State (State is an
enum which is defined inside Thread class)

A thread is well known for independent execution, During the life cycle of a thread it passes through different states which are as follows :

1) NEW (Thread Object is created)
2) RUNNABLE (Already Started but waiting for Processor time)
3) BLOCKED (Waiting for lock/Monitor)
4) WAITING (Waiting for another thread without timeout time)
5) TIMED_WAITING (Waiting with timeout time)
6) TERMINATED (Executed run())

NEW :
-----
Whenever we create a thread instance(Thread Object) a thread comes to new state OR born state. New state does not mean that the Thread has started yet only the object or instance of Thread has been created.

RUNNABLE :
-----------
Whenever we call start() method on thread object, A thread moves to Runnable state i.e Ready to run state. Here the thread is considered "alive," but it doesnt immediately start execution unless the CPU scheduler assigns it time.

BLOCKED :
---------
If a thread is waiting for object lock OR monitor to enter inside synchronized area OR re-enter inside synchronized area then it is in blocked state.

WAITING :
---------
A thread in the waiting state is waiting for another thread to
perform a particular action but WITHOUT ANY TIMEOUT time. A thread that has called wait() method on an object is waiting for another thread to call notify() or notifyAll() on the same object OR A thread that has called join() method is waiting for a specified thread to terminate.

TIMED_WAITING :
---------------
A thread in the timed_waiting state, if we call any method which put the thread into temporarly timed_waiting state but WITH POSITIVE TIMEOUT period like sleep(lons ms), join(long ms), wait(long ms) then the Thread is considered as Timed_Waiting state.

TERMINATED :
-------------
The thread has successuflly completed it's execution in the separate stack memory.
--------------------------------------------------------------
In between extends Thread and implements Runnable which one is better and why ?
----------------
In between extends Thread and implements Runnable, implements Runnable is more better approach due to the following reasons 

1) In extends Thread approach, we can't extend any class further because java does not support multiple inheritance using class but on the other hand by using implements Runnbale approach we have a chance to extand only one class.

2) By using extends Thread approach we can't write Lambda 
exaplression but Runnable interface provides Lambda Expression.

3) While working with extends Thread approach, In order to create multiple threads multiple sub class object is required but in implements Runnable approach we can create multiple with a single sub class object. 
------------------------------------------------------------

Volatile Keyword in java :
--------------------------
While working in a multithreaded environment multiple threads can perform read and write operation with common variable (chances of Data inconsistency so use synchronized OR AtomicInteger) concurrently.

In order to store the value temporarly, Every thread is having local cache memory (PC Register) but if we declare a variable with volatile modifier then variable's value is not stored in a thread's local cache; it is always read from the main memory.

So the conclusion is, a volatile variable value is always read from and written directly to the main memory, which ensures that changes made by one thread are visible to all other threads immediately.

package com.nit.testing;

class SharedData
{
    private volatile boolean flag = false;

    public void startThread()
    {
        Thread writer = new Thread(() ->
        {
            try
            {
                Thread.sleep(1000);  //Writer thread will go for 1 sec waiting state
                flag = true;
                System.out.println("Writer thread make the flag value as true");
            }
            catch (InterruptedException e)
            {
                e.printStackTrace();
            }
        });

        
        Thread reader = new Thread(() ->
        {
            while (!flag) //Cache memory still the value of flag is false
            {
               
            }
            System.out.println("Reader thread got the updated value");
        });

        writer.start();
        reader.start();
    }

}

public class VolatileExample
{    
    public static void main(String[] args)
    {
        new SharedData().startThread();
    }
}
--------------------------------------------------------------
Methods of Object class :
-------------------------
protected native Object clone() throws CloneNotSupportedException
---------------------------------------------------------------
Object cloning in Java is the process of creating an exact copy of the original object. In other words, it is a way of creating a new object by copying all the data and attributes from the original object. 

The clone method of Object class creates an exact copy of an object.

In order to use clone() method , a class must implements Clonable interface because we can perform cloning operation on Cloneable objects only [JVM must have additional information] otherwise cloning opertion is not possible and JVM will throw an exception at runtime java.lang.CloneNotSupportedException

We can say an object is a Cloneable object if the corresponding class implements Cloneable interface.

It throws a checked Exception i.e CloneNotSupportedException

Note :- clone() method is not the part of Clonable interface[marker interface], actually it is the method of Object class.

clone() method of Object class follows deep copy concept so hashcode will be different as well as if we modify one object content then another object content will not be modified.

clone() method of Object class has protected access modifier so we need to override clone() method in sub class.

Steps we need to follow to perform clone operation :
----------------------------------------------------
1) The class must implements Cloneable interface
2) Override clone method [throws OR try catch]
3) In this Overridden method call Object class clone method
4) Perform downcasting at the time creating duplicate object
5) Two different objects are created [deep copy]

package com.ravi.clone_operation;

class Customer implements Cloneable
{
	private Integer customerId;
	private String customerName;
	
	public Customer(Integer customerId, String customerName) 
	{
		super();
		this.customerId = customerId;
		this.customerName = customerName;
	}

	public void setCustomerId(Integer customerId) 
	{
		this.customerId = customerId;
		
	}

	public void setCustomerName(String customerName) 
	{
		this.customerName = customerName;
	}

	@Override
	public String toString() {
		return "Customer [customerId=" + customerId + ", customerName=" + customerName + "]";
	}	
	
	@Override
	public Object clone() throws CloneNotSupportedException
	{
		return super.clone();
	}
	
	
	
}

public class ObjectCloningDemo 
{
	public static void main(String[] args) 
	{
		
		try
		{
			Customer c1 = new Customer(111, "Scott");
			Customer c2 = (Customer)c1.clone();
			
			 System.out.println("Before Modification");
	         System.out.println(c1);
	         System.out.println(c2);	
	         
	         
	         System.out.println("After Modification");
	         c2.setCustomerId(222);
	         c2.setCustomerName("Smith");
	         System.out.println(c1);
	         System.out.println(c2);	
	            
	         
		}
		catch(CloneNotSupportedException e)
		{
			System.out.println("JVM does not have any information");
			e.printStackTrace();
		}

	}

}
-----------------------------------------------------------------
04-02-2025
----------
protected void finalize() throws Throwable :
--------------------------------------------
It is a predefined method of Object class.

Garbage Collector automatically call this method just before an object is eligible for garbage collection to perform clean-up activity.

Here clean-up activity means closing the resources associated with that object like file connection, database connection, network connection and so on we can say resource de-allocation.

Note :- JVM calls finalize method only one per object.

         This method is deprecated from java 9V.

//Program

package com.ravi.finalize;

record Product(Integer productId, String productName)
{
	@Override
	public void finalize()
	{
		System.out.println("Product Object is eligible for GC..");
	}
}


public class FinalizeDemo 
{
	public static void main(String[] args) throws InterruptedException 
	{
       Product p1 = new Product(111,"Laptop");
       System.out.println(p1);
       
       p1 = null;
       
       System.gc(); //Calling garbage collector explicitly
       
       Thread.sleep(3000);
       
       System.out.println(p1);

	}

}
-----------------------------------------------------------------
** What is the difference between final, finally and finalize()

final :
-------
It is used to provide some kind of restriction, by using final modifier we can declare our class, Method and variables as a a final.

finally :
---------
If we open any resourse as a part of try block then it should compulsory closed inside finally block, [We we close the resourses inside try block, It is always Risky] for resourse handling purpose.

finalize() :
-------------
It is a method class, We should override this method in the corresponding class to perform cleanup activity, JVM will automatically call this method just before object destruction.
=================================================================












































 







































































































   
   
   
   





























































































































































































































































  
    
  
  
  






















































































 



























   




































































































































  
  
  
  
  
  































































































































 






































































































































      


   
   
   
   
































































































































































































































































   
   
   







































































































































































































































































    
    
    
    

    
    
    























